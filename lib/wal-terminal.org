#+TITLE: Terminal
#+AUTHOR: @Walheimat
#+PROPERTY: header-args:emacs-lisp :tangle (expand-file-name "wal-terminal.el" wal-emacs-config-build-path)

#+BEGIN_QUOTE
I am convinced that we are in a terminal process.
â€” E. P. Thompson
#+END_QUOTE

* Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-terminal.el --- Terminal. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide terminal packages.

;;; Code:

(eval-when-compile
  (require 'wal-useful nil t)
  (require 'wal-package nil t)
  (require 'wal-bridge nil t))

(declare-function project-buffers "ext:project.el")
(declare-function project-current "ext:project.el")
(declare-function project-root "ext:project.el")
(declare-function wdb-faraway "wal-useful.el")

(defvar eshell-buffer-name)
#+END_SRC

* Packages

** with-editor
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package with-editor
  :custom
  (with-editor-mode-lighter " w/e"))
#+END_SRC

* Eshell

#+BEGIN_SRC emacs-lisp
(junk-expand eshell
  "Make eshell feel like a feature-complete shell."
  :packages (eshell-syntax-highlighting))
#+END_SRC

** eshell
:PROPERTIES:
:UNNUMBERED: t
:END:

Set up =eshell=. I like the idea of it but I don't really use it.

*** Utility

#+BEGIN_SRC emacs-lisp
(defun wal-instead-truncate-buffer (&rest _r)
  "Advise to truncate buffer."
  (defvar eshell-buffer-maximum-lines)
  (declare-function eshell-truncate-buffer "ext:eshell.el")

  (let ((eshell-buffer-maximum-lines 0))

    (eshell-truncate-buffer)))

(defun wal-eshell (&optional arg)
  "Run `eshell' in a project-aware way.

ARG is passed to `eshell'."
  (interactive "P")

  (require 'eshell)

  (if-let* ((project (project-current))
            (root (expand-file-name (project-root project))))

      (if-let* ((pattern (concat "\\" (substring eshell-buffer-name 0 -1)))
                (filter (lambda (it) (string-match-p pattern (buffer-name it))))
                (eshell-buffers (seq-filter filter (buffer-list)))
                (find (lambda (it)
                        (let* ((dir (buffer-local-value 'default-directory it))
                               (safe-dir (substring-no-properties dir)))
                          (string-match-p root safe-dir))))
                (containing (seq-find find eshell-buffers)))

          (switch-to-buffer containing)
        (funcall-interactively 'eshell '(4)))

    (eshell arg)))
#+END_SRC

*** Configuration

#+BEGIN_SRC emacs-lisp
(use-package eshell
  :hook
  ((eshell-mode . with-editor-export-editor)
   (eshell-mode . with-editor-export-git-editor))

  :config
  (advice-add
   'eshell/clear :override
   #'wal-instead-truncate-buffer)

  :custom
  (eshell-banner-message (concat
                          (propertize "}< ,.__)" 'face 'mode-line-highlight)
                          "-eshell"
                          "\n\n"))

  :bind
  (("C-c e" . wal-eshell)))
#+END_SRC

** eshell-syntax-highlighting
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package eshell-syntax-highlighting
  :wal-ways nil

  :hook (eshell-mode . eshell-syntax-highlighting-mode))
#+END_SRC

** vterm
:PROPERTIES:
:UNNUMBERED: t
:END:

*** Utility

#+BEGIN_SRC emacs-lisp
(defun wal-vterm (&optional arg)
  "Get a `vterm' buffer.

If called from a project buffer, this only creates a `vterm'
buffer if one doesn't exist yet and ARG is nil."
  (interactive "P")

  (if arg (funcall-interactively 'vterm arg)

    (if-let* ((current (project-current))
              (root (expand-file-name (project-root current))))

        (if-let* ((safe-dir (expand-file-name root))
                  (found (cl-find-if
                          #'(lambda (it)
                              (and (provided-mode-derived-p
                                    (buffer-local-value 'major-mode it)
                                    'vterm-mode)
                                   (string-match-p
                                    safe-dir
                                    (buffer-local-value 'default-directory it))))
                          (buffer-list))))
            (switch-to-buffer found)

          ;; Create a new session.
          (funcall-interactively 'vterm '(4)))

      (funcall-interactively 'vterm))))
#+END_SRC

*** Configuration

#+begin_src emacs-lisp
(use-package vterm
  :wal-ways nil

  :hook
  (vterm-mode . with-editor-export-git-editor)

  :custom
  (vterm-prefix "VTerm")
  (vterm-max-scrollback 10000)

  :general
  (ambassador "t" 'wal-vterm)

  :delight
  (vterm-copy-mode " vcp"))
#+end_src

* Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-terminal)

;;; wal-terminal.el ends here
#+END_SRC
