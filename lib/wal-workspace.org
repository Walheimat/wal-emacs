#+TITLE: Workspace
#+AUTHOR: @Walheimat
#+PROPERTY: header-args:emacs-lisp :tangle (expand-file-name "wal-workspace.el" wal-emacs-config-build-path)

Keep order.

* Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-workspace.el --- Workspace. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide workspace packages.

;;; Code:

(eval-when-compile
  (require 'cl-extra)
  (require 'wal-useful nil t)
  (require 'wal-key-bindings nil t))

(declare-function consult-buffer "ext:consult.el")
(declare-function consult--buffer-query "ext:consult.el")
(declare-function magit-status "ext:magit.el")
(declare-function project-buffers "ext:project.el")
(declare-function project-find-file-in "ext:project.el")
(declare-function project-name "ext:project.el")
(declare-function project-root "ext:project.el")
(declare-function project--value-in-dir "ext:project.el")
(declare-function ring-elements "ext:ring.el")
(declare-function ring-empty-p "ext:ring.el")
(declare-function ring-insert "ext:ring.el")
(declare-function ring-member "ext:ring.el")
(declare-function ring-ref "ext:ring.el")
(declare-function ring-remove+insert+extend "ext:ring.el")
(declare-function wal-plist-keys "wal-useful.el")
(declare-function wal-univ-p "wal-useful.el")
(declare-function wdb-faraway "wal-useful.el")

(defvar compilation-save-buffers-predicate)
(defvar org-agenda-files)

(defgroup wal-workspace nil
  "Change settings used for workspace packages."
  :group 'wal
  :tag "Workspace")
#+END_SRC

* Packages

** project
:PROPERTIES:
:UNNUMBERED: t
:END:

Built-in project management.

*** Utility

#+BEGIN_SRC emacs-lisp
(defvar-local wal-project-parent-project nil
  "The current project's parent project.")
(put 'wal-project-parent-project 'safe-local-variable #'stringp)

(defun wal-project-switch-to-parent-project ()
  "Switch to the current project's parent project."
  (interactive)

  (if-let* ((parent (wal-project-local-value 'wal-project-parent-project)))
      (project-switch-project parent)
    (user-error "You need to set `wal-project-parent-project'")))

(defvar wal-project-commands nil
  "Hash maps for compilation commands.")

(defvar wal-project-current-command nil)
(defvar wal-project-command-history nil)
(defconst wal-project-command-history-length 5)

(defun wal-project-command--buffer-name (_major-mode)
  "Get the buffer name for the current command."
  (if wal-project-current-command
      (concat "*" "project-" wal-project-current-command "*")
    "*project-compile*"))

(defun wal-project-command (cmd &optional arg)
  "Run CMD for the current project.

Each command will be stored in a per-project history. If the
history is non-empty, the user will not be prompted unless called
with a prefix argument ARG.

If the prefix argument ARG is 0, `comint-mode' will be used
instead of `compile-mode'."
  (defvar project-vc-name)

  (let* ((project-vc-name nil)
         (current (project-current t))
         (root (project-root current))
         (name (project-name current))

         (table (plist-get wal-project-commands cmd))

         (history (wal-project-command--history cmd))
         (wal-project-command-history (ring-elements history))

         (initial (unless (ring-empty-p history)
                    (ring-ref history 0)))
         (wal-project-current-command (symbol-name cmd))

         (comint (zerop (prefix-numeric-value arg)))
         (prompt (format "%s project (%s)%s"
                         (capitalize wal-project-current-command)
                         name
                         (if comint " interactively: " ": ")))
         (command (or (and (not arg) initial)
                      (read-shell-command prompt initial 'wal-project-command-history)))

         (default-directory (project-root current))
         (compilation-buffer-name-function 'wal-project-command--buffer-name))

    ;; Store the entered command if not yet/no longer present.
    (if (ring-member history command)
        (ring-remove+insert+extend history command t)
      (ring-insert history command))
    (puthash root history table)

    (compile command comint)))

(defun wal-project-command--history (cmd)
  "Access history for CMD.

If the history doesn't yet exist, create it using the provided
default.

The default can be a string or a list of strings. In the latter
case, they are inserted in reverse order so that the first item
is the default."
  (if-let* ((table (plist-get wal-project-commands cmd))
            (project (project-current))
            (root (project-root project))
            (history (gethash root table)))

      history

    (let* ((var (intern (format "wal-project-%s-default-cmd" cmd)))
           (default (project--value-in-dir var root))
           (new-history (make-ring wal-project-command-history-length)))

      (cond
       ((listp default)
        (mapc (lambda (it) (ring-insert new-history it)) (reverse default)))
       ((stringp default)
        (ring-insert new-history default))
       (t nil))

      (puthash root new-history table)

      new-history)))

(defvar wal-project-prefix-map (make-sparse-keymap))

(cl-defmacro wal-project-create-command (name &key key default)
  "Create command NAME.

The command will be bound using `ambassador' using its initial
unless KEY is provided. If DEFAULT is non-nil, set the initial
value using it. If COMINT is t, make sure the command is run in
`comint-mode' instead."
  (declare (indent defun))

  (let ((function-name (intern (format "wal-project-%s" name)))
        (default-var (intern (format "wal-project-%s-default-cmd" name)))
        (key (or key (substring (symbol-name name) 0 1))))

    `(progn
       (defvar-local ,default-var ,default ,(format "Default for `%s'." function-name))

       (defun ,function-name (&optional arg)
         ,(concat (capitalize (symbol-name name))
                  " the current project.\n\n"
                  "See `wal-project-command' for behavior of ARG.")
         (interactive "P")

         (wal-project-command ',name arg))

       (setq wal-project-commands (plist-put
                                   wal-project-commands
                                   ',name
                                   ,(make-hash-table :test 'equal)))

       (bind-key ,key ',function-name wal-project-prefix-map)
       (put ',default-var 'safe-local-variable #'wal-project-command--valid-default-p))))

(defun wal-project-command--valid-default-p (val)
  "Check if VAL is a valid project command default."
  (or (stringp val)
      (and (listp val)
           (cl-every #'stringp val))))

(defun wal-project-select-command (cmd)
  "Complete and run CMD."
  (interactive
   (list (completing-read "Select command: "
                          (wal-plist-keys wal-project-commands))))

  (wal-project-command (intern cmd)))

(defun wal-with-project-bounded-compilation (fun &rest args)
  "Run FUN applying ARGS.

Makes sure this is done with `compilation-save-buffers-predicate'
set to filter by project buffers."
  (if-let* ((project (project-current nil))
            (buffers (project-buffers project))
            (pred (lambda () (memq (current-buffer) buffers)))
            (compilation-save-buffers-predicate pred))
      (apply fun args)
    (apply fun args)))

(defun wal-project-consult-buffer ()
  "Find an open project buffer using `consult-buffer'."
  (interactive)

  (defvar consult-project-buffer-sources)
  (let ((confirm-nonexistent-file-or-buffer t))

    (consult-buffer consult-project-buffer-sources)))

(defun wal-project-magit-status ()
  "Show `magit-status' for the current project."
  (interactive)

  (if-let* ((current (project-current t))
            (root (project-root current))
            (is-vc (cadr current)))
      (magit-status root)
    (message "Project at '%s' is not version-controlled" root)))

(defun wal-project-dired-root ()
  "Open the root directory using Dired."
  (interactive)

  (let* ((current (project-current t))
         (root (project-root current)))

    (dired root)))

(defun wal-project--buffer-root (buffer)
  "Get the project root for BUFFER."
  (with-current-buffer buffer
    (when-let* ((dir (cond
                      (buffer-file-name
                       (file-name-directory buffer-file-name))
                      (dired-directory dired-directory)
                      (t nil)))
                (project (project-current nil dir)))

      (project-root project))))

(defun wal-project-local-value (symbol &optional project)
  "Get the project-local value of SYMBOL.

Optionally the PROJECT may be passed directly."
  (when-let* ((project (or project (project-current)))
              (root (project-root project)))

    (project--value-in-dir symbol root)))

(defun wal-project-find-in-here (&optional include-all)
  "Find a project file in the current directory.

If INCLUDE-ALL is t, don't ignore otherwise ignored fils."
  (interactive "P")

  (when-let ((project (project-current nil)))

    (project-find-file-in nil (list default-directory) project include-all)))

(defun wal-project-switch-to-tasks ()
  "Switch to the current project's tasks."
  (interactive)

  (when-let* ((marker (wal-org-capture--find-project-tasks-heading))
              (buffer (marker-buffer marker)))

    (switch-to-buffer buffer)))
#+END_SRC

*** Configuration

#+BEGIN_SRC emacs-lisp
(use-package project
  :init
  (wal-advise-many
   'wal-with-project-bounded-compilation :around
   '(project-compile
     recompile
     wal-project-command))

  ;; Allow setting custom names.
  (put 'project-vc-name 'safe-local-variable #'stringp)

  (that-key "project commands" :key "C-c p")

  :config
  (wdb-faraway "\\*project")

  ;; Create common commands.
  (wal-project-create-command build :default "make")
  (wal-project-create-command install :default "make install")
  (wal-project-create-command clean :default "make clean")
  (wal-project-create-command execute)
  (wal-project-create-command test :default '("make test" "make coverage"))

  :custom
  (project-vc-extra-root-markers '("pom.xml"
                                   "package.json"
                                   "project.godot"
                                   "pyproject.toml"
                                   ".project-marker"))

  (project-switch-commands '((project-find-file "Find file" ?f)
                             (project-find-dir "Find dir" ?d)
                             (wal-project-switch-to-tasks "Find tasks" ?t)
                             (wal-project-magit-status "Magit" ?m)
                             (wal-project-consult-buffer "Consult buffer" ?j)
                             (wal-rg-project-literal "Find rg" ?n)
                             (wal-project-dired-root "Find root dir" ?r)
                             (wal-project-select-command "Run command" ?c)))

  (project-vc-ignores '("node_modules/"
                        "build/"
                        "android/"
                        "*.lock"
                        "bundle.js"
                        "*.min.js"
                        "*.js.map"
                        ".ccls-cache/"
                        "coverage/"))

  :bind-keymap
  ("C-c p" . wal-project-prefix-map)

  :bind
  (:map wal-project-prefix-map
   ("C-p" . wal-project-switch-to-parent-project)
   ("C-f" . wal-project-find-in-here)
   ("C-c" . wal-project-switch-to-tasks))

  :wal-bind
  (("h" . project-find-file)))
#+END_SRC

* Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-workspace)

;;; wal-workspace.el ends here
#+END_SRC
