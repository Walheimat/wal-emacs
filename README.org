#+TITLE: Walheimat's Emacs Config
#+AUTHOR: [[https://gitlab.com/Walheimat][@Walheimat]]

[[./assets/logo.png]]

* About

** Heads-Up

This project is my personal literate Emacs[fn:1] configuration.

If you're a complete beginner, you will find [[https://github.com/emacs-tw/awesome-emacs#starter-kit][more user-friendly and
less tailor-made configs]] out there.

Feel free to consider it a jumping-off-point for your own custom
config. Just know that nothing in this config should be considered
/good practice/, it's mostly just how I (think I) like things to be.

** Try-Out

If you're interested in trying out Emacs using my config, here are the
necessary steps:

+ install Emacs if you haven't[fn:2]
+ =git clone= this repository into your =user-emacs-directory=[fn:3]
+ run =load-file= and navigate to =setup/wal-setup=, run =wal/setup=, select
  =init file= and choose =link= or =copy=
+ close and re-run Emacs which should (download and) install all[fn:4]
  packages.

If you do not wish to =clone= this repo in your =user-emacs-directory= or
use the default name, you will need to adapt the variable
=wal/emacs-config-default-path= in the example init file you just
copied.

You can then use =customize-group= to change settings for various
aspects of the config.

** Peculiarities

*** As a Daemon

This config is /daemon-ready/, i.e. if you start Emacs with the =--daemon=
flag, the config will make sure that any customization that requires a
frame will only be loaded once a frame was created.

You can install either a =systemd= service using =wal/setup= (described
above) or just execute =emacs --daemon= in a terminal or your login
shell's configuration.

In any case, an Emacs daemon will start (on start-up). To connect, you
can use, for example, =emacsclient -c -n=[fn:5].

*** Package-Like

#+BEGIN_HTML
<a href='https://coveralls.io/github/Walheimat/emacs-config?branch=trunk'>
    <img
        src='https://coveralls.io/repos/github/Walheimat/emacs-config/badge.svg?branch=trunk'
        alt='Coverage Status'
    />
</a>
#+END_HTML

Custom functions and variables use the =wal/= scope and belong to their
respective section's package. Each package/section defines a group for
customization purposes.

With a few exceptions, each package has a *Header* and a *Footer* that
contains declarations for the package, as well as either a *Packages*
section or several sections grouping packages.

Enough preambling, let's configure some Emacs. The init script will
evaluate /everything/[fn:6] that follows.

* Settings
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-settings.el" wal/emacs-config-package-path)
:END:

Set things up.

Confer also the eponymous [[*Functionality][Functionality]] sections if custom
functionality is used.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-settings.el --- Settings. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; The global settings.

;;; Code:

(eval-when-compile
  (require 'marginalia)
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wal/bytes-per-mb "wal-func.el")
(declare-function wal/create-non-existent-directory "wal-func.el")
(declare-function wal/expansion--stringify "wal-func.el")
(declare-function wal/insert-after "wal-func.el")
(declare-function wal/install-packages "wal-func.el")
(declare-function wal/is-expansion-pack "wal-func.el")
(declare-function wal/maybe-make-directory "wal-func.el")
(declare-function wal/modern-emacs-p "wal-func.el")
(declare-function wal/persist-scratch "wal-key-bindings.el")
(declare-function wal/prefix-user-key "wal-key-bindings.el")
(declare-function wal/rehydrate-scratch "wal-key-bindings.el")
(declare-function wal/reset-to-standard "wal-func.el")
(declare-function wal/set-indent-defaults "wal-func.el")
(declare-function wdb/side "wal-func.el")

(defvar compilation-scroll-output)
(defvar global-auto-revert-non-file-buffers)
(defvar debugger-bury-or-kill)
(defvar display-time-default-load-average)
(defvar display-time-format)
(defvar native-comp-async-report-warnings-errors)
(defvar recentf-filename-handlers)
(defvar so-long-action)
(defvar use-package-defaults)
(defvar use-package-always-defer)
(defvar use-package-always-ensure)
(defvar use-package-compute-statistics)
(defvar wal/flag-doctor)
(defvar wal/flag-mini)
(defvar wal/flag-deny)
(defvar wal/expansion-packs)

(defgroup wal-settings nil
  "Change core settings."
  :group 'wal
  :tag "Settings")

;;;; Customization:

(defcustom wal/cache-directory (expand-file-name ".cache" user-emacs-directory)
  "The cache directory."
  :type 'string
  :group 'wal-settings)

(defcustom wal/site-lisp-directory (expand-file-name "site-lisp" user-emacs-directory)
  "Directory of site Lisp packages."
  :type 'string
  :group 'wal-settings)

(defcustom wal/org-directory (expand-file-name "org" "~")
  "Default directory for org files."
  :type 'string
  :group 'wal-settings)

(defcustom wal/agenda-tasks-directory (expand-file-name "tasks" wal/org-directory)
  "One-size-fits-all directory for agenda tasks."
  :type 'string
  :group 'wal-settings)

(defcustom wal/org-roam-directory (expand-file-name "zettelkasten" wal/org-directory)
  "Directory for Zettelkasten note-taking."
  :type 'string
  :group 'wal-settings)

(defcustom wal/custom-file (expand-file-name "custom.el" user-emacs-directory)
  "Location of the custom file."
  :type 'string
  :group 'wal-settings)

(defcustom wal/indent-offset 4
  "The indent offset in spaces."
  :type 'integer
  :group 'wal-settings)

(defcustom wal/prefer-tabs nil
  "Whether tabs are preferred for indentation."
  :type 'boolean
  :group 'wal-settings)

(defcustom wal/scratch-persist-file (expand-file-name "scratch-persist" wal/cache-directory)
  "The file to persist the *scratch* buffer's content in."
  :type 'string
  :group 'wal-settings)

(defcustom wal/minimal nil
  "Whether to use a minimal configuration."
  :type 'boolean
  :group 'wal-settings)

(defcustom wal/minimal-exclude '()
  "Packages that are not part of a minimal configuration but should be installed."
  :type '(repeat symbol)
  :group 'wal-settings)

(defcustom wal/maximize-new-frames t
  "Whether to maximize new frames by default."
  :type 'boolean
  :group 'wal-settings)

(defcustom wal/ack-warnings nil
  "Acknowledge all warnings."
  :type 'boolean
  :group 'wal-settings)

(defcustom wal/idle-delay 0.4
  "The delay after which helpful information should be shown."
  :type 'float
  :group 'wal-settings)
#+END_SRC

** Personal

Set some personal info[fn:7].

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Krister Schuchardt"
      user-mail-address "krister.schuchardt@gmail.com")
#+END_SRC

** Start-Up

Customize start-up.

#+BEGIN_SRC emacs-lisp
;; Load custom file. Create it if it doesn't yet exist.
(setq custom-file wal/custom-file)
(unless (file-exists-p custom-file)
  (write-region "" nil custom-file))
(load custom-file)

;; Maximize frame.
(setq frame-resize-pixelwise t)
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
(when wal/maximize-new-frames
  (add-to-list 'default-frame-alist '(fullscreen . maximized)))

;; No splash.
(setq inhibit-startup-message t)
(setq initial-major-mode 'fundamental-mode) ; Avoids loading `prog-mode' derivatives.

;; Accept redefinitions.
(setq ad-redefinition-action 'accept)

;; Warn Mac/Windows users.
(unless (or (eq system-type 'gnu/linux) wal/ack-warnings)
  (warn "\
     Warning: Config only tested on Linux. The configuration may
     not work correctly on your system.

     Set `wal/ack-warnings' to t to ignore this warning."))
#+END_SRC

** Packages

Add MELPA to the package archives. Most (if not all) packages will be
installed from there.

#+BEGIN_SRC emacs-lisp
;; Always defer, maybe ensure.
(setq use-package-always-defer t)
(unless wal/flag-deny
  (setq use-package-always-ensure t))

(when wal/flag-doctor
  (setq use-package-compute-statistics t)
  (when (fboundp 'use-package-report)
    (add-hook 'after-init-hook #'use-package-report)))

(wal/insert-after 'use-package-keywords :bind-keymap* :wal-bind)
(wal/insert-after 'use-package-keywords :wal-bind :wal-bind-keymap)

(wal/insert-after 'use-package-keywords :pin :wal-ways)
(add-to-list 'use-package-defaults '(:wal-ways t t))
#+END_SRC

** Directories

Make sure that custom directories exist. We want:

+ A cache directory to store bookmarks etc.
+ a directory for site lisp
+ a default directory for org files
+ a default directory for agenda tasks
+ a default directory for notes.

Also create non-existing directories while finding files.

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook (lambda ()
                                (mapc #'wal/maybe-make-directory
                                      `(,wal/cache-directory
                                        ,wal/site-lisp-directory
                                        ,wal/org-directory
                                        ,wal/agenda-tasks-directory
                                        ,wal/org-roam-directory))))

(add-to-list 'find-file-not-found-functions #'wal/create-non-existent-directory)
#+END_SRC

** Site-Lisp

Add all sub-directories of the site lisp directory to load path (and
custom theme load path). I put non-MELPA packages here.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path wal/site-lisp-directory)

(dolist (project (directory-files wal/site-lisp-directory t "\\w+"))
  (when (file-directory-p project)
    (add-to-list 'load-path project)
    (add-to-list 'custom-theme-load-path project)))
#+END_SRC

** Saving and Backups

Don't clutter up workspaces.

#+BEGIN_SRC emacs-lisp
;; Store backups in backups folder and back up by copying.
(setq backup-directory-alist
      `(("." . ,(expand-file-name (concat user-emacs-directory "backups"))))
      backup-by-copying t)

;; Store autosaves in temp folder.
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))

;; We don't want this to mess with git.
(setq create-lockfiles nil)
#+END_SRC

** Reasonable Values

Make things shorter and snappier. These settings don't belong to
packages.

#+BEGIN_SRC emacs-lisp
(setq read-process-output-max (wal/bytes-per-mb 1)
      echo-keystrokes 0.1

      ;; Undo limits.
      undo-limit (wal/bytes-per-mb 1)
      undo-strong-limit (wal/bytes-per-mb 1.5)
      undo-outer-limit (wal/bytes-per-mb 150)

      ;; Mouse.
      mouse-yank-at-point t

      ;; Native compilation.
      package-native-compile t
      native-comp-async-report-warnings-errors 'silent

      ;; Time.
      display-time-format " %H:%M"
      display-time-default-load-average nil
      save-interprogram-paste-before-kill t

      ;; Mark ring.
      mark-ring-max 32
      global-mark-ring-max 32

      ;; Search.
      isearch-lazy-count t

      ;; Parentheses.
      show-paren-delay 0.1
      show-paren-context-when-offscreen t ; New in Emacs 29.

      ;; Editing.
      backward-delete-char-untabify-method 'hungry

      ;; Otherwise source `consult--source-project-recent-file' won't work.
      recentf-filename-handlers nil)
#+END_SRC

** Global Modes

Any mode that should be on/off no matter what.

#+BEGIN_SRC emacs-lisp
;; A bunch of useful modes.
(show-paren-mode 1)
(global-auto-revert-mode 1)
(save-place-mode 1)
(delete-selection-mode 1)
(column-number-mode 1)
(global-so-long-mode 1)
(savehist-mode 1)
(recentf-mode 1)

;; No need for bars.
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)

;; Emacs 29.
(when (wal/modern-emacs-p)
  (pixel-scroll-precision-mode 1))
#+END_SRC

** Editing

Advise to maybe add hook to delete trailing whitespace.

#+BEGIN_SRC emacs-lisp
(defun wal/then-add-delete-trailing-whitespace-hook (&rest _args)
  "Advise to conditionally add before save hook.

When `wal/delete-trailing-whitespace' is t, trailing whitespace
is deleted."
  (when wal/delete-trailing-whitespace
    (add-hook 'before-save-hook #'delete-trailing-whitespace nil t)))

(advice-add
 'hack-local-variables :after
 #'wal/then-add-delete-trailing-whitespace-hook)
#+END_SRC

** Garbage Collection

Increase the =gc-cons-threshold= after start-up.

#+BEGIN_SRC emacs-lisp
(defun wal/increase-gc-cons-threshold ()
  "Increase `gc-cons-threshold' to maximum on minibuffer setup."
  (setq gc-cons-threshold (wal/bytes-per-mb 100)))

(add-hook 'emacs-startup-hook #'wal/increase-gc-cons-threshold)
#+END_SRC

** Indentation

Set up an easy way to switch between tabs and spaces for indentation.

#+BEGIN_SRC emacs-lisp
(defvar wal/indent-vars '(python-indent-offset
                          js-indent-level
                          css-indent-offset
                          nxml-child-indent
                          tab-width
                          js-encoding-default-indentation
                          electric-indent-inhibit
                          indent-tabs-mode))

(defun wal/reset-indent-defaults ()
  "Reset indent defaults.
Resets all variables that were initially set by
`wal/set-indent-defaults'."
  (interactive)
  (mapc #'wal/reset-to-standard wal/indent-vars))

(add-hook 'emacs-startup-hook #'wal/set-indent-defaults)
#+END_SRC

*** Dir Local Indentation

Sometimes you have to play using other people's rules. You can run
=add-dir-local-variable= to do so. Check out the =.dir-locals.el= template
found in the =/templates= folder for an example using spaces.

** Scratch Buffer

Let's keep the scratch contents.

#+BEGIN_SRC emacs-lisp
;; Empty scratch message.
(setq initial-scratch-message "")

(add-hook 'emacs-startup-hook #'wal/rehydrate-scratch)
(add-hook 'kill-emacs-hook #'wal/persist-scratch)
#+END_SRC

** Command Line

#+BEGIN_SRC emacs-lisp
(wal/capture-flag doctor
  "Will set up `use-package' to collect statistics.")

(wal/capture-flag mini
  "Will packages that are part of the minimal configuration.")

(wal/capture-flag deny
  "Will prevent `use-package' from ensuring packages.")
#+END_SRC

** Minimize Annoyances

Make never leaving Emacs a priority.

#+BEGIN_SRC emacs-lisp
(setq use-dialog-box nil
      disabled-command-function nil
      debugger-bury-or-kill 'kill
      use-short-answers t ; New in Emacs 28. Otherwise you need an alias.
      so-long-action 'so-long-minor-mode)
#+END_SRC

** Expansion Packs

Make completions look nice.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'marginalia
  (defun wal/annotate-expansion-pack (candidate)
    "Annotate CANDIDATE expansion pack."
    (let* ((item (assoc (intern candidate) wal/expansion-packs))
           (docs (plist-get (cdr item) :docs))
           (packages (plist-get (cdr item) :packages))
           (recipes (mapcar #'car (plist-get (cdr item) :recipes)))
           (all-packages (wal/expansion--stringify (append packages recipes)))
           (extras (wal/expansion--stringify (plist-get (cdr item) :extras))))

      (marginalia--fields
       (docs :face 'marginalia-documentation :truncate 0.6)
       (all-packages :face 'marginalia-value :truncate 0.8)
       (extras :face 'marginalia-value :truncate 0.4))))

  (add-to-list 'marginalia-annotator-registry '(expansion-pack wal/annotate-expansion-pack builtin none))
  (add-to-list 'marginalia-command-categories '(wal/install-expansion-pack . expansion-pack)))
#+END_SRC

** Shell Commands

#+BEGIN_SRC emacs-lisp
(wdb/side "^\\*wal-async\\*")
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-settings)

;;; wal-settings.el ends here
#+END_SRC

* Key Bindings
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-key-bindings.el" wal/emacs-config-package-path)
:END:

I use many[fn:8] custom keybindings.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-key-bindings.el --- Key bindings. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Key bindings package.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wal/colonel "wal-key-bindings.el")
(declare-function wal/general "wal-key-bindings.el")
(declare-function wal/general-sink "wal-key-bindings.el")
(declare-function wal/major "wal-key-bindings.el")
(declare-function wal/open-line "wal-func.el")
(declare-function wal/open-line-above "wal-func.el")
(declare-function wal/other-window "wal-func.el")
(declare-function wal/prefix-user-key "wal-func.el")

(defvar wal/ascii-whale)

(defgroup wal-key-bindings nil
  "Change key bindings settings."
  :group 'wal
  :tag "Key bindings")

;;;; Customization:

(defcustom wal/use-hyper-prefix t
  "Whether the hyper modifier should be used to prefix user keys."
  :type 'boolean
  :group 'wal-key-bindings)

;;;;;; American ranks:

(defcustom wal/general-key "'"
  "The primary (or general) leader key."
  :type 'string
  :group 'wal-key-bindings)

(defcustom wal/colonel-key ";"
  "The secondary (or colonel) leader key."
  :type 'string
  :group 'wal-key-bindings)

(defcustom wal/major-key "/"
  "The tertiary (or major) leader key."
  :type 'string
  :group 'wal-key-bindings)

(defcustom wal/captain-key "."
  "The quaternary (or captain) leader key."
  :type 'string
  :group 'wal-key-bindings)

(defcustom wal/lieutenant-key ","
  "The quinary (or lieutenant) leader key."
  :type 'string
  :group 'wal-key-bindings)
#+END_SRC

** Prefix Keys

*** Control

There are some non-standard control sequences. Anywhere:

+ =C->=/=C-<= expands/contracts region
+ =C-.= marks next like this allowing
  + =C-,= to delete last mark and
  + =C-/= to move it downward
+ =C-?= redoes (as =C-/= undoes).

User-reserved combinations are used for certain commands, command maps
and dispatches:

+ =C-c a= for =org-agenda=
+ =C-c b= for a heavy =pulse=
+ =C-c c= does a =completion-at-point=
+ =C-c d= for =docker=
+ =C-c f= for =flycheck=
+ =C-c g= for =smerge=
+ =C-c k= for =kmacro=
+ =C-c m= for =bookmark=
+ =C-c p= for =mu4e=
+ =C-c q= to do a =quick-calc= (inserted if called with =C-u=)
+ =C-c r= for =register=
+ =C-c s= to search with =consult-line=
+ =C-c t= for =vterm=.

When editing this config:

+ =C-c 9= to dispatch related commands.

*** Meta

There are a few non-standard meta sequences.

+ =M-o= does a custom =other-window=.

*** Hyper

Most hyper[fn:9] bindings are quick-access actions:

+ =H-8= calls =kubernetes-overview=
+ =H-h= finds project file
+ =H-i= switches =perspective=
+ =H-j= switches buffer using =consult=
+ =H-k= acts on the current point with =embark= (immediately if called
  with =C-u=)
+ =H-<mouse3>= adds another =multiple-cursor= at point
+ =H-n= searches project with =rg=
+ =H-p= switches projects
+ =H-{[,]}= to toggle and cycle pop-ups using =popper=
+ =H-y= expands snippets (in =yas-minor-mode=).

It's also used for some dispatches:

+ =H-l= for movements, using =mwim= and =avy=
+ =H-m= for =magit=
+ =H-n= for =rg=
+ =H-o= for =ace-window=, and if called with =C-u=
+ =H-<SPC>= for =org-roam=.

**** Caps to Hyper

I re-bound my =<CAPS>= (caps-lock) key to =Hyper_L= to use the hyper
bindings above. Therefore, all following keys should be right hand
keys.

Assuming you use Xorg Display server, create an =.Xmodmap= file in your
home folder containing the following lines.

#+BEGIN_SRC conf :tangle no
! Assign Hyper_L to Caps_Lock
keycode 66 = Hyper_L
! Remove caps lock
remove lock = Caps_Lock
! Set hyper to mod3 from mod4
remove mod4 = Hyper_L
add mod3 = Hyper_L
#+END_SRC

Add a =.xinitrc= file (also in your home folder) containing the
following script:

#+begin_src shell :tangle no
[[ -f ~/.Xmodmap ]] && xmodmap ~/.Xmodmap
#+end_src

This assumes that =Hyper_L= was assigned to modifier =Mod4= that's already
used by =Super_L= and modifier =Mod3= is an empty group.

***** Unsafe Alternative

A much riskier[fn:10] way, provided the recipe above doesn't work,
would be to edit your =/usr/share/X11/xkb/symbols/pc= file like so:

#+BEGIN_SRC :tangle no
...
// key <CAPS> {    [ Caps_Lock     ]   };
key <CAPS> {    [ Hyper_L       ]   };
...
// modifier_map Lock   { Caps_Lock };
modifier_map Mod3   { Hyper_L, Hyper_R };
...
// modifier_map Mod4   { <HYPR> };
modifier_map Mod3   { <HYPR> };
#+END_SRC

** Leader Keys

The are five leader keys (four of them =general= leaders), each serving
its unique purpose by prefixing (groups of) actions by common context.

Some leader keys have so-called sinks for additional commands.

*** General

Leader key =general= (='= by default) is responsible for Emacs actions
like loading a theme, finding a library, quitting, as well as opening
built-in programs like =eshell= and =eww=.

*** Colonel

Leader key =colonel= (=;= by default) provides a layer of useful editing
actions.

They are:

+ =c= to copy a line
+ =d= to duplicate lines
+ =i= for =iedit-mode=
+ =m= to move a line
+ =q= to =query-replace=
+ =.= to mark all "like this"
+ =v= for =vundo= (visual undo)
+ =w= to kill a line
+ =x= to delete a line.

The sink for =colonel= provides alternative version of these calls.

They are:

+ =c= to copy a region
+ =d= to duplicate and comment
+ =h= to mark a region
+ =m= to move a region
+ =q= to =query-replace-regexp=
+ =.= to mark all ends in a region
+ =w= to kill a region
+ =x= to delete a region.

*** Major

Leader key =major= (=.= by default) deals with the global context.

It gives access to minor-mode[fn:11] commands and command maps that are
relevant globally (or for the current perspective). These are:

+ =d= for =dashboard=
+ =i= for =perspective=
+ =p= for =projectile=
+ =w= for =winner=.

*** Captain

Leader key =captain= (=/= by default) deals with the (buffer-)local context.

If the respective buffer-local =minor-mode= is active, the following
command maps are bound

+ =f= for =flycheck=
+ =l= for =lsp-mode=
+ =r= for =verb=
+ =s= for =flyspell=
+ =y= for =yasnippet=.

It also binds =hydra= commands:

+ =@= for =smerge= (if active)
+ =o= to resize the window
+ =t= to scale text
+ =v= to scroll the /other/ window.

It also binds some other commands:

+ =0= to =zone= out
+ =D= to look up word definitions
+ =-= for =consult-minor-mode-menu=
+ =+= for =consult-mode-command=.
+ =w= to toggle =read-only-mode= for buffer.

*** Lieutenant

Leader key =lieutenant= (=,= by default) invokes a dispatch if the
underlying major-mode has it defined.

** Packages

*** general
:PROPERTIES:
:UNNUMBERED: t
:END:

Allows defining custom prefixes.

#+BEGIN_SRC emacs-lisp
(cl-defmacro wal/create-leader-sink (name &key definer prefix)
  "Macro to create a leader sink `NAME-sink'.

NAME is the name of the macro. DEFINER is the definer to create
the sink for and PREFIX is its prefix."
  (declare (indent defun))

  (let* ((defname (symbol-name definer))
         (suffix (substring prefix -1))
         (wk (upcase (concat (substring defname 4) "!"))))

    (progn
      (general-define-key :prefix prefix suffix `(:ignore t :wk ,wk))

      `(defmacro ,name (&rest args)
         `(, ',definer ,@,`(mapcar (lambda (it)
                                     (if (stringp it)
                                         (concat ,suffix it)
                                       it)) args))))))

(cl-defmacro wal/colonel! (key fun mfun &rest args)
  "Bind FUN to KEY, MFUN in the sink.

All ARGS are passed to both definers."
  (declare (indent defun))

  `(progn
    (wal/colonel ,@args ,key ,fun)
    (wal/colonel-sink ,@args ,key ,mfun)))

(defvar wal/leaders '(wal/general wal/colonel wal/major wal/captain))
(defvar wal/leader-with-sink '(wal/general wal/colonel))

(defun wal/general-create-definer (leader)
  "Create a definer for LEADER with a sink."
  (let* ((key-sym (intern (format "%s-key" leader)))
         (key (wal/prefix-user-key (symbol-value key-sym)))
         (sink (intern (format "%s-sink" leader)))
         (name (substring (symbol-name leader) 4)))

    ;; Queue up `which-key' replacements.
    (eval-after-load 'which-key `(which-key-add-key-based-replacements ,key ,name))

    ;; Create the normal definer.
    (eval `(general-create-definer ,leader :prefix ,key))

    ;; Also create the sink for certain leaders.
    (when (memq leader wal/leader-with-sink)
      (eval `(wal/create-leader-sink ,sink :definer ,leader :prefix ,key)))))

(use-package general
  :demand t

  :config
  (mapc #'wal/general-create-definer wal/leaders))
#+END_SRC

*** hydra
:PROPERTIES:
:UNNUMBERED: t
:END:

Provides a context for related commands that can be (re-)executed in
quick succession.

These hydras are mapped to =captain= using the following prefixes:

+ =d= for a minimal set of debugging keys using =dap-mode=
+ =o= to resize window
+ =t= to scale text
+ =v= to scroll other window
+ =w= to undo/redo window configurations using =winner=.

#+BEGIN_SRC emacs-lisp
(defun wal/ascii-whale-hydra-offset (&optional padding)
  "Get a string offset for the `wal/ascii-whale'.
Additional left PADDING can be passed."
  (let ((padd (or padding 0)))

    (make-string (+ padd (length wal/ascii-whale)) ? )))

(use-package hydra
  :demand t)

(with-no-warnings
  ;; Scaling text in buffer.
  (defhydra wal/text-scale (:hint nil)
    "
%s`wal/ascii-whale Text size: _i_ncrease or _d_ecrease.
"
    ("i" text-scale-increase)
    ("d" text-scale-decrease)
    ("r" wal/text-scale-reset "reset" :color blue)
    ("q" nil "quit"))

  ;; Move window splitter or balance windows.
  (defhydra wal/resize-window (:hint nil)
    "
%s(wal/ascii-whale-hydra-offset 25)^_p_^
%s`wal/ascii-whale Move window splitter: _b_   _f_.
%s(wal/ascii-whale-hydra-offset 25)^_n_^
"
    ("b" wal/edge-left)
    ("f" wal/edge-right)
    ("n" wal/edge-down)
    ("p" wal/edge-up)
    ("o" wal/split-window-the-other-way "re-split" :color blue)
    ("l" balance-windows "balance" :color blue)
    ("q" nil "quit"))

  (defhydra wal/scroll-other-window (:hint nil)
    "
%s`wal/ascii-whale Scroll other window: u_p_/dow_n_.
"
    ("p" scroll-other-window-down)
    ("n" scroll-other-window)
    ("q" nil "quit"))

  ;; Move similar to `xah-fly-keys'.
  (defhydra wal/fly (:hint nil :foreign-keys warn)
    "
%s`wal/ascii-whale Fly: ✜ _i_ _j_ _k_ _l_, ⇆ _u_ _o_, ⇄ _h_ _;_, ↷ _n_ _m_ _,_ _._ _/_, ⌦ _s_ _f_ _w_ _r_
"
    ("j" backward-char)
    ("l" forward-char)
    ("i" previous-line)
    ("k" next-line)
    ("u" backward-word)
    ("o" forward-word)
    ("f" delete-char)
    ("s" backward-delete-char)
    ("r" kill-word)
    ("w" backward-kill-word)
    ("h" mwim-beginning)
    (";" mwim-end)
    ("m" avy-goto-end-of-line)
    ("n" avy-goto-line)
    ("," avy-goto-word-0)
    ("." avy-goto-char)
    ("/" wal/avy-goto-word)
    ("q" nil)))
#+END_SRC

*** transient
:PROPERTIES:
:UNNUMBERED: t
:END:

Another nice way of grouping keys.

Some transients are bound directly, others are =wal/univ= variants (see
above).

#+BEGIN_SRC emacs-lisp
(use-package transient
  :demand t

  :custom
  (transient-hide-during-minibuffer-read t)
  (transient-show-popup wal/idle-delay))
#+END_SRC

** Additional (Un-)Bindings

Most bindings are declared in individual packages.

#+BEGIN_SRC emacs-lisp
(wal/on-boot key-bindings

  (wal/captain
    "t" '(wal/text-scale/body :wk "text-scale")
    "o" '(wal/resize-window/body :wk "resize-window")
    "v" '(wal/scroll-other-window/body :wk "scroll-other-window")
    "n" '(display-line-numbers-mode :wk "line numbers"))

  ;; Additional `general' bindings.
  (wal/general
    "e" '(:ignore t :wk "Emacs")
    "eq" '(wal/delete-edit-or-kill :wk "quit")
    "er" '(restart-emacs :wk "restart")
    "f" '(:ignore t :wk "find")
    "fc" '(wal/find-custom-file :wk "custom")
    "fi" '(wal/find-init :wk "init")
    "ff" '(wal/find-fish-config :wk "fish config")
    "fl" '(find-library :wk "library")
    "fw" '(wal/find-config :wk "wal")
    "fp" '(list-processes :wk "processes")
    "s" '(:ignore t :wk "set")
    "sT" '(wal/set-transparency :wk "transparency")
    "sc" '(wal/set-cursor-type :wk "cursor")
    "p" '(:ignore t :wk "package")
    "pf" '(package-refresh-contents :wk "refresh")
    "pi" '(package-install :wk "install")
    "pl" '(list-packages :wk "list")
    "pr" '(package-reinstall :wk "re-install")
    "pd" '(package-delete :wk "delete"))

  (wal/general-sink
   "b" '(eww :wk "eww"))

  (wal/colonel! "q" 'query-replace 'query-replace-regexp)

  (wal/colonel "i" 'iedit-mode)

  (wal/captain "w" 'read-only-mode)

  ;; Use H-u for C-u.
  (when wal/use-hyper-prefix
    (let ((prefix (wal/prefix-user-key "u")))

      (general-define-key prefix 'universal-argument)
      (general-define-key
       :keymaps 'universal-argument-map
       prefix 'universal-argument-more)))

  (global-set-key (kbd "C-?") #'undo-redo)
  (global-set-key (kbd "M-o") #'wal/other-window)
  (global-set-key (kbd "C-;") #'comment-line)
  (global-set-key (kbd "C-c c") #'completion-at-point)

  (defun wal/lieutenant? ()
    "Show message when `wal/lieutenant-key' is not locally bound."
    (interactive)
    (let ((key (propertize (wal/prefix-user-key wal/lieutenant-key) 'face 'success))
          (mode (propertize (symbol-name major-mode) 'face 'success)))
      (message "Lieutenant (%s) has no binding in %s" key mode)))

  (global-set-key (kbd (wal/prefix-user-key wal/lieutenant-key)) #'wal/lieutenant?)

  (global-set-key (kbd (wal/prefix-user-key "l")) #'wal/fly/body)

  ;; Unbinds `save-buffers-kill-terminal'.
  (global-unset-key (kbd "C-x C-c")))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-key-bindings)

;;; wal-key-bindings.el ends here
#+END_SRC

* Functionality
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-func.el" wal/emacs-config-package-path)
:END:

Custom functionality.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-func.el --- Utilities. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provides functions and macros to simplify various configurations.

;;; Code:

(require 'compile)
(require 'map)

(declare-function comint-check-proc "ext:comint.el")
(declare-function marginalia-annotate-binding "ext:marginalia.el")
(declare-function server-edit "ext:server.el")
(declare-function server-edit-abort "ext:server.el")
(declare-function use-package-error "ext:use-package-core.el")
(declare-function use-package-report "ext:use-package-core.el")

(defvar server-buffer-clients)
(defvar use-package-compute-statistics)
(defvar wal/indent-offset)
(defvar wal/prefer-tabs)
(defvar wal/minimal)
(defvar wal/minimal-exclude)
(defvar wal/scratch-persist-file)
(defvar wal/use-hyper-prefix)
(defvar wal/booting)

(defgroup wal-func nil
  "Change values used in utility functions."
  :group 'wal
  :tag "Utility")

;;;; Customization:

(defcustom wal/delete-trailing-whitespace t
  "Whether to delete trailing whitespace."
  :type 'boolean
  :group 'wal-func)
#+END_SRC

** Emacs

#+BEGIN_SRC emacs-lisp
(defun wal/modern-emacs-p ()
  "Set to t if `emacs-major-version' is 28 or higher.

This variable is used to account for certain features (and
bugs)."
  (> emacs-major-version 28))
#+END_SRC

** Directories

Finding files should =mkdir -p= its parents.

#+BEGIN_SRC emacs-lisp
(defun wal/maybe-make-directory (dir)
  "Create DIR unless it exists."
  (unless (file-directory-p dir)
    (make-directory dir)))

;; Creating parent dirs.
(defun wal/create-non-existent-directory ()
  "Ask whether to create non-existent directory.
If a file is found in a not (yet) existing directory, ask if it
should get created."
  (let ((parent-directory (file-name-directory buffer-file-name)))

    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Create non-existing directory `%s'? " parent-directory)))
      (make-directory parent-directory t))))
#+END_SRC

** Buffer Display

Utility functions to configure displaying buffers of a certain type.

#+BEGIN_SRC emacs-lisp
(defun wal/display-buffer-condition (buffer-or-mode)
  "Get a display buffer condition for BUFFER-OR-MODE."
  (pcase buffer-or-mode
    ((pred stringp) buffer-or-mode)
    ((pred symbolp) `(major-mode . ,buffer-or-mode))
    (_ (user-error "Call with string or symbol"))))

(defun wal/display-buffer-in-pop-up (buffer &optional in-frame)
  "Display BUFFER in a pop-up.
The pop-up is a window unless IN-FRAME is t."
  (let ((condition (wal/display-buffer-condition buffer))
        (action (if in-frame
                     'display-buffer-pop-up-frame
                   'display-buffer-pop-up-window)))

    (add-to-list 'display-buffer-alist `(,condition (,action)))))

;; The next two functions make sense for `popper' buffers.

(cl-defun wal/display-buffer-in-side-window (buffer &key side loose no-other height)
  "Display BUFFER in SIDE window.

This window will be on SIDE (on the bottom by default), not
delete other windows, dedicated to the buffer (unless LOOSE),
available to `other-window' (unless NO-OTHER) 20 (or HEIGHT)
lines high and visible frames are considered reusable."
  (let ((condition (wal/display-buffer-condition buffer)))

    (add-to-list 'display-buffer-alist
                 `(,condition
                   (display-buffer-reuse-window display-buffer-in-side-window)
                   (side . ,(or side 'bottom))
                   (dedicated . ,(not loose))
                   (reusable-frames . visible)
                   (window-height . ,(or height 10))
                   (window-parameters . ((no-other-window . ,no-other)))))))

(defun wal/display-buffer-in-direction (buffer &optional direction)
  "Display BUFFER in direction.
The direction is right-most or DIRECTION."
  (let ((condition (wal/display-buffer-condition buffer)))

    (add-to-list 'display-buffer-alist
                 `(,condition
                   (display-buffer-reuse-mode-window display-buffer-in-direction)
                   (direction . ,(or direction 'rightmost))))))

(defun wal/display-buffer-ethereally (buffer)
  "Display BUFFER ethereally.

This means there is no display function used and the mode line is
removed."
  (let ((condition (wal/display-buffer-condition buffer)))

    (add-to-list 'display-buffer-alist
                 `(,condition
                   nil
                   (window-parameters (mode-line-format . none))))))

(defun wal/display-buffer-reuse-same-window (buffer)
  "Display BUFFER reusing same window."
  (let ((condition (wal/display-buffer-condition buffer)))

    (add-to-list 'display-buffer-alist
                 `(,condition
                   (display-buffer-reuse-window display-buffer-same-window)))))

;; Prefer short-hands.
(defalias 'wdb/pop-up 'wal/display-buffer-in-pop-up)
(defalias 'wdb/side 'wal/display-buffer-in-side-window)
(defalias 'wdb/direction 'wal/display-buffer-in-direction)
(defalias 'wdb/ghost 'wal/display-buffer-ethereally)
(defalias 'wdb/same 'wal/display-buffer-reuse-same-window)
#+END_SRC

** Editing

More convenient editing.

#+BEGIN_SRC emacs-lisp
(defun wal/kill-ring-save-whole-buffer ()
  "Call `kill-ring-save' on the entire buffer."
  (interactive)
  (kill-ring-save (point-min) (point-max)))

(defconst wal/cursor-types '(box hollow bar hbar)
  "Cursor types that can be set using `completing-read'.")

(defun wal/set-cursor-type (&optional reset)
  "Set the `cursor-type'.

Optionally RESET the type when called with `universal-argument'."
  (interactive "P")
  (if reset
      (setq-local cursor-type t)
    (let* ((type-string (completing-read "Select cursor type: " wal/cursor-types))
           (type (intern type-string)))

      (setq-local cursor-type type))))
#+END_SRC

** Windows

I keep messing up, splitting vertically when I meant horizontally.
This is inspired by [[https://github.com/purcell/emacs.d/blob/master][purcell's config]].

#+BEGIN_SRC emacs-lisp
(defun wal/split-window-the-other-way ()
  "Split window the other way.
This means if horizontally split, split vertically; if vertically
split, split horizontally."
  (interactive)
  (let* ((other-buffer (and (next-window) (window-buffer (next-window))))
         (win (selected-window))
         (split-direction (cond ((or (windows-sharing-edge win 'above)
                                     (windows-sharing-edge win 'below))
                                 'vert)
                                ((or (windows-sharing-edge win 'right)
                                     (windows-sharing-edge win 'left))
                                 'hori)
                                (t nil))))

    (delete-other-windows)

    (pcase split-direction
      ('vert (split-window-horizontally))
      ('hori (split-window-vertically))
      (_ nil))

    (when other-buffer
      (set-window-buffer (next-window) other-buffer))))

(defun wal/edge (scale-above scale-below)
  "Move the window splitter using SCALE-ABOVE and SCALE-BELOW."
  (interactive)
  (let* ((win (selected-window))
         (direction (cond ((windows-sharing-edge win 'above) scale-above)
                          ((windows-sharing-edge win 'below) scale-below)
                          (t nil))))

    (pcase direction
      ('enlarge (wal/enlarge-window))
      ('shrink (wal/shrink-window))
      (_ (message "Selected window does not share a vertical edge with another window")))))

(defun wal/edge-horizontally (scale-left scale-right)
  "Move the window splitter using SCALE-LEFT and SCALE-RIGHT."
  (interactive)
  (let* ((win (selected-window))
         (direction (cond ((windows-sharing-edge win 'left) scale-left)
                          ((windows-sharing-edge win 'right) scale-right)
                          (t nil))))

    (pcase direction
      ('enlarge (wal/enlarge-window-horizontally))
      ('shrink (wal/shrink-window-horizontally))
      (_ (message "Selected window does not share a horizontal edge with another window")))))

(defun wal/edge-left ()
  "Move the splitter of the selected window left.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge-horizontally 'enlarge 'shrink))

(defun wal/edge-right ()
  "Move the splitter of the selected window right.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge-horizontally 'shrink 'enlarge))

(defun wal/edge-up ()
  "Move the splitter of the selected window up.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge 'enlarge 'shrink))

(defun wal/edge-down ()
  "Move the splitter of the selected window down.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge 'shrink 'enlarge))

(defun wal/shrink-window (&optional horizontally)
  "Shrink the selected window (HORIZONTALLY)."
  (interactive)
  (let* ((available (window-min-delta (selected-window) horizontally))
         (chunk (floor (* available 0.2))))

    (if horizontally
        (shrink-window-horizontally chunk)
      (shrink-window chunk))))

(defun wal/shrink-window-horizontally ()
  "Shrink the selected window horizontally."
  (interactive)
  (wal/shrink-window t))

(defun wal/enlarge-window (&optional horizontally)
  "Enlarge the selected window (HORIZONTALLY)."
  (interactive)
  (let* ((available (window-max-delta (selected-window) horizontally))
         (chunk (floor (* available 0.2))))

    (if horizontally
        (enlarge-window-horizontally chunk)
      (enlarge-window chunk))))

(defun wal/enlarge-window-horizontally ()
  "Enlarge the selected window horizontally."
  (interactive)
  (wal/enlarge-window t))

(defun wal/other-window (&optional prefer-frame)
  "Switch to other window.

If the minibuffer is active, switch to that. If there's another
frame, switch to that if PREFER-FRAME is true. Otherwise switch
to next buffer."
  (interactive "P")
  (cond
   ((active-minibuffer-window)
    (switch-to-minibuffer))
   ((and (not (equal (next-frame) (selected-frame)))
         (or prefer-frame (one-window-p)))
    (other-frame 1))
   ((one-window-p)
    (switch-to-buffer nil))
   (t
    (other-window 1))))

(defun wal/l (&optional reverse)
  "Dedicate the window to the current buffer.

Un-dedicates if REVERSE is t."
  (interactive "P")
  (let ((window (selected-window))
        (buffer (current-buffer)))

    (if reverse
        (progn
         (set-window-dedicated-p window nil)
         (message "Window no longer dedicated to %s" buffer))
    (set-window-dedicated-p window buffer)
    (message "Dedicating window to %s" buffer))))
#+END_SRC

** Files

Handling of files.

#+BEGIN_SRC emacs-lisp
(defun wal/find-custom-file ()
  "Find the custom file."
  (interactive)
  (switch-to-buffer (find-file-noselect (file-truename custom-file))))


(defconst wal/fish-config-locations '("~/.config/fish/config.fish"
                                      "~/.config/omf"))

(defun wal/find-fish-config ()
  "Find the fish shell config file."
  (interactive)
  (let* ((files wal/fish-config-locations)
         (init-file (cl-find-if
                     'file-exists-p
                     (mapcar 'expand-file-name files))))

    (if init-file
        (switch-to-buffer (find-file-noselect (file-truename init-file)))
      (user-error "Couldn't find fish config file"))))
#+END_SRC

** Command Line

Capture custom command line flags.

#+BEGIN_SRC emacs-lisp
(defvar wal/flag-doctor nil)
(defvar wal/flag-mini nil)
(defvar wal/flag-deny nil)

(defconst wal/custom-flags '((doctor . "--doctor")
                             (mini . "--mini")
                             (deny . "--deny"))
  "Alist of custom flags that can be passed to Emacs.")

(defmacro wal/capture-flag (flag docs)
  "Check for custom FLAG.

DOCS will be passed on to `message'.

This will delete the flag from the command line arguments and set
the associated variable."
  (declare (indent defun) (doc-string 2))
  `(when-let* ((flags wal/custom-flags)
               (dash-flag (cdr (assoc ',flag flags)))
               (found (member dash-flag command-line-args)))

     (message ,docs)

     (setq command-line-args (delete dash-flag command-line-args))
     (setq ,(intern (concat "wal/flag-" (symbol-name flag))) t)))
#+END_SRC

** Text Scaling

Allow resetting =text-scale=.

#+BEGIN_SRC emacs-lisp
(defun wal/text-scale-reset ()
  "Reset `text-scale' level to 0."
  (interactive)
  (text-scale-set 0))
#+END_SRC

** Lists

Manipulating lists.

#+BEGIN_SRC emacs-lisp
(defun wal/append (target seq)
  "Set TARGET to it with SEQ appended.

Duplicate items are removed."
  (let ((val (symbol-value target)))

    (set target (delq nil (delete-dups (append val seq))))))

(defun wal/replace-in-alist (target values)
  "Edit TARGET alist in-place using VALUES."
  (let ((val (symbol-value target)))

    (if (seq-every-p (lambda (it) (assoc (car it) val)) values)
        (seq-each (lambda (it) (map-put! val (car it) (cdr it))) values)
      (user-error "All keys must already be present in list"))))

(defun wal/insert-after (target preceding item)
  "Insert ITEM in TARGET after PRECEDING."
  (let ((val (symbol-value target)))

    (when (memq item val)
      (user-error "Item is already in target"))

    (if (memq preceding val)
        (let* ((remainder (nthcdr (cl-position preceding val) val)))

          (setcdr remainder (cons item (cdr remainder))))
      (user-error "Can't insert, preceding key not in list"))))
#+END_SRC

** Commands

Make function calls even more versatile.

#+BEGIN_SRC emacs-lisp
(cl-defmacro wal/univ (a b)
  "Define a prefix-modified function for A.

It will call B instead if the default `universal-argument' is
present. It will again call A with `universal-argument' if the
function is called with two `C-u' or more.

Both functions will be called interactively."
  (declare (indent defun))

  (let ((a-name (symbol-name a))
        (b-name (symbol-name b)))

    `(defun ,(intern (concat "wal/univ-" a-name)) (&optional call-other)
       ,(concat (format "Call `%s' or `%s' depending on prefix argument."
                        a-name
                        b-name)
                "\n"
                "No argument means: call the prior. "
                "A single `C-u' means: call the latter. "
                "Two or more `C-u' means: call the prior with `universal-argument'.")
       (interactive "P")
       (if (> (prefix-numeric-value call-other) 4)
           (call-interactively ',a)
         (setq current-prefix-arg nil)
         (prefix-command-update)

         (if call-other
             (call-interactively ',b)
           (call-interactively ',a))))))
#+END_SRC

** Scratch Buffer

Make the scratch buffer contents persist between sessions.

#+BEGIN_SRC emacs-lisp
(defun wal/persist-scratch ()
  "Persist contents of *scratch* buffer.
The contents are stored in `wal/scratch-persist-file'."
  (with-current-buffer (get-buffer-create "*scratch*")
    (write-region (point-min) (point-max) wal/scratch-persist-file)))

(defun wal/rehydrate-scratch ()
  "Re-hydrate scratch buffer (if persisted).
This overrides the scratch buffer with the content stored in
`wal/scratch-persist-file'."
  (when (file-exists-p wal/scratch-persist-file)
    (with-current-buffer (get-buffer "*scratch*")
      (delete-region (point-min) (point-max))
      (insert-file-contents wal/scratch-persist-file))))
#+END_SRC

** Indentation

Toggle indentation, allow for automatic activation from local
variables.

#+BEGIN_SRC emacs-lisp
(defun wal/disable-tabs ()
  "Disable tabs.

Sets variable `indent-tabs-mode' to nil."
  (interactive "p")
  (setq indent-tabs-mode nil))

(defun wal/enable-tabs ()
  "Enable tabs.

Sets tab variable `indent-tabs-mode' to t."
  (interactive)
  (setq indent-tabs-mode t))

(cl-defun wal/maybe-enable-tabs (&key indent-with)
  "Maybe enable tabs.

Optionally set `indent-line-function' to INDENT-WITH."
  (when indent-with
    (setq-local indent-line-function indent-with))

  (if wal/prefer-tabs
      (wal/enable-tabs)
    (wal/disable-tabs)))

(defun wal/set-indent-defaults (&optional num)
  "Set indent defaults.
All offsets are set to `wal/indent-offset' or optionally to NUM."
  (interactive "nSet tab width to: ")
  (let ((offset (or num wal/indent-offset)))

    (setq-default python-indent-offset offset
                  js-indent-level offset
                  css-indent-offset offset
                  nxml-child-indent offset
                  tab-width offset
                  json-encoding-default-indentation (make-string offset ? )
                  electric-indent-inhibit t
                  indent-tabs-mode wal/prefer-tabs)))
#+END_SRC

** Helpers

Some more helper functions.

#+BEGIN_SRC emacs-lisp
(defun wal/biased-random (limit &optional bias-low throws)
  "Return a biased random number using LIMIT.

The bias is the high end unless BIAS-LOW is passed. The number of
throws are 3 or THROWS."
  (let ((results (list))
        (throws (or throws 3)))

    (dotimes (_i throws)
      (push (random limit) results))

    (if bias-low
        (seq-min results)
      (seq-max results))))

(defun wal/bytes-per-mb (num)
  "Return the integer value of NUM megabytes in bytes.

This function may be used to set variables that expect bytes."
  (floor (* 1024 1024 num)))

(defun wal/maybe-intern (symbol?)
  "Maybe `intern' SYMBOL? if it's not a symbol."
  (if (symbolp symbol?)
      symbol?
    (intern symbol?)))

(defun wal/truncate (text &optional max-len)
  "Truncate TEXT if longer than MAX-LEN.

Truncates to 8 characters if no MAX-LEN is provided."
  (let ((len (or max-len 8)))

    (if (> (length text) len)
        (concat (substring text 0 (max (- len 3) 1)) "...")
      text)))

(defun wal/pad-string (string &optional right)
  "Advise to pad STRING.

Padding is on the left unless RIGHT is t."
  (let ((trimmed (string-trim string))
        (padding " "))

    (if right
        (concat trimmed padding)
      (concat padding trimmed))))

(defun wal/univ-p ()
  "Check if the `current-prefix-arg' is the `universal-argument'.

This is mainly useful for non-interactive functions."
  (equal current-prefix-arg '(4)))

(defun wal/reset-to-standard (sym &optional locally)
  "Reset symbol SYM to its standard value.
If LOCALLY is t, the local variable is killed while its global
value is left untouched."
  (if locally
      (if (local-variable-p sym)
          (kill-local-variable sym)
        (user-error "'%s' has no local binding" sym))
    (set-default sym (eval (car (get sym 'standard-value))))))

(defmacro wal/try (package &rest body)
  "Exceute BODY if PACKAGE can be required."
  (declare (indent 1))
  `(when (require ',package nil :no-error) ,@body))

(defun wal/server-edit-p ()
  "Check if we're (likely) editing from outside of Emacs.

We also make sure we're not in `with-editor-mode' as to not to
intefere with `magit' and friends."
  (and (bound-and-true-p server-buffer-clients)
       (not (bound-and-true-p with-editor-mode))))

(defun wal/delete-edit-or-kill (&optional abort)
  "Delete frame, be done (or ABORT) or kill Emacs."
  (interactive "P")
  (cond
   ((wal/server-edit-p)
    (if abort (server-edit-abort) (server-edit)))
   ((daemonp)
    (delete-frame))
   (t
    (save-buffers-kill-terminal))))

(defun wal/dead-shell-p ()
  "Check if the current buffer is a shell or comint buffer with no process."
  (let ((buffer (current-buffer)))

    (with-current-buffer buffer
      (and (derived-mode-p 'comint-mode)
           (not (comint-check-proc buffer))))))

(defun wal/prefix-user-key (user-key)
  "Prefix USER-KEY.

The default prefix is the hyper key unless Emacs is not running
in GUI mode or `wal/use-hyper-prefix' is nil."
  (let ((prefix (if (and wal/use-hyper-prefix
                         (or (daemonp) (display-graphic-p)))
                    "H-"
                  "C-c w ")))

    (concat prefix user-key)))

(defmacro wal/on-boot (name &rest body)
  "Only expand BODY in NAME on boot."
  (declare (indent defun))
  (if (bound-and-true-p wal/booting)
      `(progn ,@body)
    `(message "Ignoring statements in '%s'" ',name)))
#+END_SRC

** Setup

Allow differentiating between initial and repeated setups.

#+BEGIN_SRC emacs-lisp
(defmacro wal/when-ready (&rest body)
  "Execute BODY when Emacs is ready."
  (if (daemonp)
      `(add-hook 'server-after-make-frame-hook (lambda () ,@body))
    `(add-hook 'emacs-startup-hook (lambda () ,@body))))

(defvar wal/setup-list '()
  "List of already performed setups.")

(cl-defmacro wal/define-init-setup (name docs &key initial always immediately)
  "Define an initial setup for NAME documented by DOCS.

The INITIAL setup is only run once. The ALWAYS one on every call.

In daemon-mode the function may be called IMMEDIATELY. An
appropriate hook is chosen for the original call."
  (declare (indent defun) (doc-string 2))
  (let ((func-name (intern (concat "wal/init-setup-" (symbol-name name)))))

    `(progn
       (defun ,func-name ()
         ,(format "Do base setup for %s. Do minimal setup on repeats.\n%s" name docs)
         (unless (memq ',name wal/setup-list)
           (progn
             (message "Initial setup of '%s'" ,(symbol-name name))
             ,@initial
             (add-to-list 'wal/setup-list ',name)))
         ,@always)
       (if (daemonp)
           (progn
             (when ,immediately
               (funcall ',func-name))
             (add-hook 'server-after-make-frame-hook #',func-name))
         (add-hook 'emacs-startup-hook #',func-name)))))
#+END_SRC

** Regions

Act on regions.

#+BEGIN_SRC emacs-lisp
(defun wal/duck-duck-go-region ()
  "Query duckduckgo with active region."
  (interactive)
  (if mark-active
      (let* ((beg (region-beginning))
             (end (region-end))
             (str (buffer-substring-no-properties beg end))
             (hex-str (url-hexify-string str)))

        (browse-url
         (concat "https://duckduckgo.com/html/?q=" hex-str)))
    (user-error "No active region")))
#+END_SRC

** Messages

Show messages without cluttering.

#+BEGIN_SRC emacs-lisp
(defconst wal/ascii-whale (propertize "}< ,.__)" 'face 'mode-line-emphasis)
  "A small, highlighted ASCII whale.")

(defun wal/message-in-a-bottle (bottle)
  "Randomly display a message from the given BOTTLE.

That bottle is just an array of strings."
  (let* ((message-log-max nil) ; Don't clutter.
         (message (nth (wal/biased-random (length bottle)) bottle)))

    (message (concat
              wal/ascii-whale
              " "
              (propertize message 'face 'italic)))))
#+END_SRC

** Expansion Packs

Some packages are opt-in (will not be ensured) and belong to one or
several so-called expansion packs[fn:12].

#+BEGIN_SRC emacs-lisp
(defvar wal/expansion-packs nil
  "Packs of expansion packages to be installed using `wal/install-expansion-pack'.

Individual languages build this list using macro
`wal/define-expansion-pack'.")

(cl-defun wal/install-packages (packages &key delete-windows)
  "Install all PACKAGES unless already installed.

Returns the number of newly installed packages.

Calls `delete-other-windows' if DELETE-WINDOWS is t."
  (let ((new-packages (seq-filter
                       (lambda (it) (not (package-installed-p it)))
                       packages)))

    (mapc (lambda (it) (package-install it)) new-packages)

    (when delete-windows
      (delete-other-windows))

    (length new-packages)))

(defun wal/install-recipes (recipes)
  "Install packages from RECIPES using `quelpa'.

Returns the number of newly installed packages."
  (let* ((new-packages (seq-filter
                        (lambda (it) (not (package-installed-p (car it))))
                        recipes)))

    (mapc (lambda (it) (quelpa it)) new-packages)

    (length new-packages)))

(cl-defmacro wal/define-expansion-pack (name docs &key packages extras recipes)
  "Define an expansion pack of PACKAGES under NAME.

Documented using DOCS.

Optionally provide `quelpa' RECIPES."
  (declare (indent defun) (doc-string 2))
  `(add-to-list
    'wal/expansion-packs
    '(,name . (:packages ,packages :extras ,extras :docs ,docs :recipes ,recipes))))

(defun wal/expansion-packs ()
  "Get a list of all expansion packs."
  (seq-reduce
   (lambda (acc it)
     (let* ((package-list (cdr it))
            (normal (plist-get package-list :packages))
            (extras (plist-get package-list :extras))
            (recipes (mapcar #'car (plist-get package-list :recipes))))

       (append acc normal extras recipes)))
   wal/expansion-packs '()))

(defun wal/is-expansion-pack (pack)
  "Check if PACK is an expansion pack package."
  (memq pack (wal/expansion-packs)))

(defun wal/install-expansion-pack-extra (pack)
  "Install an or all extras of an expansion for PACK."
  (let* ((extras (plist-get (cdr pack) :extras))
         (selection (wal/maybe-intern
                     (completing-read
                      "Select extra to install: " (append extras '(all))))))

    (pcase selection
      ('all
       (wal/install-packages extras)
       (message "Installed all extras."))
      (_
       (wal/install-packages (list selection))
       (message (format "Installed extra '%s'." selection))))))

(defun wal/install-expansion-pack (pack)
  "Install the given expansion PACK."
  (interactive
   (list (completing-read "Select pack to install: "
                          (mapcar (lambda (pack) (car pack)) wal/expansion-packs))))
  (let* ((sym (wal/maybe-intern pack))
         (item (assoc sym wal/expansion-packs))
         (packages (plist-get (cdr item) :packages))
         (recipes (plist-get (cdr item) :recipes))
         (extras (plist-get (cdr item) :extras)))

    (if (not item)
        (user-error "Unknown pack '%s', check `wal/expansion-packs'" sym)
      (let* ((installed-packages (wal/install-packages packages :delete-windows t))
             (installed-recipes (wal/install-recipes recipes)))

        ;; Notify about what happened.
        (if (= 0 (+ installed-packages installed-recipes))
            (message "All core packages/recipes already installed.")
          (message "Installed expansion pack '%s'" pack))

        (when (and extras (yes-or-no-p "Want to install an extras?"))
          (wal/install-expansion-pack-extra item))))))

(defun wal/expansion--stringify (package-list)
  "Stringify PACKAGE-LIST."
  (if package-list
      (mapconcat (lambda (it) (format "%s" it)) package-list ", ")
    ""))
#+END_SRC

** Hooks

#+BEGIN_SRC emacs-lisp
(defvar prog-like-hook nil
  "Commands that should be run for prog-like modes.")

(cl-defmacro wal/hook (name docs &body body &key messages lsp lsp-ignores tabs prog-like lieutenant &allow-other-keys)
  "Hook into major mode NAME, describe with DOCS.

MESSAGES is a list of strings to randomly choose from and
display.

LSP is either t or nil. LSP-IGNORES are additional paths to add
to variable `lsp-file-watch-ignored-directories'.

TABS is either nil, t or a symbol. Unless the symbol is `always',
tabs are enabled using `wal/maybe-enable-tabs', passing it to the
function as an indentation function.

LIEUTENANT is either t or nil. If it is t, a prefixed function
will be mapped to the lieutenant key.

The rest of the BODY will be spliced into the lambda."
  (declare (indent defun) (doc-string 2))

  (let ((target (intern (concat (symbol-name name) "-hook")))
        (safe-body (cl-loop for (key val) on body by 'cddr
                            unless (memq key '(:messages :lsp :lsp-ignores :tabs :prog-like :lieutenant))
                            collect key
                            and collect val))
        (func-name (intern (concat "wal/" (symbol-name name) "-hook")))
        (lieutenant-name (intern (concat "wal/" (symbol-name name) "-dispatch"))))

    `(progn
       ,@(delete
          nil
          `((defun ,func-name ()
              ,docs
              ,@(delete
                 nil
                 `(,(when messages
                      `(wal/message-in-a-bottle ,messages))
                   (hack-local-variables)
                   ,(cond ((equal 'always tabs)
                           `(wal/enable-tabs))
                          ((equal t tabs)
                           `(wal/maybe-enable-tabs))
                          ((not tabs)
                           '(wal/disable-tabs))
                          (t `(wal/maybe-enable-tabs :indent-with ,tabs)))
                   ,@safe-body
                   ,(when lsp
                      '(wal/lsp))
                   ,(when prog-like
                      '(run-hooks 'prog-like-hook))
                   ,(when lieutenant
                      `(local-set-key (kbd (wal/prefix-user-key wal/lieutenant-key)) ',lieutenant-name)))))
            ,(when (and lsp lsp-ignores)
               `(with-eval-after-load 'lsp-mode
                  (wal/append 'lsp-file-watch-ignored-directories ,lsp-ignores)))
            (add-hook
             ',target
             ',func-name))))))
#+END_SRC

** Additional Mode Controls

Turning on/off certain major modes switching between =major-mode= and
=fundamental-mode=.

#+BEGIN_SRC emacs-lisp
(defvar-local wal/before-fundamental-mode nil
  "The major mode before fundamental was engaged.")

(defun wal/fundamental-mode ()
  "Switch from `major-mode' to `fundamental-mode' and back."
  (interactive)
  (let ((m-mode major-mode))

    (if wal/before-fundamental-mode
        (progn
          (funcall wal/before-fundamental-mode)
          (setq-local wal/before-fundamental-mode nil))
      (fundamental-mode)
      (setq-local wal/before-fundamental-mode m-mode))))
#+END_SRC

** Shell Commands

#+BEGIN_SRC emacs-lisp
(defun wal/async-process (command callback error-callback &optional interrupt)
  "Start async process COMMAND with CALLBACK and ERROR-CALLBACK.

Optonally, interrupt any running process if INTERRUPT is t."
  (when interrupt (wal/async-process--maybe-interrupt))

  (let ((finalizer (wal/async-process--finalize callback error-callback)))

    (with-current-buffer (compilation-start
                          command t
                          #'wal/async-process--buffer-name)
      (view-mode 1)
      (add-hook 'compilation-finish-functions finalizer nil t))))

(defun wal/async-process--maybe-interrupt ()
  "Interrupt process without erroring."
  (when-let* ((comp-buffer (compilation-find-buffer))
              (proc (get-buffer-process comp-buffer)))
    (interrupt-process proc)))

(defun wal/async-process--buffer-name (_mode-name)
  "Generate a buffer name for MODE-NAME."
  (generate-new-buffer-name "*wal-async*"))

(defun wal/async-process--finalize (callback error-callback)
  "Get finalizer that will call CALLBACK or ERROR-CALLBACK."
  (lambda (_buf status)
       (if (string= "finished\n" status)
           (condition-case err
               (funcall callback)
             (error
              (funcall error-callback (error-message-string err))))
         (funcall error-callback (string-trim status)))))

(defun wal/kill-async-process-buffers ()
  "Kill all async process buffers."
  (interactive)
  (dolist (buf (buffer-list))
    (with-current-buffer buf
      (when (string-match "^\\*wal-async" (buffer-name))
        (when-let ((window (get-buffer-window buf)))
          (delete-window window))
        (kill-buffer buf)))))
#+END_SRC

** Strings

#+BEGIN_SRC emacs-lisp
(defun wal/matches-in-string (regexp str)
  "Return all matches of REGEXP in STR."
  (let ((matches nil))
    (with-temp-buffer
      (insert str)
      (goto-char (point-min))
      (while (re-search-forward regexp nil t)
        (push (match-string 1) matches)))
    matches))
#+END_SRC

** Advice

#+begin_src emacs-lisp
(defun wal/advise-many (advice combinator advised)
  "Advise ADVISED using ADVICE and COMBINATOR."
  (mapc (lambda (it) (advice-add it combinator advice)) advised))
#+end_src

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-func)

;;; wal-func.el ends here
#+END_SRC

** Tests
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "test/wal-func-test.el" wal/emacs-config-package-path)
:VISIBILITY: folded
:END:

*** Header

#+BEGIN_SRC emacs-lisp
;;; wal-test.el --- Tests for custom functionality. -*- lexical-binding: t; -*-

;;; Commentary:
;;
;; Tests for the custom functionality.

;;; Code:
#+END_SRC

*** Emacs

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/modern-emacs-p ()
  (let ((emacs-major-version 27))
    (should-not (wal/modern-emacs-p)))

  (let ((emacs-major-version 29))
    (should (wal/modern-emacs-p))))
#+END_SRC

*** Directories

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/maybe-make-directory ()
  (let ((temp-dir "/tmp/some-dir"))
    (wal/maybe-make-directory temp-dir)

    (should (f-directory-p temp-dir))
    (should-not (wal/maybe-make-directory temp-dir))

    (delete-directory temp-dir)))

(ert-deftest test-wal/create-non-existent-directory ()
  (let ((temp-dir "/tmp/some-other/dir/"))
    (with-mock-all ((file-name-directory . (lambda (&rest _r) temp-dir))
                    (y-or-n-p . (lambda (&rest _r) t))
                    (make-directory . (lambda (dir _) dir)))
      (should (string-equal temp-dir (wal/create-non-existent-directory))))))

(ert-deftest test-wal/create-non-existent-directory--aborts ()
  (let ((temp-dir "/tmp/some-other/dir/"))
    (make-directory temp-dir t)
    (with-mock file-name-directory (lambda (&rest _r) temp-dir)
      (should-not (wal/create-non-existent-directory)))
    (delete-directory temp-dir)))
#+END_SRC

*** Buffer Display

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/display-buffer-condition--passes-strings ()
  (should (string-equal "testing" (wal/display-buffer-condition "testing"))))

(ert-deftest test-wal/display-buffer-condition--considers-symbols-major-modes ()
  (should (equal '(major-mode . test-mode) (wal/display-buffer-condition 'test-mode))))

(ert-deftest test-wal/display-buffer-condition--errors-for-unsupported-types ()
  (should-error (wal/display-buffer-condition '(hello world)) :type 'user-error))

(ert-deftest test-wal/display-buffer-in-pop-up ()
  (let ((display-buffer-alist '()))
    (wal/display-buffer-in-pop-up 'test-mode)
    (should (equal
             (car display-buffer-alist)
             '((major-mode . test-mode) (display-buffer-pop-up-window))))
    (setq display-buffer-alist '())
    (wal/display-buffer-in-pop-up 'test-mode t)

    (should (equal
             (car display-buffer-alist)
             '((major-mode . test-mode) (display-buffer-pop-up-frame))))))

(ert-deftest test-wal/display-buffer-in-side-window ()
  (let ((display-buffer-alist '()))
    (wal/display-buffer-in-side-window 'test-mode :side 'top :loose nil :no-other t :height 12)
    (should (equal (car display-buffer-alist)
                   '((major-mode . test-mode)
                     (display-buffer-reuse-window display-buffer-in-side-window)
                     (side . top)
                     (dedicated . t)
                     (reusable-frames . visible)
                     (window-height . 12)
                     (window-parameters . ((no-other-window . t))))))))

(ert-deftest test-wal/display-buffer-in-direction ()
  (let ((display-buffer-alist '()))
    (wal/display-buffer-in-direction 'test-mode 'leftmost)
    (should (equal (car display-buffer-alist)
                   '((major-mode . test-mode)
                     (display-buffer-reuse-mode-window display-buffer-in-direction)
                     (direction . leftmost))))))

(ert-deftest test-wal/display-buffer-ethereally ()
  (let ((display-buffer-alist '()))
    (wal/display-buffer-ethereally 'test-mode)
    (should (equal (car display-buffer-alist)
                   '((major-mode . test-mode)
                     nil
                     (window-parameters . ((mode-line-format . none))))))))

(ert-deftest wal/display-buffer-reuse-same-window ()
  (let ((display-buffer-alist '()))
    (wal/display-buffer-reuse-same-window 'test-mode)
    (should (equal (car display-buffer-alist)
                   '((major-mode . test-mode)
                     (display-buffer-reuse-window display-buffer-same-window))))))
#+END_SRC

*** Editing

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/kill-ring-save-buffer ()
  (with-temp-buffer
    (insert "I hope I don't get killed")
    (wal/kill-ring-save-whole-buffer)
    (should (string-equal "I hope I don't get killed" (car kill-ring)))))

(ert-deftest test-wal/set-cursor-type--sets-and-resets ()
  (with-temp-buffer
    (with-mock completing-read (lambda (_str _types) "hollow")
      (wal/set-cursor-type)
      (should (eq cursor-type 'hollow)))
    (wal/set-cursor-type t)
    (should (eq cursor-type t))))
#+END_SRC

*** Windows

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/split-window-the-other-way ()
  (with-temp-buffer
    (save-window-excursion
      (split-window-horizontally)
      (wal/split-window-the-other-way)
      (should (windows-sharing-edge (selected-window) 'below)))
    (save-window-excursion
      (split-window-horizontally)
      (other-window 1)
      (wal/split-window-the-other-way)
      (should (windows-sharing-edge (selected-window) 'below)))
    (save-window-excursion
      (split-window-vertically)
      (wal/split-window-the-other-way)
      (should (windows-sharing-edge (selected-window) 'right)))))

(ert-deftest test-wal/edge--no-edges ()
  (with-temp-buffer
    (save-window-excursion
      (with-mock message (lambda (m &rest _r) m)
        (should (string-equal "Selected window does not share a vertical edge with another window" (wal/edge-up)))
        (should (string-equal "Selected window does not share a horizontal edge with another window" (wal/edge-right)))))))

(ert-deftest test-wal/edge-down ()
  (with-temp-buffer
    (save-window-excursion
      (split-window-vertically)
      (let ((prev-size (window-size)))
        (wal/edge-down)
        (should (< prev-size (window-size)))))))

(ert-deftest test-wal/edge-up ()
  (with-temp-buffer
    (save-window-excursion
      (split-window-vertically)
      (other-window 1)
      (let ((prev-size (window-size)))
        (wal/edge-up)
        (should (< prev-size (window-size)))))))

(ert-deftest test-wal/edge-right ()
  (with-temp-buffer
    (save-window-excursion
      (split-window-horizontally)
      (let ((prev-size (window-size (selected-window) t)))
        (wal/edge-right)
        (should (< prev-size (window-size (selected-window) t)))))))

(ert-deftest test-wal/edge-left ()
  (with-temp-buffer
    (save-window-excursion
      (split-window-horizontally)
      (other-window 1)
      (let ((prev-size (window-size (selected-window) t)))
        (wal/edge-left)
        (should (< prev-size (window-size (selected-window) t)))))))

(ert-deftest test-wal/other-window ()
  (with-mock-all ((active-minibuffer-window . (lambda () t))
                  (switch-to-minibuffer . (lambda () 'mini)))
                 (should (equal (wal/other-window) 'mini)))
  (with-mock-all ((active-minibuffer-window . (lambda () nil))
                  (next-frame . (lambda () 'other))
                  (other-frame . (lambda (_) 'frame)))
                 (should (equal (wal/other-window) 'frame)))
  (with-mock-all ((active-minibuffer-window . (lambda () nil))
                  (next-frame . (lambda () (selected-frame)))
                  (one-window-p . (lambda () nil))
                  (other-window . (lambda (_) 'window)))
                 (should (equal (wal/other-window) 'window)))
  (with-mock-all ((active-minibuffer-window . (lambda () nil))
                  (next-frame . (lambda () (selected-frame)))
                  (one-window-p . (lambda () t))
                  (switch-to-buffer . (lambda (_) 'buffer)))
                 (should (equal (wal/other-window) 'buffer)))
  (with-mock-all ((active-window-buffer . (lambda () nil))
                  (next-frame . (lambda () 'other))
                  (other-frame . (lambda (_) 'frame))
                  (one-window-p . (lambda () nil))
                  (other-window . (lambda (_) 'otherw)))
    (should (equal (wal/other-window t) 'frame))
    (should (equal (wal/other-window) 'otherw)))
  (with-mock-all ((active-window-buffer . (lambda () nil))
                  (next-frame . (lambda () 'other))
                  (other-frame . (lambda (_) 'frame))
                  (one-window-p . (lambda () t)))
    (should (equal (wal/other-window t) 'frame))
    (should (equal (wal/other-window) 'frame))))

(ert-deftest test-wal/l ()
  (with-temp-buffer
    (wal/l)
    (should (window-dedicated-p))
    (wal/l t)
    (should-not (window-dedicated-p))))
#+END_SRC

*** Files

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/find-custom-file ()
  (let ((custom-file "/tmp/custom.el"))
    (make-empty-file custom-file)
    (wal/find-custom-file)
    (should (string-equal (buffer-name) "custom.el"))
    (delete-file custom-file)))

(ert-deftest test-wal/find-fish-config ()
  (let* ((fish-config "/tmp/config.fish")
         (wal/fish-config-locations `(,fish-config)))
    (make-empty-file fish-config)
    (wal/find-fish-config)
    (should (string-equal (buffer-name) "config.fish"))
    (delete-file fish-config)))

(ert-deftest test-wal/find-fish-config--errors-if-not-found ()
  (defvar wal/fish-config-locations)
  (let ((wal/fish-config-locations '()))
    (should-error (wal/find-fish-config) :type 'user-error)))
#+END_SRC

*** Command Line

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/capture-flag ()
  (match-expansion
   (wal/capture-flag some-flag
     "We need to capture some flag.")
   `(when-let* ((flags wal/custom-flags)
                (dash-flag (cdr (assoc 'some-flag flags)))
                (found (member dash-flag command-line-args)))
      (message "We need to capture some flag.")

      (setq command-line-args (delete dash-flag command-line-args))
      (setq wal/flag-some-flag t))))
#+END_SRC

*** Text Scaling

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/text-scale-reset ()
  (with-temp-buffer
    (text-scale-increase 4)
    (should (eq text-scale-mode-amount 4))
    (wal/text-scale-reset)
    (should (eq text-scale-mode-amount 0))))
#+END_SRC

*** Lists

#+BEGIN_SRC emacs-lisp
(defvar test-target nil)

(ert-deftest test-wal/append--appends ()
  (let ((test-target '(a b c))
        (sequence '(d e f)))

    (wal/append 'test-target sequence)
    (should (equal test-target '(a b c d e f)))))

(ert-deftest test-wal/append--removes-duplicates ()
  (let ((test-target '(a b c))
        (sequence '(c d a)))

    (wal/append 'test-target sequence)
    (should (equal test-target '(a b c d)))))

(ert-deftest test-wal/replace-in-alist--replaces ()
  (let ((test-target '((a . "whale") (b . "home")))
        (values '((b . "heimat"))))

    (wal/replace-in-alist 'test-target values)
    (should (equal test-target '((a . "whale") (b . "heimat"))))))

(ert-deftest test-wal/replace-in-alist--refuses-new-keys ()
  (let ((test-target '((a . "whale") (b . "home")))
        (values '((b . "heimat") (c . "dolphin"))))

    (should-error (wal/replace-in-alist 'test-target values) :type 'user-error)
    (should (equal test-target '((a . "whale") (b . "home"))))))

(ert-deftest test-wal/insert-after--inserts ()
  (let ((test-target '(hello my old friend))
        (preceding 'hello)
        (item 'darkness))

    (wal/insert-after 'test-target preceding item)
    (should (equal test-target '(hello darkness my old friend)))))

(ert-deftest test-wal/insert-after--errors-if-key-not-in-list ()
  (let ((test-target '(hello my old friend))
        (preceding 'darkness)
        (item 'hello-again))

    (should-error (wal/insert-after 'test-target preceding item) :type 'user-error)))
#+END_SRC

*** Commands

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/univ ()
  (match-expansion
    (wal/univ some-fun other-fun)
    `(defun wal/univ-some-fun (&optional call-other)
       "Call `some-fun' or `other-fun' depending on prefix argument.\nNo argument means: call the prior. A single `C-u' means: call the latter. Two or more `C-u' means: call the prior with `universal-argument'."
       (interactive "P")
       (if (> (prefix-numeric-value call-other) 4)
           (call-interactively 'some-fun)
         (setq current-prefix-arg nil)
         (prefix-command-update)
         (if call-other
             (call-interactively 'other-fun)
           (call-interactively 'some-fun))))))
#+END_SRC

*** Scratch Buffer

#+BEGIN_SRC emacs-lisp
(defvar wal/scratch-persist-file (expand-file-name "scratch-persist" default-directory))

(ert-deftest test-wal/persist-scratch-and-rehydrate ()
  (with-current-buffer (get-buffer-create "*scratch*")
    (erase-buffer)
    (insert "This one's itchy"))

  (wal/persist-scratch)

  (let ((file (find-file-noselect wal/scratch-persist-file)))

    (with-current-buffer file
      (should (string-equal "This one's itchy" (buffer-string)))))

  (with-current-buffer (get-buffer-create "*scratch*")
    (erase-buffer)
    (should (string-equal "" (buffer-string)))
    (wal/rehydrate-scratch)
    (should (string-equal "This one's itchy" (buffer-string))))

  (delete-file wal/scratch-persist-file))
#+END_SRC

*** Indentation

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/disable-tabs--disables ()
  (with-temp-buffer
    (setq-local indent-tabs-mode t)
    (wal/disable-tabs)
    (should (eq indent-tabs-mode nil))))


(ert-deftest test-wal/enable-tabs--enables ()
  (with-temp-buffer
    (setq-local indent-tabs-mode nil)
    (should (eq indent-tabs-mode nil))
    (wal/enable-tabs)
    (should (eq indent-tabs-mode t))))


(ert-deftest test-wal/maybe-enable-tabs--enables-if-tabs-preferred ()
  (with-temp-buffer
    (setq-local wal/prefer-tabs t)
    (wal/maybe-enable-tabs)
    (should (eq indent-tabs-mode t))))

(ert-deftest test-wal/maybe-enable-tabs--sets-function ()
  (with-temp-buffer
    (setq-local wal/prefer-tabs nil)
    (wal/maybe-enable-tabs :indent-with 'some-fun)
    (should (eq indent-line-function 'some-fun))))

(ert-deftest test-wal/maybe-enable-tabs--disables-unless-preferred ()
  (with-temp-buffer
    (setq-local wal/prefer-tabs nil)
    (wal/maybe-enable-tabs)
    (should (eq indent-tabs-mode nil))))


(defvar wal/indent-offset 6)
(ert-deftest test-wal/set-indent-defaults ()
  (setq wal/prefer-tabs nil)

  (wal/set-indent-defaults 1)
  (should (eq python-indent-offset 1))
  (should (eq js-indent-level 1))
  (should (eq css-indent-offset 1))
  (should (eq tab-width 1))
  (should (string-equal json-encoding-default-indentation " "))
  (should electric-indent-inhibit)
  (should-not indent-tabs-mode)
  (wal/set-indent-defaults)
  (should (eq python-indent-offset 6))
  (should (eq js-indent-level 6))
  (should (eq css-indent-offset 6))
  (should (eq tab-width 6))
  (should (string-equal json-encoding-default-indentation "      "))
  (should electric-indent-inhibit)
  (should-not indent-tabs-mode))
#+END_SRC

*** Helpers

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/biased-random ()
  (let ((vals '(1 2 3 4)))
    (with-mock random (lambda (_) (pop vals))
      (should (eq (wal/biased-random 4) 3))

      (setq vals '(1 2 3 4))
      (should (eq (wal/biased-random 4 t) 1)))))


(ert-deftest test-wal/bytes-per-mb--floors ()
  (should (equal 314572 (wal/bytes-per-mb 0.3))))


(ert-deftest test-wal/maybe-intern--interns-non-symbol ()
  (should (eq 'test (wal/maybe-intern "test"))))

(ert-deftest test-wal/maybe-intern--leaves-symbols ()
  (should (eq 'test (wal/maybe-intern 'test))))


(ert-deftest test-wal/truncate--truncates ()
  (should (string-equal (wal/truncate "This is it" 7) "This...")))

(ert-deftest test-wal/truncate--truncates-without-len ()
  (should (string-equal (wal/truncate "This is it") "This ...")))

(ert-deftest test-wal/truncate--leaves-as-is-if-below ()
  (should (string-equal (wal/truncate "This is it" 24) "This is it")))


(ert-deftest test-wal/pad-string--pads ()
  (let ((test-string "hello"))
    (should (equal " hello" (wal/pad-string test-string)))))

(ert-deftest test-wal/pad-string--pads-right ()
  (let ((test-string "hello"))
    (should (equal "hello " (wal/pad-string test-string t)))))


(ert-deftest test-wal/univ-p ()
  (let ((current-prefix-arg '(4)))
    (should (wal/univ-p))))


(defvar test-standard 'standard)

(ert-deftest test-wal/reset-to-standard--resets ()
  (setq test-standard 'global)
  (should (equal 'global test-standard))
  (wal/reset-to-standard 'test-standard)
  (should (equal nil test-standard))
  (should-error (wal/reset-to-standard 'test-standard t) :type 'user-error)
  (with-temp-buffer
    (setq-local test-standard 'local)
    (wal/reset-to-standard 'test-standard t)
    (should (equal nil test-standard))))

(ert-deftest test-wal/try ()
  (match-expansion
    (wal/try test
     (message "Testing again"))
    `(when (require 'test nil :no-error)
       (message "Testing again"))))


(ert-deftest test-wal/server-edit-p ()
  (defvar server-buffer-clients)
  (defvar with-editor-mode)
  (let ((server-buffer-clients '(test))
    (should (wal/server-edit-p))))
  (let ((server-buffer-clients '(test))
        (with-editor-mode t))
    (should-not (wal/server-edit-p)))
  (let ((server-buffer-clients '(test))
        (with-editor-mode nil))
    (should (wal/server-edit-p))))


(ert-deftest test-wal/delete-edit-or-kill ()
  (with-mock-all ((wal/server-edit-p . (lambda () t))
                  (server-edit-abort . (lambda () 'abort))
                  (server-edit . (lambda () 'edit)))
    (should (equal (wal/delete-edit-or-kill) 'edit))
    (should (equal (wal/delete-edit-or-kill t) 'abort)))

  (with-mock-all ((wal/server-edit-p . (lambda () nil))
                  (daemonp . (lambda () t))
                  (delete-frame . (lambda () 'delete-frame)))
    (should (equal (wal/delete-edit-or-kill) 'delete-frame)))

  (with-mock-all ((wal/server-edit-p . (lambda () nil))
                  (daemonp . (lambda () nil))
                  (save-buffers-kill-terminal . (lambda () 'kill)))
    (should (equal (wal/delete-edit-or-kill) 'kill))))


(require 'shell)

(ert-deftest test-wal/dead-shell-p ()
  (with-temp-buffer
    (shell-mode)
    (should (wal/dead-shell-p))))


(ert-deftest test-wal/prefix-user-key ()
  (defvar wal/use-hyper-prefix)
  (cl-letf (((symbol-function 'daemonp) #'always)
            (wal/use-hyper-prefix t))
    (should (string-equal (wal/prefix-user-key "k") "H-k")))

  (cl-letf (((symbol-function 'daemonp) #'ignore)
            (wal/use-hyper-prefix t))
    (should (string-equal (wal/prefix-user-key "k") "C-c w k"))))
#+END_SRC

*** Setup

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/when-ready ()
  (with-mock daemonp (lambda () nil)
    (match-expansion
      (wal/when-ready (message "No demon ..."))
      `(add-hook 'emacs-startup-hook (lambda () (message "No demon ...")))))
  (with-mock daemonp (lambda () t)
    (match-expansion
      (wal/when-ready (message "Demon!"))
      `(add-hook 'server-after-make-frame-hook (lambda () (message "Demon!"))))))

(ert-deftest test-wal/define-init-setup ()
  (match-expansion
    (wal/define-init-setup test
      "Nothing else."
      :initial
      ((message "Hello"))
      :always
      ((message "Bye"))
      :immediately t)
    `(progn
       (defun wal/init-setup-test ()
         "Do base setup for test. Do minimal setup on repeats.\nNothing else."
         (unless (memq 'test wal/setup-list)
           (progn
            (message "Initial setup of '%s'" "test")
            (message "Hello")
            (add-to-list 'wal/setup-list 'test)))
         (message "Bye"))
      (if (daemonp)
          (progn
            (when t
              (funcall 'wal/init-setup-test))
            (add-hook 'server-after-make-frame-hook #'wal/init-setup-test))
        (add-hook 'emacs-startup-hook #'wal/init-setup-test)))))
#+END_SRC

*** Regions

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/duck-duck-go-region--succeeds-if-region ()
  (with-temp-buffer
    (insert "where is my mind")
    (set-mark (point-min))
    (goto-char (point-max))
    (with-mock browse-url (lambda (url &rest _r) url)
      (should (string-equal
               (wal/duck-duck-go-region)
               "https://duckduckgo.com/html/?q=where%20is%20my%20mind")))))

(ert-deftest test-wal/duck-duck-go-region--fails-if-no-region ()
  (should-error (wal/duck-duck-go-region) :type 'user-error))
#+END_SRC

*** Messages

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/message-in-a-bottle ()
  (let ((bottle '("Sting is playing bass, yeah")))

    (with-mock message (lambda (message) message)
      (should (string-equal (wal/message-in-a-bottle bottle) "}< ,.__) Sting is playing bass, yeah")))))
#+END_SRC

*** Expansion Packs

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/install-packages ()
  (with-mock-all ((package-install . (lambda (package) package))
                  (package-installed-p . (lambda (package) (memq package '(three)))))
    (should (eq 2 (wal/install-packages '(one two) :delete-windows t)))
    (should (eq 1 (wal/install-packages '(three four))))))

(ert-deftest test-wal/install-recipes ()
  (with-mock-all ((quelpa . (lambda (package) package))
                  (package-installed-p . (lambda (package) (memq package '(three)))))
    (should (eq 2 (wal/install-recipes '((one rest) (two rest)))))
    (should (eq 1 (wal/install-recipes '((three rest) (four reset)))))))

(ert-deftest test-wal/define-expansion-pack ()
  (match-expansion
    (wal/define-expansion-pack test
      "Tasteful expansion pack."
      :packages '(pull out of the package)
      :extras '(prep some ketchup)
      :recipes '(heat in oven))
    `(add-to-list
      'wal/expansion-packs
      '(test . (:packages '(pull out of the package)
                :extras '(prep some ketchup)
                :docs "Tasteful expansion pack."
                :recipes '(heat in oven))))))

(defvar wal/test-packs '((one :packages
                              (one)
                              :extras nil :docs "That's one." :recipes nil)
                         (two :packages
                              (two)
                              :extras (twofer) :docs "That's two." :recipes nil)
                         (three :packages nil :extras nil :docs "That's three." :recipes
                                ((three-mode :fetcher url :url "https://get-three-mode")))))

(ert-deftest test-wal/expansion-packs ()
  (let ((wal/expansion-packs wal/test-packs))
    (should (equal (wal/expansion-packs) '(one two twofer three-mode)))))

(ert-deftest test-wal/is-expansion-pack ()
  (let ((wal/expansion-packs wal/test-packs))
    (should (wal/is-expansion-pack 'three-mode))))


(ert-deftest test-wal/install-expansion-pack-extra ()
  (let ((messages '())
        (wal/expansion-packs wal/test-packs))
    (with-mock-all ((package-installed-p . (lambda (p) nil))
                    (package-install . (lambda (p) t))
                    (completing-read . (lambda (_m _l) 'all)))

      (ert-with-message-capture messages
        (wal/install-expansion-pack-extra (nth 2 wal/expansion-packs))
        (should (string-match "Installed all extras" messages))))

    (with-mock-all ((package-installed-p . (lambda (p) nil))
                    (package-install . (lambda (p) t))
                    (message . (lambda (m &rest args) (add-to-list 'messages (format m (car args)))))
                    (completing-read . (lambda (_m _l) 'twofer)))
      (wal/install-expansion-pack-extra (nth 2 wal/expansion-packs))
      (should (string-equal (car messages) "Installed extra 'twofer'.")))))

(ert-deftest test-wal/install-expansion-pack ()
  (let ((messages '()))
    (with-mock-all ((completing-read . (lambda (_m _v) "one"))
                    (package-installed-p . (lambda (package) nil))
                    (package-install . (lambda (package) t))
                    (message . (lambda (m &rest args) (add-to-list 'messages (format m (car args))))))
      (let ((wal/expansion-packs wal/test-packs))
        (call-interactively 'wal/install-expansion-pack)
        (should (string-equal (car messages) "Installed expansion pack 'one'"))))))

(ert-deftest test-wal/install-expansion-pack--installed-already ()
  (let ((messages '()))
    (with-mock-all ((completing-read . (lambda (_m _v) "one"))
                    (package-installed-p . (lambda (package) t))
                    (message . (lambda (m &rest args) (add-to-list 'messages (format m (car args))))))
      (let ((wal/expansion-packs wal/test-packs))
        (call-interactively 'wal/install-expansion-pack)
        (should (string-equal (car messages) "All core packages/recipes already installed."))))))

(ert-deftest test-wal/install-expansion-pack--with-extras ()
  (let ((messages '()))
    (with-mock-all ((completing-read . (lambda (_m _v) "two"))
                    (package-installed-p . (lambda (package) nil))
                    (package-install . (lambda (package) t))
                    (message . (lambda (m &rest args) (add-to-list 'messages (format m (car args)))))
                    (yes-or-no-p . (lambda (_) nil)))
      (let ((wal/expansion-packs wal/test-packs))
        (call-interactively 'wal/install-expansion-pack)
        (should (string-equal (car messages) "Installed expansion pack 'two'"))))
    (with-mock-all ((completing-read . (lambda (_m _v) "two"))
                    (package-installed-p . (lambda (package) nil))
                    (package-install . (lambda (package) t))
                    (yes-or-no-p . (lambda (_) t))
                    (wal/install-expansion-pack-extra . (lambda (_) 'extra)))
      (let ((wal/expansion-packs wal/test-packs))
        (should (equal (call-interactively 'wal/install-expansion-pack) 'extra))))))

(ert-deftest test-wal/install-expansion-pack--errors-for-non-existing ()
  (let ((wal/expansion-packs wal/test-packs))
    (should-error (wal/install-expansion-pack 'four))))

(ert-deftest test-wal/expansion--stringify ()
  (should (string-equal (wal/expansion--stringify '(one two three)) "one, two, three"))
  (should (string-empty-p (wal/expansion--stringify '()))))
#+END_SRC

*** Hooks

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/hook ()
  (match-expansion
   (wal/hook test
     "We're just testing."
     :messages '("Just testing")
     :lsp t
     :lsp-ignores '(".ignoramus")
     :tabs t)
   `(progn
      (defun wal/test-hook ()
        "We're just testing."
        (wal/message-in-a-bottle '("Just testing"))
        (hack-local-variables)
        (wal/maybe-enable-tabs)
        (wal/lsp))
      (with-eval-after-load 'lsp-mode
        (wal/append 'lsp-file-watch-ignored-directories
                    '(".ignoramus")))
      (add-hook 'test-hook 'wal/test-hook))))

(ert-deftest test-wal/hook--custom-indent ()
  (match-expansion
   (wal/hook test
     "We're just testing."
     :messages '("Just testing")
     :lsp t
     :tabs 'some-fun)
   `(progn
      (defun wal/test-hook ()
        "We're just testing."
        (wal/message-in-a-bottle '("Just testing"))
        (hack-local-variables)
        (wal/maybe-enable-tabs :indent-with 'some-fun)
        (wal/lsp))
      (add-hook 'test-hook 'wal/test-hook))))

(ert-deftest test-wal/hook--with-tabs ()
  (match-expansion
   (wal/hook test
     "We're just testing."
     :messages '("Just testing")
     :lsp nil)
   `(progn
      (defun wal/test-hook ()
        "We're just testing."
        (wal/message-in-a-bottle '("Just testing"))
        (hack-local-variables)
        (wal/disable-tabs))
      (add-hook 'test-hook 'wal/test-hook))))

(ert-deftest test-wal/hook--prog-like ()
  (match-expansion
   (wal/hook test
     "We're just testing."
     :messages '("Just testing")
     :prog-like t
     (message "hi"))
   `(progn
      (defun wal/test-hook ()
        "We're just testing."
        (wal/message-in-a-bottle '("Just testing"))
        (hack-local-variables)
        (wal/disable-tabs)
        (message "hi")
        (run-hooks 'prog-like-hook))
      (add-hook 'test-hook 'wal/test-hook))))

(ert-deftest test-wal/hook--lieutenant ()
  (match-expansion
   (wal/hook test
     "We're just testing."
     :messages '("Just testing")
     :lieutenant t
     (message "hi"))
   `(progn
      (defun wal/test-hook ()
        "We're just testing."
        (wal/message-in-a-bottle '("Just testing"))
        (hack-local-variables)
        (wal/disable-tabs)
        (message "hi")
        (local-set-key (kbd (wal/prefix-user-key wal/lieutenant-key)) 'wal/test-dispatch))
      (add-hook 'test-hook 'wal/test-hook))))
#+END_SRC

*** Additional Mode Controls

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/fundamental-mode--switches ()
  (with-temp-buffer
    (emacs-lisp-mode)
    (wal/fundamental-mode)
    (should (equal major-mode 'fundamental-mode))
    (should (equal wal/before-fundamental-mode 'emacs-lisp-mode))
    (wal/fundamental-mode)
    (should (equal major-mode 'emacs-lisp-mode))))
#+END_SRC

*** Shell Commands

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/async-process--buffer-name ()
  (should (string= (wal/async-process--buffer-name major-mode) "*wal-async*")))

(ert-deftest test-wal/async-process--finalize ()
  (let ((finalizer (wal/async-process--finalize (lambda () (should t))
                                                (lambda (m) (should (string= m "I am Error"))))))
    (funcall finalizer nil "finished\n")
    (funcall finalizer nil "I am Error"))

  (let ((finalizer (wal/async-process--finalize (lambda () (user-error "You are Error"))
                                                (lambda (m) (should (string= "You are Error" m))))))
    (funcall finalizer nil "finished\n")))

(ert-deftest test-wal/aysnc-process--maybe-interrupt ()
  (with-mock-all ((compilation-find-buffer . (lambda () (message "found-buffer") "buffer"))
                  (get-buffer-process . (lambda (m) (message m)))
                  (interrupt-process . (lambda (_) (message "interrupted"))))
    (ert-with-message-capture messages
      (wal/async-process--maybe-interrupt)
      (should (string= "found-buffer\nbuffer\ninterrupted\n" messages)))))

(ert-deftest test-wal/async-process ()
  (with-mock-all ((wal/async-process--maybe-interrupt . (lambda () (message "interrupted")))
                  (compilation-start . (lambda (c _ _n) (message "compiles") (get-buffer-create "async"))))
    (ert-with-message-capture messages
      (wal/async-process
       "compiles"
       (lambda () (message "finishes"))
       (lambda (_m) nil)
       t)
      (with-current-buffer "async"
        (funcall (car compilation-finish-functions) nil "finished\n"))
      (should (string= "interrupted\ncompiles\nfinishes\n" messages)))))

(ert-deftest test-wal/kill-async-process-buffers ()
  (get-buffer-create (generate-new-buffer-name "*wal-async*"))
  (get-buffer-create (generate-new-buffer-name "*wal-async*"))
  (let ((buf-count (length (buffer-list))))
    (call-interactively #'wal/kill-async-process-buffers)
    (should (> buf-count (length (buffer-list))))))
#+END_SRC

*** Strings

#+BEGIN_SRC emacs-lisp
(ert-deftest test-wal/matches-in-string ()
  (let ((str "This 1 string has 3 matches, or is it 2?")
        (pattern "\\(?1:[[:digit:]]\\)"))
    (should (equal '("2" "3" "1") (wal/matches-in-string pattern str)))))
#+END_SRC

*** Advice

#+begin_src emacs-lisp
(ert-deftest test-wal/advise-many ()
  (defun wal/test-fun-1 (arg1 arg2)
    "Do something with ARG1 and ARG2."
    (list arg1 arg2))

  (defun wal/test-fun-2 (arg1 arg2)
    "Do something with ARG1 and ARG2."
    (list arg1 arg2))

  (defun wal/test-advice (fun &rest args)
    "Just call as is."
    (apply fun args))

  (wal/advise-many #'wal/test-advice :around '(wal/test-fun-1 wal/test-fun-2))

  (should (and (advice--p (advice--symbol-function 'wal/test-fun-1))
               (advice--p (advice--symbol-function 'wal/test-fun-2)))))
#+end_src

*** Footer

#+BEGIN_SRC emacs-lisp
;;; wal-test.el ends here
#+END_SRC

* Look
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-look.el" wal/emacs-config-package-path)
:END:

Make frame transparent and set themes. [[https://peach-melpa.org/][PeachMelpa]] has more themes.

#+BEGIN_SRC emacs-lisp
;;; wal-look.el --- Look.

;;; Commentary:
;;
;; Provide packages for the look of the config.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wal/modern-emacs-p "wal-func.el")

(defgroup wal-look nil
  "Change the look."
  :group 'wal
  :tag "Look")

;;;; Customization:

(defcustom wal/transparency 90
  "The default frame transparency."
  :type 'integer
  :group 'wal-look)

(defcustom wal/theme nil
  "The theme."
  :type '(choice symbol (const nil))
  :group 'wal-look)

(defcustom wal/hidpi nil
  "Whether the display is considered HiDPI."
  :type 'boolean
  :group 'wal-look)

(defun wal/set-transparency (&optional value)
  "Set the transparency of the frame to VALUE.

1 being (almost) completely transparent, 100 being opaque.

This also updates variable `wal/transparency' for the duration of
the session."
  (interactive "nSet transparency (1-100): ")
  (let ((transparency (min (max (or value wal/transparency) 1) 100)))

    (setq wal/transparency transparency)

    (if (wal/modern-emacs-p)
        (modify-all-frames-parameters `((alpha-background . ,transparency)))
      (modify-all-frames-parameters `((alpha . ,transparency))))))

(defvar wal/active-theme nil)

(defvar wal/theme-hook nil)

(defun wal/load-active-theme ()
  "Load the currently active theme."
  (interactive)
  (when wal/active-theme
    (when (custom-theme-p wal/active-theme)
      (enable-theme wal/active-theme))
    (load-theme wal/active-theme t)
    (run-hooks 'wal/theme-hook)
    t))

(wal/on-boot visuals
  ;; Some themes require configuration, so we only load after initialization.
  (wal/define-init-setup visuals
    "Set up visual frills like theme and transparency."
    :initial
    ((if (wal/modern-emacs-p)
         (add-to-list 'default-frame-alist `(alpha-background . ,wal/transparency))
       (add-to-list 'default-frame-alist `(alpha . ,wal/transparency)))
     (when wal/theme
       (setq wal/active-theme wal/theme)
       (wal/load-active-theme))
     (when wal/hidpi
       (set-fringe-mode 18)))
    :always
    ((wal/set-transparency)
     (wal/load-active-theme))
    :immediately t)

  ;; Mix of old and new.
  (setq frame-title-format '(multiple-frames "%b" ("%b@" system-name))))

(provide 'wal-look)

;;; wal-look.el ends here
#+END_SRC

** Tests
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "test/wal-look-test.el" wal/emacs-config-package-path)
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-look-test.el --- Tests for look functionality. -*- lexical-binding: t; -*-

;;; Commentary:
;;
;; Tests for the look functionality.

;;; Code:

(ert-deftest test-wal/set-transparency ()
  (let ((emacs-major-version 29))
    (funcall-interactively 'wal/set-transparency 90)
    (should (eq 90 wal/transparency))
    (should (eq 90 (cdr (assoc 'alpha-background default-frame-alist)))))

  (let ((emacs-major-version 29))
    (setq wal/transparency 50)
    (funcall-interactively 'wal/set-transparency)
    (should (eq 50 wal/transparency))
    (should (eq 50 (cdr (assoc 'alpha-background default-frame-alist)))))

  (let ((emacs-major-version 28))
    (funcall-interactively 'wal/set-transparency 90)
    (should (eq 90 wal/transparency))
    (should (eq 90 (cdr (assoc 'alpha default-frame-alist))))))

(ert-deftest test-wal/load-active-theme ()
  (let ((wal/active-theme nil))
    (should-not (wal/load-active-theme)))

  (with-mock-all ((custom-theme-p . (lambda (_) t))
                  (enable-theme . (lambda (theme) theme)))
    (let ((wal/active-theme 'wombat))
      (should (wal/load-active-theme)))))

;;; wal-look-test.el ends here
#+END_SRC

* Fonts
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-fonts.el" wal/emacs-config-package-path)
:END:

Set fonts (with preference). To get support for ligatures, install the
symbol font from [[https://github.com/tonsky/FiraCode/files/412440/FiraCode-Regular-Symbol.zip][here]].

#+BEGIN_SRC emacs-lisp
;;; wal-fonts.el --- Fonts.

;;; Commentary:
;;
;; Provide font setup and configuration.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wal/general "wal-key-bindings.el")

(defgroup wal-fonts nil
  "Change fonts and font sizes."
  :group 'wal
  :tag "Fonts")

;;;; Customization:

(defcustom wal/fixed-fonts
  '("JetBrains Mono"
    "Iosevka"
    "Fira Code"
    "Hasklig"
    "Input Mono"
    "mononoki"
    "Source Code Pro"
    "DejaVu Sans Mono"
    "Monoid" ; The calt version doesn't work properly.
    "Liberation Mono")
  "Fixed fonts ordered by preference."
  :type '(repeat string)
  :group 'wal-fonts)

(defcustom wal/variable-fonts
  '("Roboto"
    "Ubuntu"
    "Liberation Serif"
    "DeJa Vu Sans"
    "Lato"
    "Quicksand"
    "San Francisco"
    "Arial")
  "Variable fonts ordered by preference."
  :type '(repeat string)
  :group 'wal-fonts)

(defcustom wal/preferred-fonts nil
  "List of (fixed and variable width) font names that should be preferred."
  :type '(choice (repeat string) (const nil))
  :group 'wal-fonts)

(defcustom wal/fixed-font-height 120
  "The font height for fixed fonts.
The default value is 98."
  :type 'integer
  :group 'wal-fonts)

(defcustom wal/variable-font-height 140
  "The font height for variable fonts.
This has no default value."
  :type 'integer
  :group 'wal-fonts)

(defvar wal/fonts-updated-hook nil
  "Functions to run when fonts were updated.")

(defun wal/font-update (attribute value faces)
  "Set ATTRIBUTE to VALUE for FACES.

This returns the made updates."
  (let ((updates (mapc (lambda (it)
                         (when (internal-lisp-face-p it)
                           (set-face-attribute it nil attribute value)))
                       faces)))
    (run-hooks 'wal/fonts-updated-hook)
    updates))

(defun wal/select-fixed-font (font)
  "Select fixed (available) FONT."
  (interactive
   (list (completing-read "Select font: " (wal/available-fonts wal/fixed-fonts))))
  (wal/font-update :font font '(default fixed-pitch)))

(defun wal/set-fixed-font-height (&optional height)
  "Set the HEIGHT for fixed fonts."
  (interactive "nSet fixed font height: ")
  (let ((sensible-height (max (min height 300) 80)))

    (setq wal/fixed-font-height sensible-height)

    (wal/font-update :height sensible-height '(default fixed-pitch))))

(defun wal/select-variable-font (font)
  "Select variable (available) FONT."
  (interactive
   (list (completing-read "Select font: " (wal/available-fonts wal/variable-fonts))))
  (wal/font-update :font font '(variable-pitch)))

(defun wal/set-variable-font-height (&optional height)
  "Set the HEIGHT for variable fonts."
  (interactive "nSet variable font height: ")
  (let ((sensible-height (max (min height 300) 80)))

    (setq wal/variable-font-height sensible-height)

    (wal/font-update :height sensible-height '(variable-pitch))))

(defun wal/available-fonts (fonts)
  "Filter FONTS down to available fonts."
  (seq-filter (lambda (it) (find-font (font-spec :name it))) fonts))

(defun wal/preferred-fonts (fonts)
  "Filter FONTS down to preferred fonts."
  (seq-filter (lambda (it) (member it wal/preferred-fonts)) fonts))

(defun wal/fonts-candidate (fonts &optional prefer)
  "Return the first available font from a list of FONTS.
If PREFER is true, variable `wal/preferred-fonts' is not nil and
preferred fonts are available, return the first of those
instead."
  (let* ((available-fonts (wal/available-fonts fonts))
         (preferred (and prefer (wal/preferred-fonts available-fonts))))

    (if preferred
        (car preferred)
      (car available-fonts))))

;; Slanted and enchanted.
(defun wal/font-lock ()
  "Set comment face to italic and keyword face to bold."
  (set-face-attribute 'font-lock-comment-face nil :slant 'italic :weight 'normal)
  (set-face-attribute 'font-lock-keyword-face nil :weight 'bold))

(wal/on-boot fonts
 (wal/define-init-setup fonts
   "Set up fonts for GUI Emacs.

This sets `default' and `fixed-pitch' fonts to the first
available candidate from `wal/fixed-fonts'. Does the same for
`variable-pitch' using `wal/variable-fonts'."
   :initial
   ((when (or (daemonp) (display-graphic-p))
      (mapc (lambda (it)
              (when (internal-lisp-face-p it)
                (set-face-attribute it nil
                                    :font (wal/fonts-candidate wal/fixed-fonts t)
                                    :height wal/fixed-font-height)))
            '(default fixed-pitch))
      (mapc (lambda (it)
              (when (internal-lisp-face-p it)
                (set-face-attribute it nil :inherit 'mode-line)))
            '(mode-line-active mode-line-inactive))

      ;; Variable pitch face.
      (set-face-attribute 'variable-pitch nil
                          :font (wal/fonts-candidate wal/variable-fonts t)
                          :height wal/variable-font-height)))
   :always
   ((run-hooks 'wal/fonts-updated-hook)))

 (wal/general
   "sf" '(wal/set-fixed-font-height :wk "fixed height")
   "sv" '(wal/set-variable-font-height :wk "variable height")
   "sF" '(wal/select-fixed-font :wk "fixed family")
   "sV" '(wal/select-variable-font :wk "variable family"))

 (add-hook 'font-lock-mode-hook #'wal/font-lock))

(provide 'wal-fonts)

;;; wal-fonts.el ends here
#+END_SRC

** Tests
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "test/wal-fonts-test.el" wal/emacs-config-package-path)
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-fonts-test.el --- Tests for fonts functionality. -*- lexical-binding: t; -*-

;;; Commentary:
;;
;; These tests require a lot of mocking as there won't be an
;; initialized window system.

;;; Code:

(ert-deftest test-wal/font-update ()
  (should (equal '(default) (wal/font-update :height 120 '(default)))))

(ert-deftest test-wal/select-fixed-font ()
  (with-mock completing-read (lambda (_m _) "JetBrains Mono")
    (let ((updates (call-interactively 'wal/select-fixed-font)))
      (should (equal updates '(default fixed-pitch))))))

(ert-deftest test-wal/set-fixed-font-height ()
  (let ((updates (funcall-interactively 'wal/set-fixed-font-height 110)))
    (should (equal updates '(default fixed-pitch)))
    (should (eq 110 (face-attribute 'default :height)))
    (should (eq wal/fixed-font-height 110))))

(ert-deftest test-wal/select-variable-font ()
  (with-mock completing-read (lambda (_m _) "Roboto")
    (let ((updates (call-interactively 'wal/select-variable-font)))
    (should (equal updates '(variable-pitch))))))

(ert-deftest test-wal/set-variable-font-height ()
  (let ((updates (funcall-interactively 'wal/set-variable-font-height 98)))
    (should (equal updates '(variable-pitch)))
    (should (eq 98 (face-attribute 'variable-pitch :height)))
    (should (eq wal/variable-font-height 98))))

(ert-deftest test-wal/preferred-fonts ()
  (let ((wal/preferred-fonts '("None" "This One")))
    (should (equal '("This One") (wal/preferred-fonts '("Not" "This One" "Here"))))))

(ert-deftest test-wal/fonts-candidate ()
  (with-mock-all ((wal/available-fonts . (lambda (_) '("Two" "One")))
                  (wal/preferred-fonts . (lambda (_) '("One" "Two"))))
    (should (string-equal "Two" (wal/fonts-candidate '())))
    (should (string-equal "One" (wal/fonts-candidate '() t)))))

(ert-deftest test-wal/font-lock ()
  (with-temp-buffer
    (wal/font-lock)
    (should (equal 'italic (face-attribute 'font-lock-comment-face :slant)))
    (should (equal 'bold (face-attribute 'font-lock-keyword-face :weight)))))

;; wal-fonts-test.el ends here
#+END_SRC

* External Packages
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-external.el" wal/emacs-config-package-path)
:END:

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-external.el --- External packages -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Set up installing external packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wal/install-packages "wal-func.el")
(declare-function wal/is-expansion-pack "wal-func.el")
(declare-function wal/prefix-user-key "wal-func.el")

(defvar wal/flag-mini)
(defvar wal/minimal)
(defvar wal/minimal-exclude)
#+END_SRC

** Packages

*** use-package
:PROPERTIES:
:UNNUMBERED: t
:END:

Before =use-package= macro can be used to configure other packages it
needs to be installed. We also install optional dependencies to
diminish and delight minor modes.

#+BEGIN_SRC emacs-lisp
(defconst wal/core-packages '(diminish
                              delight
                              use-package)
  "Packages to install before using `use-package'.
Such as package `use-package'.")

(require 'package)

(wal/on-boot external
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)

  ;; Try to install. On fail refresh and install again.
  (condition-case nil
      (wal/install-packages wal/core-packages :delete-windows t)
    (error
     (package-refresh-contents)
     (wal/install-packages wal/core-packages :delete-windows t))))

(eval-when-compile
    (require 'use-package))
#+END_SRC

*** Extensions

**** use-package/:wal-bind

We'll add keyword =:wal-bind= to =use-package= in order to create bindings
prefixed by =wal/prefix-user-key=.

#+BEGIN_SRC emacs-lisp
(defun wal/use-package-normalize-binder (name keyword args)
  "Normalize NAME, KEYWORD, ARGS.

This normalizer is a copy of the normalizer for `:bind'. There
are two differences:

1. It prefixes the key strings with `wal/prefix-user-key'.
2. On recursion it calls this normalizer."
  (let ((arg args)
        args*)
    (while arg
      (let ((x (car arg)))
        (cond
         ((and (consp x)
               (or (stringp (car x))
                   (vectorp (car x)))
               (fboundp 'use-package-recognize-function)
               (or (use-package-recognize-function (cdr x) t #'stringp)))
          ;; This is where we deviate from the `:bind' normalizer.
          (setq args* (nconc args* (list (cons (wal/prefix-user-key (car x)) (cdr x)))))
          (setq arg (cdr arg)))
         ((or (and (eq x :map) (symbolp (cadr arg)))
              (and (eq x :prefix) (stringp (cadr arg)))
              (and (eq x :prefix-map) (symbolp (cadr arg)))
              (and (eq x :prefix-docstring) (stringp (cadr arg)))
              (eq x :filter)
              (and (eq x :menu-name) (stringp (cadr arg)))
              (and (eq x :package) (symbolp (cadr arg))))
          (setq args* (nconc args* (list x (cadr arg))))
          (setq arg (cddr arg)))
         ((listp x)
          (setq args*
                (nconc args* (use-package-normalize/:wal-bind name keyword x)))
          (setq arg (cdr arg)))
         (t
          (use-package-error
           (concat (symbol-name name)
                   " wants arguments acceptable to the `bind-keys' macro,"
                   " or a list of such values"))))))
    args*))

(defalias 'use-package-normalize/:wal-bind 'wal/use-package-normalize-binder)
(defalias 'use-package-normalize/:wal-bind-keymap 'wal/use-package-normalize-binder)

;; We can use the same handler as `:bind' and `:bind-keymap'.
(defalias 'use-package-handler/:wal-bind 'use-package-handler/:bind)
(defalias 'use-package-handler/:wal-bind-keymap 'use-package-handler/:bind-keymap)

;; Make sure that functions are autoloaded.
(defalias 'use-package-autoloads/:wal-bind 'use-package-autoloads-mode)
#+END_SRC

**** use-package/:wal-ways

Certain packages do not belong to a minimal setup, these are tagged
with =:wal-ways nil=.

#+BEGIN_SRC emacs-lisp
(defalias 'use-package-normalize/:wal-ways 'use-package-normalize-predicate)

(defun use-package-handler/:wal-ways (name _keyword pred rest state)
  "Only expand conditionally.

The conditions for normal packages are: (1) the PRED is t, (2)
`wal/minimal' is nil or (3) NAME is never excluded.

If NAME is an expansion pack package, the conditions are: (1) the
PRED is t or (2) NAME is installed.

The STATE is updated as well before parsing REST if we want to
use the result further down the line."
  (when (and (fboundp 'use-package-process-keywords)
             (fboundp 'use-package-plist-maybe-put))
    (let* ((active (or pred
                       (if (wal/is-expansion-pack name)
                           (not (null (package-installed-p name)))
                         (or (not (or wal/minimal wal/flag-mini))
                             (not (null (memq name wal/minimal-exclude)))))))

           (body (use-package-process-keywords
                   name
                   rest
                   (use-package-plist-maybe-put state :wal-ways active))))

      `((when ,active
          ,@body)))))
#+END_SRC

** quelpa
:PROPERTIES:
:UNNUMBERED: t
:END:

Allows installing from other sources (like GitHub) using recipes.

#+BEGIN_SRC emacs-lisp
(use-package quelpa
  :demand t

  :custom
  (quelpa-update-melpa-p nil))

(use-package quelpa-use-package
  :demand
  :after quelpa

  :config
  (when (fboundp 'quelpa-use-package-activate-advice)
    (quelpa-use-package-activate-advice)))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-external)

;;; wal-external.el ends here
#+END_SRC

* Emacs
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-emacs.el" wal/emacs-config-package-path)
:END:

Everything that has to do with Emacs-y stuff.

This is a combination of configurations for built-in packages some
external ones.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-emacs.el --- Emacs. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide Emacs settings/configurations.

;;; Code:

(eval-when-compile
  (require 'transient)
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wal/dead-shell-p "wal-func.el")
(declare-function wal/modern-emacs-p "wal-func.el")
(declare-function wdb/pop-up "wal-func.el")
(declare-function wdb/side "wal-func.el")
(declare-function wdb/direction "wal-func.el")

(wal/on-boot emacs
  (wdb/direction 'help-mode)
  (wdb/direction 'shortdoc-mode)
  (wdb/side 'debug-mode))
#+END_SRC

** Improved Editing

Sometimes I need to see whitespace chars.

*** text-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

No double spaces in sentences.

#+BEGIN_SRC emacs-lisp
(use-package text-mode
  :ensure nil

  :init
  (wal/hook text-mode
    "Hook into `text-mode'."
    ;; Activate `flyspell-mode' when editing commit messages.
    (when (string-match "COMMIT_EDITMSG" (buffer-name))
      (flyspell-mode)))

  :custom
  (sentence-end-double-space nil))
#+END_SRC

*** abbrev
:PROPERTIES:
:UNNUMBERED: t
:END:

Automatic quick expansion.

#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :ensure nil

  :hook
  ((elixir-mode) . abbrev-mode)

  :config
  (define-abbrev-table 'elixir-mode-abbrev-table '(("p" "|>")))

  :custom
  (save-abbrevs t)

  :delight " abb")
#+END_SRC

*** follow-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Follow me around.

#+begin_src emacs-lisp
(use-package follow-mode
  :ensure nil

  :custom
  (follow-mode-line-text " flw"))
#+end_src

*** diff-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Effing diffing.

#+BEGIN_SRC emacs-lisp
(use-package diff-mode
  :ensure nil

  :config
  ;; Removes `diff-goto-source'.
  (define-key diff-mode-shared-map (kbd "o") nil))
#+END_SRC

*** tabulated-list
:PROPERTIES:
:UNNUMBERED: t
:END:

According to my tabulations, your columns are too small.

#+BEGIN_SRC emacs-lisp
(use-package tabulated-list
  :ensure nil

  :bind
  (:map tabulated-list-mode-map
   ("M-b" . tabulated-list-previous-column)
   ("M-f" . tabulated-list-next-column)
   ("M-w" . tabulated-list-widen-current-column)
   ("M-n" . tabulated-list-narrow-current-column)))
#+END_SRC

*** hideshow
:PROPERTIES:
:UNNUMBERED: t
:END:

Hide blocks.

#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :ensure nil

  :general
  (wal/captain :keymaps 'hs-minor-mode-map
    "h" '(hs-toggle-hiding :wk "toggle hiding")))
#+END_SRC

*** kmacro
:PROPERTIES:
:UNNUMBERED: t
:END:

Some people need macros, okay?

#+BEGIN_SRC emacs-lisp
(use-package kmacro
  :ensure nil

  :config
  (with-eval-after-load 'which-key
    (which-key-add-key-based-replacements "C-c k" "kmacro"))

  :bind-keymap
  (("C-c k" . kmacro-keymap)))
#+END_SRC

*** register
:PROPERTIES:
:UNNUMBERED: t
:END:

No offender.

#+BEGIN_SRC emacs-lisp
(use-package register
  :ensure nil

  :config
  (with-eval-after-load 'which-key
    (which-key-add-key-based-replacements "C-c r" "register"))

  :bind-keymap
  (("C-c r" . ctl-x-r-map)))
#+END_SRC

*** pulse
:PROPERTIES:
:UNNUMBERED: t
:END:

Highlight lines.

#+BEGIN_SRC emacs-lisp
(defun wal/lighthouse ()
  "Do a heavy `pulse-momentary-highlight-one-line'.

This just means increasing duration, delay, size and brightness."
  (interactive)
  (defvar pulse-iterations)
  (let ((pulse-iterations 30))

    (pulse-momentary-highlight-one-line (point) 'cursor)))

(use-package pulse
  :ensure nil

  :bind
  ("C-c b" . wal/lighthouse))
#+END_SRC

** Dealing With Emacs

Allow restoring window configurations when Emacs decided they should
be gone.

*** winner
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure nil

  :defer 2

  :config
  ;; Allow for quicker un- and redoing.
  (defhydra wal/winner (:hint nil)
    "
%s`wal/ascii-whale Window layout: _u_ndo or _r_edo.
"
    ("u" winner-undo)
    ("r" winner-redo)
    ("q" nil "quit"))

  (winner-mode 1)

  :custom
  (winner-dont-bind-my-keys t)

  :general
  (wal/major "w" '(wal/winner/body :wk "winner")))
#+END_SRC

*** async
:PROPERTIES:
:UNNUMBERED: t
:END:

Execute IO actions asynchronously.

#+BEGIN_SRC emacs-lisp
(use-package async
  :defer 2
  :after dired

  :config
  (dired-async-mode 1)

  :diminish 'dired-async-mode)
#+END_SRC

*** shell
:PROPERTIES:
:UNNUMBERED: t
:END:

I'd like to kill shells without a process quickly.

#+BEGIN_SRC emacs-lisp
(use-package shell
  :ensure nil

  :general
  (general-define-key
   :keymaps '(shell-mode-map comint-mode-map)
   :predicate '(wal/dead-shell-p)
   "k" 'kill-buffer-and-window))
#+END_SRC

*** compile
:PROPERTIES:
:UNNUMBERED: t
:END:

Show compilations in a pop-up and scroll output.

#+BEGIN_SRC emacs-lisp
(use-package compile
  :ensure nil

  :config
  (wdb/pop-up "\\*compilation")

  :custom
  (compilation-scroll-output t))
#+END_SRC

** Help

*** helpful
:PROPERTIES:
:UNNUMBERED: t
:END:

Let's try to be even more =helpful=.

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :demand
  :after elisp-mode

  :config
  (wdb/direction 'helpful-mode)
  (when (wal/modern-emacs-p)
    (defvar read-symbol-positions-list nil))

  :bind
  (([remap describe-command] . helpful-command)
   ([remap describe-function] . helpful-function)
   ([remap describe-key] . helpful-key)
   ([remap describe-variable] . helpful-variable)
   ([remap describe-symbol] . helpful-symbol)
   :map help-map
   ("M" . helpful-macro)
   ("C-x" . helpful-kill-buffers)
   :map helpful-mode-map
   ("k" . kill-buffer-and-window)))
#+END_SRC

** Look-Up

*** bookmark
:PROPERTIES:
:UNNUMBERED: t
:END:

Leave a bookmark why don't you.

#+BEGIN_SRC emacs-lisp
(use-package bookmark
  :ensure nil

  :config
  (wdb/side "\\*Bookmark Annotation\\*" :side 'left)

  (with-eval-after-load 'bookmark
    (which-key-add-key-based-replacements "C-c m" "bookmark"))

  :custom
  (bookmark-use-annotations t)
  (bookmark-menu-confirm-deletion t)

  :bind-keymap
  (("C-c m" . bookmark-map))

  :bind
  (:map bookmark-map
   ("l" . bookmark-bmenu-list)
   ("L" . bookmark-load)))
#+END_SRC

*** calc
:PROPERTIES:
:UNNUMBERED: t
:END:

Quick calculations.

#+BEGIN_SRC emacs-lisp
(use-package calc
  :ensure nil

  :bind
  ("C-c q" . quick-calc))
#+END_SRC

*** dictionary
:PROPERTIES:
:UNNUMBERED: t
:END:

Look up words in a word book.

#+BEGIN_SRC emacs-lisp
(use-package dictionary
  :ensure nil

  :config
  (wdb/direction "^\\*Dictionary")

  :custom
  (dictionary-server "dict.org")

  :general
  (wal/captain "D" 'dictionary-lookup-definition))
#+END_SRC

** Additional Info Display

*** eldoc
:PROPERTIES:
:UNNUMBERED: t
:END:

Contextual information. Package =lsp-mode= use =eldoc= extensively.

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :ensure nil

  :custom
  (eldoc-idle-delay 2.0)
  (eldoc-echo-area-use-multiline-p nil)
  (eldoc-echo-area-prefer-doc-buffer t)
  (eldoc-echo-area-display-truncation-message nil)

  :delight " eld")
#+END_SRC

*** hl-line
:PROPERTIES:
:UNNUMBERED: t
:END:

Highlighting the current line.

#+BEGIN_SRC emacs-lisp
(use-package hl-line
  :ensure nil

  :hook
  ((tablist-minor-mode
    tabulated-list-mode
    dired-mode
    dashboard-mode) . hl-line-mode))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-emacs)

;;; wal-emacs.el ends here
#+END_SRC

* Editing
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-edit.el" wal/emacs-config-package-path)
:END:

It's fun to edit things /quickly/.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-edit.el --- Editing. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide editing packages.

;;; Code:

(declare-function yas-expand "ext:yasnippet.el")

(defvar wal/use-hyper-prefix)
#+END_SRC

** Packages

*** multiple-cursors
:PROPERTIES:
:UNNUMBERED: t
:END:

Don't you want to edit your buffer in multiple places at once?

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :init
  ;; Since the map is `nil', using `:bind' would fail.
  (setq mc/keymap (make-sparse-keymap))

  :custom
  (mc/always-run-for-all t)

  :bind
  (("C-." . mc/mark-next-like-this)
   :map mc/keymap
   ;; Keep the first two bindings from the default map.
   ("C-g" . mc/keyboard-quit)
   ("C-'" . mc-hide-unmatched-lines-mode)
   ("C-," . mc/unmark-next-like-this)
   ("C-/" . mc/skip-to-next-like-this))

  :wal-bind
  ("<mouse-3>" . mc/add-cursor-on-click)

  :general
  (wal/colonel! "." 'mc/mark-all-like-this  'mc/edit-ends-of-lines))
#+END_SRC

*** expand-region
:PROPERTIES:
:UNNUMBERED: t
:END:

One thing that can be a bit tricky is selecting regions, not anymore.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind
  (("C->" . er/expand-region)
   ("C-<" . er/contract-region)))
#+END_SRC

*** yasnippet
:PROPERTIES:
:UNNUMBERED: t
:END:

Don't reduce the boilerplate, reduce your involvement in it with
snippets.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :hook ((prog-mode org-mode prog-like) . yas-minor-mode)

  :config
  ;; Don't want to get in the way of `completion-at-point'.
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (yas-reload-all)

  :wal-bind
  (:map yas-minor-mode-map
   ("y" . yas-expand))

  :general
  (wal/captain :keymaps 'yas-minor-mode-map
    "y"  '(:ignore t :wk "yas")
    "yi" 'yas-insert-snippet
    "yv" 'yas-visit-snippet-file
    "yn" 'yas-new-snippet)

  :delight " yas")

(use-package yasnippet-snippets
  :demand
  :after yasnippet)
#+END_SRC

*** drag-stuff
:PROPERTIES:
:UNNUMBERED: t
:END:

Drag lines and regions around.

#+BEGIN_SRC emacs-lisp
(use-package drag-stuff
  :hook ((prog-mode prog-like) . drag-stuff-mode)

  :config
  (when wal/use-hyper-prefix
    (setq drag-stuff-modifier 'hyper))

  (when (fboundp 'drag-stuff-define-keys)
    (drag-stuff-define-keys))

  :delight " drg")
#+END_SRC

*** elec-pair
:PROPERTIES:
:UNNUMBERED: t
:END:

Less intrusive pairing mode than =smartparens=.

#+BEGIN_SRC emacs-lisp
(defun wal/in-case-of-mc-mode-do-not-default (&rest _args)
  "Advise to inhibit if `multiple-cursors-mode' is t."
  (bound-and-true-p multiple-cursors-mode))

(use-package elec-pair
  :ensure nil

  :hook ((prog-mode prog-like) . electric-pair-local-mode)

  :init
  (advice-add
   'electric-pair-default-inhibit :before-until
   #'wal/in-case-of-mc-mode-do-not-default))
#+END_SRC

*** crux
:PROPERTIES:
:UNNUMBERED: t
:END:

I guess I can't live without this package.

#+BEGIN_SRC emacs-lisp
(use-package crux
  :bind
  ("C-k" . crux-smart-kill-line)
  ("M-k" . crux-kill-line-backwards)
  ("C-o" . crux-smart-open-line)
  ("C-M-o" . crux-smart-open-line-above)

  :general
  (wal/colonel! "d"
    'crux-duplicate-current-line-or-region
    'crux-duplicate-and-comment-current-line-or-region))
#+END_SRC

*** vundo
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package vundo
  :wal-ways nil

  :custom
  (vundo-glyph-alist vundo-unicode-symbols)
  (vundo---window-max-height 5)

  :general
  (wal/captain "/" 'vundo))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-edit)

;;; wal-edit.el ends here
#+END_SRC

* Visuals
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-visuals.el" wal/emacs-config-package-path)
:END:

I like nice-looking things.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-visuals.el --- Visuals. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide visual packages.

;;; Code:

(declare-function dashboard-insert-startupify-lists "ext:dashboard.el")
(declare-function ligature-set-ligatures "ext:ligature.el")
(declare-function wal/append "wal-func.el")
(declare-function wal/biased-random "wal-func.el")
(declare-function wal/maybe-intern "wal-func.el")

(defvar dashboard-buffer-name)
(defvar dashboard-footer-messages)
(defvar dimmer-prevent-dimming-predicates)
(defvar wal/ascii-whale)
(defvar wal/emacs-config-default-path)
(defvar which-key-popup-type)

(defgroup wal-visuals nil
  "Change settings used for visual packages."
  :group 'wal
  :tag "Visuals")

;;;; Customization:

(defcustom wal/dashboard-footer-messages
  '("breaching your favorite stupid framework"
    "I propel myself forward on nothing but flukes"
    "devout and up the spout"
    "krill, filter feeders and hit sulphur bottom"
    "the founder of retiring gentlemen"
    "the loud keyboard shall vanquish the muscular mouse"
    "answering all C-calls in sweeping, overflowing song"
    "infinite whale loop"
    "from echo location to perimeter expansion"
    "a mystic of profounder divings"
    "superior, clear and fine code; but there's little of it"
    "formed by intertwisting, slanting folds"
    "a register for distant jets"
    "the most majestic in affect, the most valuable in commiseration"
    "unshared, sourceless immensities")
  "The dashboard footer messages.

A collection of status messages."
  :type '(repeat string)
  :group 'wal-visuals)

(defcustom wal/recentf-exclude '("bookmarks\\'" "zettelkasten")
  "Files the dashboard should not consider recent files."
  :type '(repeat regexp)
  :group 'wal-visuals)

(defcustom wal/startup-banner
  (let ((ext (if (or (daemonp) (display-graphic-p))
                 ".png"
               ".txt")))

    (expand-file-name
     (concat "assets/logo" ext)
     wal/emacs-config-default-path))
  "The start-up banner (transformed Emacs logo)."
  :type 'file
  :group 'wal-visuals)

(defcustom wal/footer-icon
  (if (or (daemonp) (display-graphic-p))
      ":whale:"
    wal/ascii-whale)
  "The path to the footer icon."
  :type 'string
  :group 'wal-visuals)

(defcustom wal/major-delight t
  "Whether some major modes are delighted beyond reason."
  :type 'boolean
  :group 'wal-visuals)

(defcustom wal/zone-when-idle nil
  "Determine whether to zone out when idling."
  :type 'boolean
  :group 'wal-visuals)

(defcustom wal/zone-timer (* 5 60)
  "The time in seconds when we will zone out."
  :type 'integer
  :group 'wal-visuals)
#+END_SRC

** Dashboard

*** dashboard
:PROPERTIES:
:UNNUMBERED: t
:END:

Let's have a dash of board.

#+BEGIN_SRC emacs-lisp
(defun wal/with-recent-files-excluded (fun &rest args)
  "Advise FUN to ignore certain directories, applying ARGS."
  (defvar recentf-exclude)

  (let ((recentf-exclude wal/recentf-exclude))

    (apply fun args)))

(defun wal/instead-show-biased-random (&rest _args)
  "Advise to use biased random footer message."
  (nth (wal/biased-random (length dashboard-footer-messages)) dashboard-footer-messages))

(defun wal/in-case-of-daemonp-add-different-hook ()
  "Setup the dashboard in a daemon-friendly way."
  (when (daemonp)
    (add-hook
     'server-after-make-frame-hook
     #'dashboard-insert-startupify-lists)))

(use-package dashboard
  :wal-ways nil

  :hook (after-init . dashboard-setup-startup-hook)

  :init
  (advice-add
   'dashboard-insert-startupify-lists :around
   #'wal/with-recent-files-excluded)
  (advice-add
   'dashboard-random-footer :override
   #'wal/instead-show-biased-random)
  (advice-add
   'dashboard-setup-startup-hook :before-until
   #'wal/in-case-of-daemonp-add-different-hook)

  :config
  (setq dashboard-banner-logo-title (wal/describe-config-version))

  :custom
  (dashboard-startup-banner wal/startup-banner)
  (dashboard-projects-backend (if wal/use-projectile
                                  'projectile
                                'project-el))
  (dashboard-items '((recents . 5)
                     (projects . 3)
                     (bookmarks . 3)))
  (dashboard-center-content t)
  (dashboard-set-file-icons t)
  (dashboard-set-navigator t)
  (dashboard-footer-icon wal/footer-icon)
  (dashboard-footer-messages wal/dashboard-footer-messages)
  (dashboard-week-agenda nil)
  (dashboard-agenda-time-string-format "%d/%m/%y")
  (dashboard-agenda-release-buffers t)

  :general
  (wal/major "d" '(dashboard-refresh-buffer :wk "dashboard")))
#+END_SRC

** Themes

*** doom-themes
:PROPERTIES:
:UNNUMBERED: t
:END:

The nicest theme packages out there. It supports many, many packages'
=face= variants.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :wal-ways nil

  :config
  (doom-themes-org-config))
#+END_SRC

*** kaolin-themes
:PROPERTIES:
:UNNUMBERED: t
:END:

Another collection of beautiful themes, but it doesn't color every
=face=.

#+BEGIN_SRC emacs-lisp
(use-package kaolin-themes
  :wal-ways nil

  :config
  (kaolin-treemacs-theme)

  :custom
  (kaolin-themes-italic-comments t)
  (kaolin-themes-git-gutter-solid t)
  (kaolin-themes-modeline-border nil)
  (kaolin-themes-distinct-fringe t))
#+END_SRC

*** modus-themes
:PROPERTIES:
:UNNUMBERED: t
:END:

Protesilaos' super configurable themes.

#+BEGIN_SRC emacs-lisp
(use-package modus-themes
  :ensure nil

  :custom
  (modus-themes-slanted-constructs t)
  (modus-themes-bold-constructs t)
  (modus-themes-mode-line '(borderless))
  (modus-themes-org-blocks 'tinted-background))
#+END_SRC

*** ef-themes
:PROPERTIES:
:UNNUMBERED: t
:END:

Color over configuration from the same author.

#+BEGIN_SRC emacs-lisp
(use-package ef-themes
  :wal-ways nil)
#+END_SRC

*** base16-themes
:PROPERTIES:
:UNNUMBERED: t
:END:

Check out the [[https://base16-project.github.io/base16-gallery/][gallery]].

#+BEGIN_SRC emacs-lisp
(use-package base16-theme
  :wal-ways nil

  :custom
  (base16-theme-distinct-fringe-background nil))
#+END_SRC

** Highlighting

*** diff-hl
:PROPERTIES:
:UNNUMBERED:
:END:

Show diffs in the fringe (also in =dired= buffers).

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :defer 1

  :hook
  ((magit-post-refresh . diff-hl-magit-post-refresh)
   (dired-mode . diff-hl-dired-mode))

  :config
  (global-diff-hl-mode))
#+END_SRC

*** highlight-numbers
:PROPERTIES:
:UNNUMBERED: t
:END:

Make numbers stand out.

#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers
  :wal-ways nil

  :hook ((prog-mode prog-like) . highlight-numbers-mode))
#+END_SRC

*** hl-todo
:PROPERTIES:
:UNNUMBERED: t
:END:

Highlight =TODO=, =FIXME= etc. in =prog= modes.

#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :wal-ways nil

  :hook ((prog-mode prog-like) . hl-todo-mode)

  :custom
  (hl-todo-highlight-punctuation ":")
  (hl-todo-require-punctuation t))
#+END_SRC

*** rainbow-delimiters
:PROPERTIES:
:UNNUMBERED: t
:END:

Make delimiters stand out.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :wal-ways nil

  :hook ((prog-mode prog-like) . rainbow-delimiters-mode))
#+END_SRC

*** rainbow-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Show colors colorfully.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :wal-ways nil

  :delight " rbm")
#+END_SRC

** Where Am I?

*** which-key
:PROPERTIES:
:UNNUMBERED: t
:END:

Show the next possible key presses towards a command.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :wal-ways nil

  :defer 2

  :config
  (which-key-mode 1)

  :custom
  (which-key-idle-delay wal/idle-delay)
  (which-key-lighter " wk?")
  (which-key-sort-uppercase-first nil)
  (which-key-preserve-window-configuration t)
  (which-key-show-docstrings t))
#+END_SRC

*** dimmer
:PROPERTIES:
:UNNUMBERED: t
:END:

Dim inactive frames.

#+BEGIN_SRC emacs-lisp
;; Solution from buzztaiki https://github.com/gonewest818/dimmer.el/issues/49
(defun wal/instead-force-only-if-predicates-falsy ()
  "Advise to only force process if no predicate is truthy."
  (let ((ignore (cl-some (lambda (f) (and (fboundp f) (funcall f)))
                         dimmer-prevent-dimming-predicates)))

    (unless ignore
      (when (fboundp 'dimmer-process-all)
        (dimmer-process-all t)))))

(defun wal/lsp-ui-doc-frame-p ()
  "Check if buffer is a lsp-ui-doc frame buffer."
  (string-match-p "\\` \\*lsp-ui-doc" (buffer-name)))

(defun wal/dimmer-configure-lsp-doc ()
  "Convenience settings for lsp-doc users."
  (add-to-list
   'dimmer-prevent-dimming-predicates
   #'wal/lsp-ui-doc-frame-p))

(defun wal/corfu-frame-p ()
  "Check if the buffer is a corfu frame buffer."
  (string-match-p "\\` \\*corfu" (buffer-name)))

(defun wal/dimmer-configure-corfu ()
  "Convenience settings for corfu users."
  (add-to-list
   'dimmer-prevent-dimming-predicates
   #'wal/corfu-frame-p))

(use-package dimmer
  :wal-ways nil

  :defer 3

  :config
  (advice-add
   'dimmer-config-change-handler :override
   #'wal/instead-force-only-if-predicates-falsy)

  ;; Integrate with other packages.
  (dimmer-configure-hydra)
  (dimmer-configure-magit)
  (dimmer-configure-org)
  (dimmer-configure-which-key)
  (wal/dimmer-configure-lsp-doc)
  (wal/dimmer-configure-corfu)

  (dimmer-mode t)

  :custom
  (dimmer-fraction 0.3)

  :delight " dmm")
#+END_SRC

*** goggles
:PROPERTIES:
:UNNUMBERED: t
:END:

Pulse on region edits.

#+BEGIN_SRC emacs-lisp
(use-package goggles
  :wal-ways nil

  :hook ((prog-mode text-mode) . goggles-mode)

  :custom
  (goggles-pulse-iterations 20)

  :delight " ggl")
#+END_SRC

** Modeline

Minor modes are white-listed, hidden, delighted and diminished.
Meaning that, if not white-listed, they are not shown, if they are
shown, they are delighted unless they were diminished.

*** wal-line
:PROPERTIES:
:UNNUMBERED: t
:END:

My own mode line.

#+BEGIN_SRC emacs-lisp
(use-package wal-line
  :wal-ways nil
  :quelpa (wal-line :fetcher github :repo "Walheimat/wal-line")

  :defer 1

  :config
  (wal-line-mode 1)

  :custom
  (wal-line-icons-prettify-buffer-status t))
#+END_SRC

*** delight
:PROPERTIES:
:UNNUMBERED: t
:END:

Refine a couple of major and minor mode names.

#+BEGIN_SRC emacs-lisp
(use-package delight
  :config
  (delight 'dired-mode "Dired" :major)
  (delight 'emacs-lisp-mode "Elisp" :major)
  (delight 'lisp-interaction-mode "Elisp?" :major)
  (delight 'wdired-mode "DirEd" :major)
  (delight 'c++-mode "CPP" :major)
  (delight 'compilation-shell-minor-mode " csh" "compile")
  (delight 'auto-fill-function " aff" t)
  (delight 'with-editor-mode " w/e" "with-editor")

  ;; Only confuse/delight if allowed.
  (when wal/major-delight
    (delight 'elixir-mode "Homebrew" :major)
    (delight 'c++-mode "*&" :major)
    (delight 'python-mode "Snake" :major)
    (delight 'js-mode "NaNsense" :major)
    (delight 'inferior-python-mode "Bite" :major)))

(use-package diminish)
#+END_SRC

*** minions
:PROPERTIES:
:UNNUMBERED: t
:END:

Sometimes the list of minor modes overcrowds the modeline.

#+BEGIN_SRC emacs-lisp
(use-package minions
  :wal-ways nil

  :defer 3

  :config
  (minions-mode 1)

  :custom
  (minions-prominent-modes '(smerge-mode
                             git-timemachine-mode
                             vterm-copy-mode
                             with-editor-mode
                             typo-mode
                             auto-fill-function
                             flyspell-mode
                             org-tree-slide-mode
                             wal/config-mode
                             verb-mode
                             verb-response-body-mode
                             lispy-mode
                             pet-mode)))
#+END_SRC

*** mode-line-bell
:PROPERTIES:
:UNNUMBERED: t
:END:

Make the bell visual.

#+BEGIN_SRC emacs-lisp
(use-package mode-line-bell
  :defer 3

  :config
  (mode-line-bell-mode)

  :custom
  (mode-line-bell-flash-time 0.1))
#+END_SRC

** Ligatures

Font *JetBrains Mono* has the best support for ligatures.

*** ligature
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(defconst wal/common-ligatures
  '(
    "==" "!=" ">=" "<="        ; Comparison.
    "+=" "-=" "/=" "%=" "*="   ; Assignment.
    "||" "&&"                  ; Logical.
    "/*" "*/" "//" "/**" "**/" ; Comments.
    "++" "--"                  ; Increment/decrement.
    ">>=" "<<=" "&=" "|=" "^=" ; Bitwise assignments.
    "<<" ">>"                  ; Bitwise shifts.
    "..."                      ; Spread.
    )
  "A list of ligatures available in all programming modes.")

(defun wal/with-common-ligatures (fun &rest args)
  "Advise FUN to append common ligatures.

ARGS is a list containing modes and additional ligatures."
  (let ((modes (nth 0 args))
        (ligatures (append (nth 1 args) wal/common-ligatures)))

    (apply fun `(,modes ,ligatures))))

(use-package ligature
  :wal-ways nil

  :hook ((prog-mode prog-like) . ligature-mode)

  :config
  ;; Common ligatures.
  (advice-add
   'ligature-set-ligatures :around
   #'wal/with-common-ligatures)

  (ligature-set-ligatures 'clojure-mode '(";;" "->" "->>"))
  (ligature-set-ligatures 'c++-mode '("::" "->"))
  (ligature-set-ligatures 'dart-mode '("=>" "///" ".?" "??"
                                       "??=" ".."))
  (ligature-set-ligatures 'elixir-mode '("|>" "->" "<-" "=>"
                                         "::" "<>" "#{" "\\\\"
                                         "===" "!==" ".."))
  (ligature-set-ligatures 'html-mode '("<!--" "-->" "</" "/>"))
  (ligature-set-ligatures 'nxml-mode '("<!--" "-->" "</" "/>"))
  (ligature-set-ligatures 'java-mode '("::" "->"))
  (ligature-set-ligatures 'js-mode '("=>" "!==" "===" "!!"))
  (ligature-set-ligatures 'lisp-data-mode '(";;"))
  (ligature-set-ligatures 'php-mode '("::" "=>" "->" "??"
                                      "__" "<>" "!==" "<=>"
                                      "==="))
  (ligature-set-ligatures 'prolog-mode '(":-"))
  (ligature-set-ligatures 'python-mode '("->" "__"))
  (ligature-set-ligatures 'rust-mode '("///" "->" "=>" "::"
                                       ".." "#[")))
#+END_SRC

** Icons

*** all-the-icons
:PROPERTIES:
:UNNUMBERED: t
:END:

You need to install the icons yourself[fn:13].

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :wal-ways nil

  :commands (all-the-icons-octicon))
#+END_SRC

*** emojify
:PROPERTIES:
:UNNUMBERED: t
:END:

Display emojis[fn:14].

#+BEGIN_SRC emacs-lisp
(use-package emojify
  :wal-ways nil

  :hook (dashboard-mode . emojify-mode))
#+END_SRC

** Screen-Saver

*** zone
:PROPERTIES:
:UNNUMBERED: t
:END:

Screen saver, CPU devourer.

#+BEGIN_SRC emacs-lisp
(use-package zone
  :ensure nil

  :config
  (setq zone-programs [
                       zone-pgm-drip
                       zone-pgm-jitter
                       zone-pgm-dissolve
                       zone-pgm-rat-race
                       zone-pgm-whack-chars
                       ])

  (when (and (fboundp 'zone-when-idle) wal/zone-when-idle)
    (zone-when-idle wal/zone-timer))

  :general
  (wal/captain "0" 'zone))
#+END_SRC

** Other

*** mixed-pitch
:PROPERTIES:
:UNNUMBERED: t
:END:

Allow using variable and fixed fonts in the same buffer.

#+BEGIN_SRC emacs-lisp
(use-package mixed-pitch
  :wal-ways nil

  :config
  (add-to-list 'mixed-pitch-fixed-pitch-faces 'markdown-pre)

  :custom
  (mixed-pitch-variable-pitch-cursor nil)

  :delight " mpm")
#+END_SRC

*** visual-fill-column
:PROPERTIES:
:UNNUMBERED: t
:END:

Allow padding and centering text.

#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :wal-ways nil)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-visuals)

;;; wal-visuals.el ends here
#+END_SRC

* Windows
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-windows.el" wal/emacs-config-package-path)
:END:

Everything that has to do with windows.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-windows.el --- Windows. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide window packages.

;;; Code:

(declare-function aw-delete-window "ext:ace-window.el")
(declare-function popper-popup-p "ext:popper.el")

(defvar aw-dispatch-alist)
(defvar popper-group-function)
#+END_SRC

** Packages

*** ace-window
:PROPERTIES:
:UNNUMBERED: t
:END:

Ace interacting with (multiple) windows.

#+BEGIN_SRC emacs-lisp
(defun wal/aw-delete-window-kill-buffer (window)
  "Call `aw-delete-window' on WINDOW requesting buffer kill."
  (aw-delete-window window t))

(defun wal/instead-call-consult-buffer (&rest _args)
  "Advise `aw--switch-buffer' to use `consult-buffer'."
  (call-interactively 'consult-buffer))

(use-package ace-window
  :config
  ;; We want to switch buffers using `consult'.
  (advice-add
   'aw--switch-buffer :override
   #'wal/instead-call-consult-buffer)

  ;; We update the dispatch list after the package is loaded.
  (setq aw-dispatch-alist '((?h aw-split-window-horz "horizontal split")
                            (?v aw-split-window-vert "vertical split")
                            (?f aw-split-window-fair "fair split")
                            (?d aw-delete-window "delete")
                            (?x wal/aw-delete-window-kill-buffer "kill")
                            (?o delete-other-windows "delete other")
                            (?c aw-copy-window "copy")
                            (?s aw-swap-window "swap")
                            (?b aw-switch-buffer-in-window "buffer")
                            ;; If this has a description, it doesn't work.
                            (?? aw-show-dispatch-help)))

  :custom
  (aw-dispatch-always t)
  (aw-keys '(?j ?k ?l ?\; ?u ?i ?o ?p))
  (aw-fair-aspect-ratio 3)

  :wal-bind
  ("o" . ace-window)

  :delight " ace")
#+END_SRC

*** popper
:PROPERTIES:
:UNNUMBERED: t
:END:

Treat certain buffers and their windows as pop-ups.

#+BEGIN_SRC emacs-lisp
(defconst wal/popper-reference-buffers
  '(docker-container-mode
    "\\*Bookmark Annotation\\*"
    "\\*org-roam\\*"
    ;; Compilation and REPL(-like).
    "\\*poetry-shell\\*"
    "^\\*docker-compose"
    "^\\* docker-compose \\(up\\|run\\|build\\)"
    "^\\*wal-async\\*"
    dap-ui-repl-mode
    cider-repl-mode
    inferior-python-mode
    python-pytest-mode
    "\\*rg\\*\\'"
    compilation-mode
    ;; Debug(-like).
    debugger-mode
    "\\*\\(.+\\)out\\*"
    "^\\* docker container"
    ;; Help(-like).
    helpful-mode
    help-mode
    dictionary-mode
    shortdoc-mode)
  "Replaces `popper-reference-buffers'.")

(defun wal/popper-echo-transform (buffer-name)
  "Transform BUFFER-NAME by truncating certain prefixes."
  (let ((helpful-re "\\*helpful \\w+\:")
        (dc-re "\\* docker-compose \\(?1:up\\|run\\|build\\)\\( --rm\\)?\\ \\(?2:\\w+\\)")
        (cont-re "\\* docker container \\(?1:logs\\|stop\\)?\\ ?\\(--tail [[:digit:]]+\\)?\\ \\(?2:\\w+_\\w+_[[:digit:]]+\\)\\ \\*"))

    (cond
     ((string-match helpful-re buffer-name)
      (concat
       (substring (replace-regexp-in-string helpful-re "" buffer-name) 0 -1)
       "/help"))
     ((string-match dc-re buffer-name)
      (concat
       (with-temp-buffer
         (insert buffer-name)
         (goto-char (point-min))
         (re-search-forward dc-re nil t)
         (concat
           (if (match-string 2) (match-string 2) "")
           "/dc-"
           (if (match-string 1) (match-string 1) "")
           ))))
     ((string-match cont-re buffer-name)
       (with-temp-buffer
         (insert buffer-name)
         (goto-char (point-min))
         (re-search-forward cont-re nil t)
         (concat
           (if (match-string 2) (match-string 2) "")
           "/"
           (if (match-string 1) (match-string 1) ""))))
     (t buffer-name))))

(use-package popper
  :wal-ways nil

  :demand
  :after winner

  :config
  (popper-mode 1)
  (popper-echo-mode 1)

  :custom
  (popper-group-function 'popper-group-by-perspective)
  (popper-reference-buffers wal/popper-reference-buffers)
  (popper-display-control 'user)
  (popper-mode-line '(:eval (concat
                             " "
                             (all-the-icons-faicon "fort-awesome"
                                                   :face 'all-the-icons-dsilver
                                                   :height 0.9
                                                   :v-adjust 0.0)
                             " ")))
  (popper-echo-dispatch-persist nil)
  (popper-echo-dispatch-keys '(?a ?s ?d ?f ?g ?q ?w ?e ?r ?t))
  (popper-echo-lines 1)
  (popper-echo-transform-function #'wal/popper-echo-transform)

  :wal-bind
  (:map popper-mode-map
   ("[" . popper-toggle-latest)
   ("]" . popper-cycle)))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-windows)

;;; wal-windows.el ends here
#+END_SRC

* Movement
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-movement.el" wal/emacs-config-package-path)
:END:

Moving around should be fun.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-movement.el --- Movement. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide movement packages.

;;; Code:

(eval-when-compile
  (require 'avy))

(declare-function avy--line "ext:avy.el")
(declare-function avy-jump "ext:avy.el")
(declare-function org-at-heading-p "ext:org.el")
(declare-function wal/univ-p "wal-func.el")

(defvar avy-goto-word-0)
(defvar avy-goto-word-0-regexp)
#+END_SRC

** Packages

*** avy
:PROPERTIES:
:UNNUMBERED: t
:END:

Who needs a mouse.

#+BEGIN_SRC emacs-lisp
(defun wal/avy-goto-word (&optional line-first)
  "Jump to a word in current line.

If LINE-FIRST is t, move to a line first."
  (interactive "P")
  (when line-first
    (avy-goto-line))

  (avy-with avy-goto-word-0
    (avy-jump avy-goto-word-0-regexp
              :beg (line-beginning-position)
              :end (line-end-position))))

(defun wal/avy-mark-region ()
  "Select two lines and mark the region between them."
  (interactive)
  (avy-with wal/avy-mark-region
    (let* ((beg (avy--line))
           (end (avy--line)))

      (when (> beg end)
        (cl-rotatef beg end))

      (set-mark beg)
      (goto-char end)
      (forward-visible-line 1)
      (point))))

(defun avy-action-zip-to-char (pt)
  "Zip (just mark) from current point up to PT."
  (set-mark (point))
  (goto-char pt))

(defun wal/then-goto-beginning-for-org-headings (&rest _args)
  "Advise `avy-goto-end-of-line' to go to beginning for `org' headings.

When called with `universal-argument', this also goes to the
beginning."
  (when (or (wal/univ-p)
            (and (eq major-mode 'org-mode) (org-at-heading-p)))
    (goto-char (line-beginning-position))))

(use-package avy
  :commands (avy-with)

  :config
  ;; Extend the dispatch with a way to delete up to a char.
  (add-to-list 'avy-dispatch-alist '(?q . avy-action-zip-to-char))

  ;; Make sure we go to the start of the line for org headings.
  (advice-add
   'avy-goto-end-of-line :after
   #'wal/then-goto-beginning-for-org-headings)

  :custom
  (avy-background t)

  :bind
  (:map goto-map
   ("c" . avy-goto-char)           ; Replaces `goto-char'.
   ("l" . avy-goto-line)
   ("e" . avy-goto-end-of-line)
   ("w" . wal/avy-goto-word)
   ("s" . avy-goto-subword-1)
   ("a" . avy-goto-word-0)
   ("q" . avy-goto-word-0-above)
   ("z" . avy-goto-word-0-below))

  :general
  ;; Lines.
  (wal/colonel! "c" 'avy-copy-line 'avy-copy-region)
  (wal/colonel! "x" 'avy-kill-whole-line 'avy-kill-region)
  (wal/colonel! "m" 'avy-move-line 'avy-move-region)
  (wal/colonel! "w"
    'avy-kill-ring-save-whole-line
    'avy-kill-ring-save-region)
  (wal/colonel-sink "h" 'wal/avy-mark-region))
#+END_SRC

*** mwim
:PROPERTIES:
:UNNUMBERED: t
:END:

Move where I want. Useful for comments.

#+BEGIN_SRC emacs-lisp
(use-package mwim
  :bind
  (("C-a" . mwim-beginning)
   ("C-e" . mwim-end)))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-movement)

;;; wal-movement.el ends here
#+END_SRC

* Finding Things
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-find.el" wal/emacs-config-package-path)
:END:

I mostly search.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-find.el --- Finding things. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide packages to find things.

;;; Code:

(declare-function wdb/pop-up "wal-func.el")

(defvar wal/active-theme)
#+END_SRC

** Packages

*** rg
:PROPERTIES:
:UNNUMBERED: t
:END:

You can get the =ripgrep= binary from [[https://github.com/BurntSushi/ripgrep][here]].

#+BEGIN_SRC emacs-lisp
(use-package rg
  :config
  (wdb/pop-up "\\*rg\\*\\'")

  :wal-bind
  ("n" . rg-menu))
#+END_SRC

*** dumb-jump
:PROPERTIES:
:UNNUMBERED: t
:END:

Look up definitions when no LSP is already doing it. Jumping is done
using =xref-find-definitions= (=M-.=).

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :init
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)

  :custom
  (dumb-jump-force-searcher 'rg)
  (dumb-jump-selector 'completing-read))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-find)

;;; wal-find.el ends here
#+END_SRC

* Completion
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-complete.el" wal/emacs-config-package-path)
:END:

Complete commands and code.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-complete.el --- Completion. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide Emacs completion packages.

;;; Code:

(eval-when-compile
  (require 'transient)
  (require 'perspective nil t))

(declare-function org-clock-in "ext:org-clock.el")
(declare-function persp-names "ext:perspective.el")
(declare-function projectile-project-root "ext:projectile.el")
(declare-function wdb/ghost "wal-func.el")
(declare-function wal/append "wal-func.el")

(defvar persp-initial-frame-name)
(defvar savehist-additional-variables)
(defvar xref-show-xrefs-function)
(defvar xref-show-definitions-function)
(defvar wal/active-theme)
(defvar wal/use-projectile)
#+END_SRC

** Inline Completion

*** corfu
:PROPERTIES:
:UNNUMBERED: t
:END:

Alternative.

#+BEGIN_SRC emacs-lisp
(defun wal/corfu-enable-in-minibuffer ()
  "Enable Corfu in the minibuffer if `completion-at-point' is bound."
  (when (where-is-internal #'completion-at-point (list (current-local-map)))
    (corfu-mode 1)))

(use-package corfu
  :hook
  (((prog-mode prog-like) . corfu-mode)
   (minibuffer-setup . wal/corfu-enable-in-minibuffer))

  :custom
  (corfu-auto t)
  (corfu-cycle t))
#+END_SRC

*** corfu-quick
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package corfu-quick
  :ensure nil

  :after corfu

  :bind
  (:map corfu-map
   ("M-q" . corfu-quick-complete)
   ("C-q" . corfu-quick-insert)))
#+END_SRC

*** corfu-history
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package corfu-history
  :ensure nil

  :demand
  :after corfu

  :config
  (add-to-list 'savehist-additional-variables 'corfu-history)
  (corfu-history-mode)

  :custom
  (corfu-history-length 200))
#+END_SRC

*** corfu-doc
:PROPERTIES:
:UNNUMBERED: t
:END:

Show docs while selecting.

#+BEGIN_SRC emacs-lisp
(use-package corfu-doc
  :after corfu

  :bind
  (:map corfu-map
   ("M-p" . corfu-doc-scroll-down)
   ("M-n" . corfu-doc-scroll-up)
   ("M-d" . corfu-doc-toggle)))
#+END_SRC

** Minibuffer Completion

*** vertico
:PROPERTIES:
:UNNUMBERED: t
:END:

Provide global option narrowing using the =vertico= family of products.

#+BEGIN_SRC emacs-lisp
(use-package vertico
  :defer 1

  :config
  ;; Set up minibuffer.
  (setq enable-recursive-minibuffers t
        read-extended-command-predicate #'command-completion-default-include-p
        minibuffer-prompt-properties '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  (vertico-mode)

  :custom
  (vertico-cycle t)
  (vertico-sort-function #'vertico-sort-history-alpha))
#+END_SRC

*** vertico-directory
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(defvar-local wal/command nil
  "Command that started completion session.")

(defun wal/record-this-command ()
  "Record the command which opened the minibuffer."
  (setq-local wal/command this-command))

(defun wal/with-dired-goto-file-ignored (fun &rest args)
  "Advise FUN using ARGS to exit if we came from `dired-goto-file'."
  (unless (and (eq (car args) 'category)
               (eq wal/command 'dired-goto-file))
    (apply fun args)))

(use-package vertico-directory
  :ensure nil

  :demand
  :after vertico

  :hook
  ((rfn-eshadow-update-overlay . vertico-directory-tidy)
   (minibuffer-setup . wal/record-this-command))

  :config
  ;; We don't want to enter directories when we go to file with Dired.
  (advice-add
   'vertico--metadata-get :around
   #'wal/with-dired-goto-file-ignored)

  :bind
  (:map vertico-map
   ("RET" . vertico-directory-enter)
   ("DEL" . vertico-directory-delete-char)
   ("M-DEL" . vertico-directory-delete-word)))
#+END_SRC

*** vertico-quick
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package vertico-quick
  :ensure nil

  :demand
  :after vertico

  :bind
  (:map vertico-map
   ("M-q" . vertico-quick-exit)
   ("C-q" . vertico-quick-insert)))
#+END_SRC

*** orderless
:PROPERTIES:
:UNNUMBERED: t
:END:

Fuzzy matches.

#+BEGIN_SRC emacs-lisp
(use-package orderless
  :demand
  :after vertico

  :config
  ;; Setup basic completion and category defaults/overrides.
  (setq completion-styles '(orderless partial-completion basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+END_SRC

*** marginalia
:PROPERTIES:
:UNNUMBERED: t
:END:

Contextual information during completion, partial completion and
completion actions.

#+BEGIN_SRC emacs-lisp
(use-package marginalia
  :demand
  :after vertico

  :config
  ;; Map external functions to categories.
  (wal/append
   'marginalia-command-categories
   '((projectile-switch-to-buffer . buffer)
     (projectile-find-file . project-file)
     (projectile-find-file-other-window . project-file)
     (projectile-find-dir . project-file)
     (projectile-find-file-in-directory . project-file)
     (projectile-recentf . project-file)
     (projectile-switch-project . project-file)
     (persp-switch-to-buffer . buffer)
     (persp-kill-buffer* . buffer)))

  (marginalia-mode)

  :bind
  (:map minibuffer-local-map
   ("M-a" . marginalia-cycle)))
#+END_SRC

*** embark
:PROPERTIES:
:UNNUMBERED: t
:END:

Act upon =thing-at-point=, be it in a buffer or minibuffer.

#+BEGIN_SRC emacs-lisp
(use-package embark
  :after vertico

  :commands (wal/univ-embark-act)

  :init
  (wal/univ embark-act embark-dwim)

  :config
  ;; No mode-line for collections and completions.
  (wdb/ghost "\\`\\*Embark Collect \\(Live\\|Completions\\)\\*")

  ;; Use `projectile' alternatives when finding files.
  (when wal/use-projectile
    (define-key embark-file-map
                (kbd "f")
                (wal/maybe-use-projectile find-file))
    (define-key embark-file-map
                (kbd "o")
                (wal/maybe-use-projectile find-file-other-window)))

  ;; Search using region.
  (define-key embark-region-map
              (kbd "g")
              #'wal/duck-duck-go-region)

  :custom
  (embark-mixed-indicator-delay 2.0)
  (embark-cycle-key (kbd "C-,"))

  :wal-bind
  ("k" . wal/univ-embark-act))

(use-package embark-consult
  :demand
  :after (embark consult)

  :hook (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC

*** consult
:PROPERTIES:
:UNNUMBERED: t
:END:

Heavy lifting with =consult=.

#+BEGIN_SRC emacs-lisp
(defconst wal/consult-buffer-filter
  '("\\*Buffer List\\*"
    "\\*Calendar\\*"
    "\\*Call Hierarchy\\*"
    "\\*cider"
    "\\*compilation"
    "\\*dap"
    "\\*dashboard"
    "\\*docker"
    "\\* docker"
    "\\*Flutter"
    "\\*Flycheck"
    "\\*Help"
    "\\*helpful"
    "\\*HTTP"
    "\\*info\\*"
    "\\*lsp"
    "\\*Messages\\*"
    "\\*Packages\\*"
    "\\*poetry"
    "\\*RE-Builder\\*"
    "\\*rg"
    "\\*scratch"
    "\\*vterm"
    "\\*xref"
    "out\\*$"
    "^magit"
    "server log\\*$")
  "Additional buffers to filter.")

(defun wal/consult-ripgrep-ignored (&optional dir initial)
  "Search for regexp with rg in DIR with INITIAL input.
Do not ignore hidden files."
  (interactive "P")
  (let ((consult-ripgrep-args
         (concat (substring consult-ripgrep-args 0 -1) "--no-ignore .")))

    (when (and (fboundp 'consult--grep)
               (fboundp 'consult--ripgrep-builder))
      (consult--grep "Ripgrep (ignored)" #'consult--ripgrep-builder dir initial))))

(defun wal/consult-line (&optional at-point)
  "Call consult line using `thing-at-point' if AT-POINT is t."
  (interactive "P")
  (if at-point
      (consult-line (thing-at-point 'symbol))
    (consult-line)))

(defun wal/consult-clock-in ()
  "Clock into an Org agenda heading.

If the initial perspective still exists, switch to that first to
not pollute the current one."
  (interactive)
  (save-window-excursion
    (if (memq persp-initial-frame-name (persp-names))
        (with-perspective persp-initial-frame-name
          (consult-org-agenda)
          (org-clock-in))
      (consult-org-agenda)
      (org-clock-in))))

(defun wal/then-set-active-theme (theme)
  "Advise to set `wal/active-theme' to THEME."
  (setq wal/active-theme theme)
  (run-hooks 'wal/theme-hook))

(defun wal/with-big-vertico (fun &rest args)
  "Call FUN with ARGS but increase the `vertico-count'."
  (defvar vertico-count)
  (let ((vertico-count 20))

    (apply fun args)))

(use-package consult
  :commands
  (wal/consult-line
   wal/consult-clock-in)

  :config
  ;; Integrate into `projectile' and `xref'.
  (when wal/use-projectile
    (setq consult-project-function #'projectile-project-root))
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Filter out additional buffers.
  (wal/append 'consult-buffer-filter wal/consult-buffer-filter)

  ;; Customize sources.
  (consult-customize
   consult--source-recent-file
   consult--source-project-recent-file
   consult--source-bookmark
   :preview-key (kbd "M-,")
   consult--source-project-recent-file
   :narrow ?r
   wal/consult-clock-in
   :prompt "Clock in: "
   :preview-key (kbd "M-."))


  ;; Be sure to set the active them after switching.
  (advice-add 'consult-theme :after #'wal/then-set-active-theme)

  ;; Use a bigger `vertico' when grepping.
  (advice-add 'consult-ripgrep :around #'wal/with-big-vertico)

  ;; Create suffixes for other transients.
  (with-eval-after-load 'rg-menu
    (transient-append-suffix 'rg-menu "p" '("u" "Using consult" consult-ripgrep)))
  (with-eval-after-load 'lsp-mode
    (transient-append-suffix 'wal/lsp-dispatch '(0 3 1)
      '("s" "symbol" consult-lsp-file-symbols)))
  (with-eval-after-load 'flycheck
    (transient-append-suffix 'wal/flycheck-dispatch '(0 0 1)
      '("u" "consult" consult-flycheck)))

  :bind
  (("C-c s" . wal/consult-line)
   ("C-c i" . wal/consult-clock-in)
   ("C-c l" . consult-locate)
   :map goto-map
   ("g" . consult-goto-line)
   ("h" . consult-org-heading)
   ("m" . consult-mark)
   ("M" . consult-global-mark)
   :map kmacro-keymap
   ("u" . consult-kmacro)
   :map bookmark-map
   ("u" . consult-bookmark)
   :map ctl-x-r-map
   ("u" . consult-register)
   ("S" . consult-register-store)
   ("L" . consult-register-load))

  :wal-bind
  ("j" . consult-buffer)

  :general
  (wal/general
    "st" '(consult-theme :wk "consult theme")
    "fr" '(consult-recent-file :wk "recent"))
  (wal/captain
    "+" 'consult-mode-command
    "-" 'consult-minor-mode-menu))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-complete)

;;; wal-complete.el ends here
#+END_SRC

* Workspace
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-workspace.el" wal/emacs-config-package-path)
:END:

Keep order.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-workspace.el --- Workspace. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide workspace packages.

;;; Code:

(eval-when-compile
  (require 'perspective nil t))

(declare-function consult-customize "ext:consult.el")
(declare-function consult--buffer-query "ext:consult.el")
(declare-function consult--buffer-state "ext:consult.el")
(declare-function consult--regexp-filter "ext:consult.el")
(declare-function persp-current-buffers "ext:perspective.el")
(declare-function persp-current-buffer-names "ext:perspective.el")
(declare-function persp-current-name "ext:perspective.el")
(declare-function persp-names "ext:perspective.el")
(declare-function persp-mode-line "ext:perspective.el")
(declare-function persp-scratch-buffer "ext:perspective.el")
(declare-function persp-switch "ext:perspective.el")
(declare-function persp-switch-to-buffer "ext:perspective.el")
(declare-function projectile-project-p "ext:projectile.el")
(declare-function projectile-read-command "ext:projectile.el")
(declare-function wal/append "wal-func.el")
(declare-function wal/major "wal-key-bindings.el")
(declare-function wal/univ-p "wal-func.el")

(defvar consult-buffer-filter)
(defvar consult-buffer-sources)
(defvar consult--source-buffer)
(defvar org-agenda-files)
(defvar persp-initial-frame-name)
(defvar persp-modestring-short)
(defvar projectile-globally-ignored-directories)
(defvar projectile-globally-ignored-files)
(defvar projectile-globally-ignored-file-suffixes)

(defgroup wal-workspace nil
  "Change settings used for workspace packages."
  :group 'wal
  :tag "Workspace")

;;;; Customization:

(defcustom wal/use-projectile t
  "Whether to use `projectile' over `project'."
  :type 'boolean
  :group 'wal-workspace)

(defcustom wal/default-perspective "walheimat"
  "The name of my default perspective."
  :type 'string
  :group 'wal-workspace)

(defcustom wal/perspective-truncate-after 20
  "Name truncation threshold.

If the combined length of names pass it, names of inactive
perspectives are truncated."
  :type 'integer
  :group 'wal-workspace)

(defcustom wal/perspective-shorten-after 20
  "Shorten threshold.

If the mode-line string passes it, only the active perspective is
shown."
  :type 'integer
  :group 'wal-workspace)

(defcustom wal/perspective-truncated-length 3
  "The length of a perspective name when truncated."
  :type 'integer
  :group 'wal-workspace)
#+END_SRC

** Packages

*** perspective
:PROPERTIES:
:UNNUMBERED: t
:END:

Group buffers in workspaces.

#+BEGIN_SRC emacs-lisp
;; Utility

(defun wal/persp-maybe-shorten ()
  "Maybe shorten mode-line string when many perspectives are open."
  (let ((truncated-length (length (mapconcat #'identity (persp-mode-line) ""))))

    (setq persp-modestring-short
        (> truncated-length wal/perspective-shorten-after))))

(defun wal/kill-dired-buffers-in-perspective ()
  "Kill all Dired buffers in the current perspective."
  (interactive)
  (with-current-perspective
    (let ((buffers (buffer-list)))
      (dolist (it buffers)
        (with-current-buffer it
          (when (derived-mode-p 'dired-mode it)
            (when-let ((window (get-buffer-window it)))
              (delete-window window))
            (kill-buffer it)))))))

;; Advice.

(defun wal/without-querying-for-process-kill (fun &rest args)
  "Advises FUN to kill processes without querying, applying ARGS.

This only removes `process-kill-buffer-query-function'."
  (let ((kill-buffer-query-functions (delq 'process-kill-buffer-query-function
                                           kill-buffer-query-functions)))

    (apply fun args)))

(defun wal/apply-truncation-to-non-active (&rest args)
  "Truncate non-active perspective name (in ARGS)."
  (let* ((name (car args))
         (curr-name (persp-current-name))
         (names (persp-names))
         (names-len (length names))
         (divider-len (if (> 1 names-len)
                          (+ 1 names-len)
                        2))
         (combined-length (+ divider-len
                             (seq-reduce
                              (lambda (acc item)
                                (+ acc (length item)))
                              names
                              0))))

    (if (and (> combined-length wal/perspective-truncate-after)
             (not (string-match-p name curr-name)))
        (substring name 0 (min (length name) wal/perspective-truncated-length))
      name)))

(defun wal/instead-guess-truncated-perspective (event)
  "Guess perspective from click EVENT and switch."
  (let ((clicked (format "%s" (car (posn-string (event-start event))))))

    (if (eq (length clicked) wal/perspective-truncated-length)
        (when-let* ((r (concat "^" clicked))
                    (names (persp-names))
                    (p (cl-find-if (lambda (it) (string-match r it)) names)))

          (persp-switch p))
      (persp-switch clicked))))

(defun wal/with-persp-buffers-only (fun &rest _args)
  "Advise FUN `list-buffers--refresh' to only consider perspective buffers.

No filter is applied if called with `universal-argument'."
  (if (wal/univ-p)
      (apply fun nil)
    (apply fun (list (seq-filter 'buffer-live-p (persp-current-buffers))))))

(defun wal/then-remove-agenda-buffers ()
  "Remove agenda buffers from the current perspective."
  (when (and (fboundp 'persp-remove-buffer)
             (not (string-equal (persp-current-name) persp-initial-frame-name)))
    (dolist (buf (persp-current-buffers))
      (when-let* ((name (buffer-file-name buf))
                  (matches (seq-some (lambda (it) (string-prefix-p it name)) org-agenda-files)))

        (persp-remove-buffer buf)))))

;; Integration with `consult'.

(defun wal/consult-persp-buffer--query ()
  "Buffer query for `perspective'."
  (consult--buffer-query
    :sort 'visibility
    :as #'buffer-name
    :predicate
    '(lambda (buf) (and (persp-is-current-buffer buf)
                   (with-current-buffer buf
                     (not (derived-mode-p 'dired-mode)))))))

(use-package perspective
  :defer 1

  :commands (wal/persp)

  :hook
  ((kill-emacs . persp-state-save)
   ((persp-created
     persp-killed
     persp-after-rename) . wal/persp-maybe-shorten))

  :config
  ;; Kill processes of killed perspectives without prompt.
  (advice-add
   'persp-kill :around
   #'wal/without-querying-for-process-kill)

  ;; Truncate inactive perspectives.
  (advice-add
   'persp-format-name :filter-return
   #'wal/apply-truncation-to-non-active)

  ;; Make clicking work despite truncation.
  (advice-add
   'persp-mode-line-click :override
   #'wal/instead-guess-truncated-perspective)

  ;; Refresh the buffer list with filtering intact.
  (advice-add
   'list-buffers--refresh :around
   #'wal/with-persp-buffers-only)

  ;; Remove agenda buffers after notes are stored.
  (advice-add
   'org-store-log-note :after
   #'wal/then-remove-agenda-buffers)

  ;; Customize buffer source, add new one for Dired.
  (with-eval-after-load 'consult
    (consult-customize
     consult--source-buffer
     :name "Perspective Buffer"
     :items #'wal/consult-persp-buffer--query))

  ;; Register command map.
  (wal/major "i" '(:keymap perspective-map :wk "perspective"))

  ;; Override the override to `perspective-map' in older Emacs versions.
  (when (< emacs-major-version 28)
    (define-key persp-mode-map (kbd "C-x x") ctl-x-x-map))

  (persp-mode 1)

  :custom
  (persp-modestring-dividers '("(" ")" "/"))
  (persp-initial-frame-name wal/default-perspective)
  (persp-state-default-file (expand-file-name "persp-persist" wal/cache-directory))
  (persp-suppress-no-prefix-key-warning t)

  :bind
  (:map persp-mode-map
   ("C-x b" . persp-switch-to-buffer)
   ("C-x C-b" . persp-buffer-menu)
   :map perspective-map
   ("l" . persp-list-buffers))

  :wal-bind
  (:map persp-mode-map
   ("i" . persp-switch)))
#+END_SRC

*** projectile
:PROPERTIES:
:UNNUMBERED: t
:END:

More robust project management.

#+BEGIN_SRC emacs-lisp
(defmacro wal/maybe-use-projectile (func)
  "Maybe use the `projectile' variant for FUNC."
  (let* ((func-name (symbol-name func))
         (projectile-func-name (concat "projectile-" func-name)))

  `(defun ,(intern (concat "wal/maybe-use-projectile-" func-name)) ()
     ,(format "Use `%s' instead of `%s' if in a project." projectile-func-name func-name)
     (interactive)
     (with-demoted-errors "%s"
       (require 'projectile)
       (if (projectile-project-p)
           (call-interactively (symbol-function ',(intern projectile-func-name)))
         (call-interactively (symbol-function ',func)))))))

(defun wal/with-projectile-switch (func &rest args)
  "Call FUNC with ARGS or switch project."
  (if (projectile-project-p)
      (apply func args)
    (call-interactively 'projectile-switch-project)))

(use-package projectile
  :commands
  (wal/projectile
   projectile-project-root)

  :if wal/use-projectile

  :init
  ;; Switch to project first if outside a project.
  (advice-add
   'projectile-find-file :around
   #'wal/with-projectile-switch)

  :config
  ;; Extend the various ignore lists.
  (wal/append 'projectile-globally-ignored-directories
              '("node_modules" "build" "_build" "android"))
  (wal/append 'projectile-globally-ignored-files
              '("yarn.lock" "package.lock" "bundle.js"))
  (wal/append 'projectile-globally-ignored-file-suffixes
              '(".min.js" ".js.map"))

  ;; Register command map.
  (wal/major "p" '(:keymap projectile-command-map :wk "projectile"))

  (projectile-mode 1)

  :custom
  (projectile-switch-project-action #'projectile-dired)
  (projectile-sort-order 'recentf)
  ;; Allow finding files that are ignored by `.gitignore'.
  (projectile-indexing-method 'hybrid)
  (projectile-enable-caching t)
  (projectile-per-project-compilation-buffer t)
  ;; TEMP: Currently passing missing switch "--strip-cwd-prefix".
  (projectile-generic-command "fd . -0 --type f --color=never")

  :wal-bind
  (:map projectile-mode-map
   ("h" . projectile-find-file)
   ("p" . projectile-switch-project))

  :delight " pjt")
#+END_SRC

*** project
:PROPERTIES:
:UNNUMBERED: t
:END:

Built-in but entirely dependent on either =git= or =hg=.

#+BEGIN_SRC emacs-lisp
(use-package project
  :if (not wal/use-projectile)

  :ensure nil

  :demand t

  :config
  (wal/major "p" '(:keymap project-prefix-map :wk "project"))

  :custom
  (project-switch-commands 'project-find-dir)
  (project-vc-ignores '("node_modules/"
                        "build/"
                        "android/"
                        "*.lock"
                        "bundle.js"
                        "*.min.js"
                        "*.js.map"))

  :wal-bind
  (("l" . project-find-file)
   ("p" . project-switch-project)))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-workspace)

;;; wal-workspace.el ends here
#+END_SRC

* Org Mode
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-org.el" wal/emacs-config-package-path)
:END:

The best thing about Emacs. Check out the [[https://orgmode.org/manual/][manual]].

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-org.el --- Org. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide org packages/configurations.

;;; Code:

(eval-when-compile
  (require 'transient)
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function org-roam-buffer-p "ext:org-roam.el")
(declare-function persp-names "ext:perpectivel.el")
(declare-function persp-switch "ext:perpectivel.el")
(declare-function projectile-project-root "ext:projectile.el")
(declare-function project-root "ext:project.el")
(declare-function transient-define-prefix "ext:transient.el")
(declare-function wal/append "wal-func.el")
(declare-function wal/disable-tabs "wal-func.el")
(declare-function wal/message-in-a-bottle "wal-func.el")
(declare-function wal/replace-in-alist "wal-fun.el")
(declare-function wal/truncate "wal-func.el")
(declare-function wal/univ-p "wal-func.el")

(defvar org-global-properties)
(defvar org-mode-map)
(defvar persp-initial-frame-name)
(defvar text-scale-mode-step)
(defvar visual-fill-column-width)
(defvar visual-fill-column-center-text)
(defvar wal/agenda-tasks-directory)
(defvar wal/lieutenant-key)
(defvar wal/use-projectile)

(defgroup wal-org nil
  "Change settings used for org packages."
  :group 'wal
  :tag "Org")

;;;; Customization:

(defcustom wal/org-roam-dailies-directory "tagebuch/"
  "The directory for dailies."
  :type 'string
  :group 'wal-org)

(defcustom wal/org-tree-slide-visual-fill-column-width 160
  "The base `visual-fill-column-width' for `org-tree-slide' presentations."
  :type 'integer
  :group 'wal-org)
#+END_SRC

** The Mode Itself

*** org
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(defun wal/first-require-ox-md (&rest _args)
  "Advise to require `ox-md' before export dispatch."
  (unless (featurep 'ox-md)
    (require 'ox-md nil t)))

(defun wal/org-content (level)
  "Show up to given LEVEL.
This calls `org-content' interactively."
  (interactive "nShow content up to level: ")
  (when (fboundp 'org-content)
    (org-content level)))

(use-package org
  :ensure nil

  :hook (org-mode . auto-fill-mode)

  :init
  (wal/hook org-mode
    "Hook into `org-mode'."
    :messages '("Organize! Seize the means of production!")
    :lieutenant t)

  :config
  ;; TEMP: Getting missing face errors otherwise.
  (require 'org-indent)

  ;; Remove `org-cycle-agenda-files'.
  (define-key org-mode-map (kbd "C-,") nil)

  ;; Require `ox-md' before calling dispatch as it might not be loaded.
  (advice-add
   'org-export-dispatch :before
   #'wal/first-require-ox-md)

  (with-no-warnings
    (transient-define-prefix wal/org-mode-dispatch ()
      "Access `org-mode' commands."
      [["Commands"
        ("n" "add note" org-add-note)
        ("t" "toggle timestamp" org-toggle-timestamp-type
         :inapt-if-not (lambda () (org-at-timestamp-p 'inactive)))]
       ["Subtrees"
        ("s w" "cut" org-cut-subtree
         :inapt-if-not (lambda () (org-at-heading-p)))
        ("s y" "paste" org-paste-subtree)]
       ["Visibility"
        ("v a" "show all" org-show-all)
        ("v l" "up to level" wal/org-content)]
       ["Footnotes"
        ("f a" "add" org-footnote-new
         :inapt-if (lambda () (org-in-src-block-p)))
        ("f n" "normalize" org-footnote-normalize)]]))

  :custom
  ;; Make it look nice and tidy.
  (org-adapt-indentation nil)
  (org-ellipsis "↷")
  (org-hide-emphasis-markers t)
  (org-startup-with-inline-images t)
  (org-startup-folded 'overview)
  (org-cycle-separator-lines 1)

  ;; Logging.
  (org-log-done 'time)
  (org-log-note-clock-out t)
  (org-log-into-drawer t)

  ;; Set up directories.
  (org-directory wal/org-directory)
  (org-default-notes-file (concat org-directory "/notes.org"))
  (org-agenda-files `(,wal/agenda-tasks-directory))

  ;; Be sure to add archive tag with `org-toggle-archive-tag'.
  (org-archive-location "::* Archived")

  ;; Adapt keywords, tags and speed commands.
  (org-todo-keywords
   '((sequence "TODO(t)" "IN PROGRESS(p)" "WAITING(w)" "BLOCKED(b)" "|" "DONE(d)" "CANCELED(c)")))
  (org-tag-alist
   '(;; Depth.
     ("@immersive" . ?i)
     ("@process" . ?p)
     ;; Context.
     ("@work" . ?w)
     ("@home" . ?h)
     ("@away" . ?a)
     ("@repeated" . ?r)
     ("@unbillable" . ?u)
     ("@intermittent" . ?m)
     ;; Energy.
     ("@easy" . ?1)
     ("@average" . ?2)
     ("@challenge" . ?3)
     ;; Category.
     ("@development" . ?d)
     ("@talk" . ?t)
     ("@contribution" . ?c)
     ("@growth" . ?g)
     ("@education" . ?e)
     ("@chore" . ?h)))

  ;; Warn late about upcoming deadlines.
  (org-deadline-warning-days 2)

  :bind
  (:map org-mode-map
   ("M-p" . org-previous-visible-heading)
   ("M-n" . org-next-visible-heading)))
#+END_SRC

** Agendas

*** org-agenda
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(defvar wal/org-agenda-window-configuration nil
  "The (stored) window configuration for the agenda view.")

(defun wal/agenda (&optional no-restore)
  "Go to task directory with Dired and open the agenda.

Attempts to restore view unless NO-RESTORE is t."
  (interactive "P")
  (when (memq persp-initial-frame-name (persp-names))
    (persp-switch persp-initial-frame-name))
  (let* ((wconf wal/org-agenda-window-configuration)
         (task-buffer-name (car (last (split-string wal/agenda-tasks-directory "/"))))
                           (buffer-count (seq-count
                                          (lambda (it) (or (string-equal (buffer-name it) "*Org Agenda*")
                                                      (string-equal (buffer-name it) task-buffer-name)))
                                          (buffer-list))))

         (if (and wconf (eq buffer-count 2) (not no-restore))
             (set-window-configuration wconf)
           (dired wal/agenda-tasks-directory)
           (org-agenda (wal/univ-p) "a")
           (setq wal/org-agenda-window-configuration (current-window-configuration)))))

(use-package org-agenda
  :ensure nil

  :commands (wal/agenda)

  :config
  (wal/replace-in-alist 'org-agenda-prefix-format '((agenda . "  %?-12t %s%b")))

  :custom
  (org-agenda-hide-tags-regexp "^@")
  (org-agenda-span 'day)
  (org-agenda-restore-windows-after-quit t)
  (org-agenda-time-leading-zero t)
  (org-agenda-log-mode-items '(clock))
  (org-agenda-clockreport-parameter-plist
   '(:link t
     :maxlevel 3
     :fileskip0 t
     :emphasize t
     :match "-@unbillable"))

  :bind
  ("C-c a" . wal/agenda))
#+END_SRC

*** org-habit
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package org-habit
  :ensure nil

  :custom
  (org-habit-show-habits-only-for-today nil)
  (org-habit-graph-column 50))
#+END_SRC

*** org-super-agenda
:PROPERTIES:
:UNNUMBERED: t
:END:

Allow for better grouping.

#+BEGIN_SRC emacs-lisp
(use-package org-super-agenda
  :wal-ways nil

  :demand
  :after org-agenda

  :config
  (org-super-agenda-mode)

  :custom
  (org-super-agenda-groups
   '((:name "Schedule" :time-grid t)
     (:name "Unscheduled"
      :and (:scheduled nil
            :not (:tag "@intermittent" :todo "BLOCKED")))
     (:name "Leftovers"
      :and (:todo ("IN PROGRESS" "WAITING")
            :scheduled past
            :not (:tag "@repeated" :tag "@education")))
     (:name "Blocked" :todo "BLOCKED")
     (:name "Education" :and (:habit t :tag "@education"))

     ;; Habits.
     (:name "Contribution"
      :and (:habit t
            :tag "@contribution"))
     (:name "Growth"
      :and (:habit t
            :tag "@growth"))
     (:name "Chores"
      :and (:habit t
            :tag "@chore"))
     (:name "Other habits"
            :habit t)

     ;; Discard the rest.
     (:discard (:anything t))))
  (org-super-agenda-final-group-separator "\n"))
#+END_SRC

** Zettelkasten

Trying to organize my thoughts using Zettelkästen.

/Note/ that you will need to install =sqlite3= manually.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack org-roam
  "Note rhizome."
  :packages (org-roam)
  :extras (org-roam-ui))
#+END_SRC

*** org-roam
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(defun wal/maybe-org-roam-refile (&rest args)
  "Refile using ARGS, but use `org-roam-refile' for its buffers.

If called with `universal-argument', default to `org-roam' in any
case."
  (interactive)
  (declare-function org-refile "ext:org.el")
  (if (and (org-roam-buffer-p) (not (wal/univ-p)))
      (org-roam-refile)
    (org-refile args)))

(use-package org-roam
  :if (executable-find "sqlite3")
  :wal-ways nil

  :ensure nil

  :commands
  (wal/org-roam
   org-roam-buffer-display-dedicated
   org-roam-capture
   org-roam-node-create
   org-roam-node-find
   org-roam-node-read)

  :init
  (setq org-roam-v2-ack t)

  :config
  ;; Show roam buffer on the right.
  (wdb/side 'org-roam-mode :side 'right)

  ;; Refile differently for these files.
  (wal/replace-in-alist 'org-speed-commands '(("w" . wal/maybe-org-roam-refile)))

  ;; Add todos from the dailies to the agenda.
  (add-to-list 'org-agenda-files (expand-file-name
                                  wal/org-roam-dailies-directory
                                  wal/org-roam-directory))

  (transient-define-prefix wal/org-roam-dispatch ()
    "Run `org-roam' commands."
    [["Capture"
      ("c" "capture" org-roam-capture)
      ("t" "today" org-roam-dailies-capture-today)
      ("o" "normal" org-capture)]
     ["Find"
      ("f" "find" org-roam-node-find)
      ("d" "find daily" org-roam-dailies-goto-date)
      ("D" "find daily directory" org-roam-dailies-find-directory)]
     ["Actions"
      ("b" "buffer" org-roam-buffer-toggle)
      ("w" "refile" org-roam-refile
       :inapt-if-not-mode 'org-mode)
      ("i" "insert" org-roam-node-insert
       :inapt-if-not-mode 'org-mode)
      ("@" "tag" org-roam-tag-add
       :inapt-if-not-mode 'org-mode)]
     ["Visualization"
      ("g" "graph" org-roam-graph)]])

  (org-roam-db-autosync-enable)

  :custom
  ;; Setup directories and file names.
  (org-roam-directory wal/org-roam-directory)
  (org-roam-dailies-directory wal/org-roam-dailies-directory)
  (org-roam-extract-new-file-path "${slug}.org")

  ;; Simple capture templates.
  (org-roam-capture-templates
   '(("d" "default" plain "%?"
      :target (file+head "${slug}.org"
                         "#+title: ${title}\n")
      :unnarrowed t)))
  (org-roam-dailies-capture-templates
   '(("d" "default" entry
      "* %?\n:PROPERTIES:\n:CREATED_AT: %U\n:TASK: %k\n:END:"
      :target (file+head "%<%Y-%m-%d>.org"
                         "#+title: %<%Y-%m-%d>\n")
      :empty-lines 1)))

  :wal-bind
  ("<SPC>" . wal/org-roam-dispatch))
#+END_SRC

*** org-roam-ui
:PROPERTIES:
:UNNUMBERED: t
:END:

Fancy UI.

#+BEGIN_SRC emacs-lisp
(use-package org-roam-ui
  :wal-ways nil

  :defer 3
  :after org-roam

  :config
  (transient-append-suffix 'wal/org-roam-dispatch '(0 3 0)
    '("u" "ui" org-roam-ui-mode))

  :ensure nil)
#+END_SRC

** Presentations

*** org-tree-slide
:PROPERTIES:
:UNNUMBERED: t
:END:

Turn any =org-mode= buffer into a presentation.

#+BEGIN_SRC emacs-lisp
(defun wal/relative-column-width (&optional target-width)
  "Get the relative column width of TARGET-WIDTH."
  (let ((width (or target-width 160))
        (scale (if (and (boundp 'text-scale-mode-amount)
                        (numberp text-scale-mode-amount))
                   (expt text-scale-mode-step text-scale-mode-amount)
                 1)))

    (ceiling (/ width scale))))

(defun wal/org-tree-slide-toggle-visibility ()
  "Toggle visibility of cursor."
  (interactive)
  (if cursor-type
      (setq cursor-type nil)
    (setq cursor-type t)))

(defvar wal/org-tree-slide-disabled-modes '())

(defun wal/org-tree-slide-play ()
  "Hook into `org-tree-slide-play'."
  (setq visual-fill-column-width (wal/relative-column-width
                                  wal/org-tree-slide-visual-fill-column-width)
        visual-fill-column-center-text t
        cursor-type nil)
  (visual-fill-column-mode 1)

  (when (bound-and-true-p dimmer-mode)
    (setq wal/org-tree-slide-disabled-modes
      (append wal/org-tree-slide-disabled-modes '(dimmer-mode)))
    (dimmer-mode -1))

  (mixed-pitch-mode 1))

(defun wal/org-tree-slide-stop ()
  "Hook into `org-tree-slide-stop'."
  (setq visual-fill-column-width nil
        visual-fill-column-center-text nil
        cursor-type t)
  (visual-fill-column-mode -1)

  (when (fboundp 'outline-show-all)
    (outline-show-all))

  (when (memq 'dimmer-mode wal/org-tree-slide-disabled-modes)
    (dimmer-mode 1))

  (setq wal/org-tree-slide-disabled-modes '())

  (mixed-pitch-mode -1))

(defun wal/org-tree-slide-text-scale ()
  "Hook into `text-scale-mode-hook' for `org-tree-slide'."
  (when (and (boundp 'org-tree-slide-mode) org-tree-slide-mode)
    (wal/org-tree-slide-play)))

(use-package org-tree-slide
  :wal-ways nil

  :hook
  ((org-tree-slide-play . wal/org-tree-slide-play)
   (org-tree-slide-stop . wal/org-tree-slide-stop)
   (text-scale-mode . wal/org-tree-slide-text-scale))

  :config
  ;; Insert new group after "Visibility".
  (transient-append-suffix 'wal/org-mode-dispatch '(0 2)
    ["Presentation"
     ("p" "present" org-tree-slide-mode)
     ("i" "indent" org-indent-mode)])

  :custom
  (org-tree-slide-never-touch-face t)
  (org-tree-slide-cursor-init nil)
  (org-tree-slide-activate-message "We're on a road to nowhere")
  (org-tree-slide-deactivate-message "Take you here, take you there")
  (org-tree-slide-indicator '(:next "   >>>" :previous "<<<" :content "< Here is where time is on our side >"))

  :bind
  (:map org-tree-slide-mode-map
   ("q" . org-tree-slide-mode) ; To close it again.
   ("n" . org-tree-slide-move-next-tree)
   ("p" . org-tree-slide-move-previous-tree)
   ("i" . text-scale-increase)
   ("d" . text-scale-decrease)
   ("v" . wal/org-tree-slide-toggle-visibility))

  :diminish buffer-face-mode)
#+END_SRC

** Editing

*** org-src
:PROPERTIES:
:UNNUMBERED: t
:END:

Editing source blocks.

#+BEGIN_SRC emacs-lisp
(use-package org-src
  :ensure nil

  :after org

  :init
  (wal/hook org-src-mode ()
    "Hook into function `org-src-mode'."
    (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

  :config
  (wal/append
   'org-src-lang-modes
   '(("dockerfile" . dockerfile)
     ("conf" . conf)
     ("markdown" . markdown)
     ("fish" . fish)))

  (transient-append-suffix 'wal/org-mode-dispatch '(0 0 1)
    '("e" "edit source" org-edit-src-code :inapt-if-not (lambda () (org-in-src-block-p))))

  :custom
  (org-src-tab-acts-natively nil)
  (org-edit-src-content-indentation 0)

  :bind
  (:map org-src-mode-map
   ("C-c C-c" . org-edit-src-exit))

  :delight " osc")
#+END_SRC

*** org-capture
:PROPERTIES:
:UNNUMBERED: t
:END:

Capture templates.

#+BEGIN_SRC emacs-lisp
(defun wal/org-capture-find-project-tasks ()
  "Find a project's tasks file.

If the project root cannot be determined, use
`wal/org-directory'. as destination."
  (let ((proj-root (if wal/use-projectile
                       (projectile-project-root)
                     (project-root (project-current)))))

    (expand-file-name "tasks.org" (or proj-root org-directory))))

(use-package org-capture
  :ensure nil

  :custom
  (org-capture-templates
   `(("c" "current task" plain
      (clock)
      "\n%?\n"
      :empty-lines-before 1)
     ("d" "daily" plain
      (file+olp+datetree ,(concat org-directory "/dailies.org"))
      "%i\n%?")
     ("p" "project task" entry
      (file+headline wal/org-capture-find-project-tasks "Tasks")
      "* TODO %?\n\n%F\n\n%i"
      :empty-lines-before 1)))
  (org-capture-bookmark nil) ; Prevents countless edit buffers since we annotate bookmarks.

  :delight " cap")
#+END_SRC

*** org-transclusion
:PROPERTIES:
:UNNUMBERED: t
:END:

Spectral inclusion.

#+BEGIN_SRC emacs-lisp
(use-package org-transclusion
  :commands wal/org-transclusion

  :config
  ;; Not using `org-transclusion-map' as it includes `org-mode-map'.
  (transient-define-prefix wal/org-transclusion ()
    "Access `org-transclusion' commands."
    [["Transclusion commands"
      ("a" "add" org-transclusion-add)
      ("A" "add all" org-transclusion-add-all)
      ("x" "remove" org-transclusion-remove)
      ("X" "remove all" org-transclusion-remove-all all)
      ("l" "from link" org-transclusion-make-from-link)
      ("r" "refresh" org-transclusion-refresh)
      ("s" "sync start" org-transclusion-live-sync-start)
      ("S" "sync exit" org-transclusion-live-sync-exit)]])

  (transient-append-suffix 'wal/org-mode-dispatch '(0 0 2)
    '("c" "transclusion" wal/org-transclusion))

  :custom
  (org-transclusion-mode-lighter " tra"))
#+END_SRC

*** org-refile
:PROPERTIES:
:UNNUMBERED: t
:END:

Configure refiling headings.

#+BEGIN_SRC emacs-lisp
(use-package org-refile
  :ensure nil

  :custom
  ;; Allow refiling in same file up to level 3.
  (org-refile-targets
   '((nil . (:maxlevel . 3)))))
#+END_SRC

** Other

*** org-babel
:PROPERTIES:
:UNNUMBERED: t
:END:

Convenient (and less safe) source block interaction.

#+BEGIN_SRC emacs-lisp
(use-package ob
  :ensure nil

  :config
  ;; Load a few more languages.
  (wal/append
   'org-babel-load-languages
   '((shell . t)
     (python . t)
     (latex . t)
     (js . t)))

  :custom
  (org-confirm-babel-evalute nil))
#+end_src

*** org-clock
:PROPERTIES:
:UNNUMBERED: t
:END:

You know the drill. Clock in, clock out.

#+BEGIN_SRC emacs-lisp
(defun wal/org-clock-in-switch-to-state (todo-state)
  "Only switch state to IN PROGRESS if TODO-STATE was given."
  (when todo-state
    "IN PROGRESS"))

(defun wal/org-clock-heading ()
  "Render a truncated heading for modeline."
  (when (and (fboundp 'org-link-display-format) (fboundp 'org-get-heading))
    (let ((heading (org-link-display-format
	                (org-no-properties (org-get-heading t t t t)))))

      (wal/truncate heading 12))))

(defun wal/org-clock-in-from-now ()
  "Force `org-clock-in' without continuous logging."
  (defvar org-clock-continuously)
  (let ((org-clock-continuously nil))

    (when (fboundp 'org-clock-in)
      (org-clock-in))))

(use-package org-clock
  :ensure nil

  :after org

  :init
  (add-to-list 'org-speed-commands '("N" . wal/org-clock-in-from-now))

  :custom
  ;; We want a continuous, persistent clock.
  (org-clock-idle-time 60)
  (org-clock-continuously t)
  (org-clock-persist t)
  (org-clock-in-switch-to-state 'wal/org-clock-in-switch-to-state)
  (org-clock-in-resume t)
  (org-clock-report-include-clocking-task t)
  (org-clock-out-remove-zero-time-clocks t)

  ;; Truncate overly long tasks.
  (org-clock-heading-function #'wal/org-clock-heading)

  :bind
  (:map goto-map
    ("t" . org-clock-goto)))
#+END_SRC

*** org-duration
:PROPERTIES:
:UNNUMBERED: t
:END:

Set up durations for a 40-hour week.

#+BEGIN_SRC emacs-lisp
(use-package org-duration
  :ensure nil

  :after org

  :config
  ;; 40h working week, one month of vacation.
  (wal/replace-in-alist
    'org-duration-units
    `(("d" . ,(* 60 8))
      ("w" . ,(* 60 8 5))
      ("m" . ,(* 60 8 5 4))
      ("y" . ,(* 60 8 5 4 11)))))
#+END_SRC

*** org-keys
:PROPERTIES:
:UNNUMBERED: t
:END:

Add some user speed commands.

#+BEGIN_SRC emacs-lisp
(use-package org-keys
  :ensure nil

  :after org

  :config
  (wal/replace-in-alist
   'org-speed-commands
   '(("a" . org-archive-subtree)
     ("j" . consult-org-heading)))

  :custom
  (org-use-speed-commands t)
  (org-return-follows-link t))
#+END_SRC

*** org-bullets
:PROPERTIES:
:UNNUMBERED: t
:END:

Prettier headlines.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :wal-ways nil

  :hook (org-mode . org-bullets-mode)

  :custom
  (org-bullets-bullet-list '("◆" "◈" "►" "▻" "▸" "▹" "•")))
#+END_SRC

*** org-modern
:PROPERTIES:
:UNNUMBERED: t
:END:

Modern look.

#+begin_src emacs-lisp
(use-package org-modern
  :wal-ways nil

  :ensure nil

  :hook (org-mode . org-modern-mode)

  :custom
  ;; Provided by `org-bullets'.
  (org-modern-star nil)
  (org-modern-hide-stars nil)

  (org-modern-variable-pitch nil)
  (org-modern-label-border 0.1))
#+end_src

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-org)

;;; wal-org.el ends here
#+END_SRC

* Dired
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-dired.el" wal/emacs-config-package-path)
:END:

Run =dired= with =C-x d=.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-dired.el --- Dired. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide Dired packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function dired-read-dir-and-switches "ext:dired.el")
(declare-function consult--buffer-query "ext:consult.el")
(declare-function consult--buffer-state "ext:consult.el")
(declare-function wal/insert-after "wal-func.el")

(defvar wal/lieutenant-key)
#+END_SRC

** Packages

*** dired
:PROPERTIES:
:UNNUMBERED: t
:END:

The mother of all buffers. You don't need no tree views.

#+BEGIN_SRC emacs-lisp
(defun wal/dired-from-home (dirname &optional switches)
  "Find DIRNAME local to HOME directory.
Uses the same optional SWITCHES."
  (interactive
    (let ((default-directory (expand-file-name "~/")))

      (dired-read-dir-and-switches "")))
  (pop-to-buffer-same-window (dired-noselect dirname switches)))

(defun wal/image-dired ()
  "Run `image-dired' in the `default-directory'."
  (interactive)
  (image-dired (expand-file-name default-directory)))

(defun wal/consult-dired-buffer--query ()
  "Get Dired buffer names."
  (consult--buffer-query
   :sort 'visibility
   :as #'buffer-name
   :predicate
   '(lambda (buf)
      (and (with-current-buffer buf
             (derived-mode-p 'dired-mode))
           (if (bound-and-true-p persp-mode)
               (persp-is-current-buffer buf)
             t)))))

(use-package dired
  :ensure nil

  :init
  (wal/hook dired-mode
    "Hook into `dired-mode'."
    :lieutenant t)

  :config
  ;; We aren't scared of finding alternate files.
  (put 'dired-find-alternate-file 'disabled nil)

  (transient-define-prefix wal/dired-mode-dispatch ()
    "Access Dired commands."
    [["Utility"
      ("q" "query replace" dired-do-query-replace-regexp)
      ("t" "create empty file" dired-create-empty-file)]
     ["Other"
      ("v" "show images" wal/image-dired)]])

  (with-eval-after-load 'consult
    (defvar wal/consult--source-dired-buffer
      (list :name "Dired Buffer"
            :narrow ?d
            :category 'buffer
            :state #'consult--buffer-state
            :history 'buffer-name-history
            :face 'font-lock-keyword-face
            :items #'wal/consult-dired-buffer--query))

    (wal/insert-after
     'consult-buffer-sources
     'consult--source-buffer
     wal/consult--source-dired-buffer))

  :custom
  (dired-listing-switches "-lah --group-directories-first")
  (dired-auto-revert-buffer t)
  (dired-kill-when-opening-new-dired-buffer t) ; New in Emacs 28.

  :bind
  (:map ctl-x-map
   ("j" . dired-jump)
   :map ctl-x-x-map
   ("d" . wal/dired-from-home)
   ("j" . dired-jump-other-window)
   :map dired-mode-map
   ("." . dired-up-directory) ; Overrides `dired-clean-directory'.
   ("," . dired-display-file)))
#+END_SRC

*** dired-filter
:PROPERTIES:
:UNNUMBERED: t
:END:

Hit =/= to filter in dired buffers.

#+BEGIN_SRC emacs-lisp
(use-package dired-filter
  :defer 1
  :after dired

  :delight " drf")
#+END_SRC

*** diredfl
:PROPERTIES:
:UNNUMBERED: t
:END:

Highlighting in dired buffers.

#+BEGIN_SRC emacs-lisp
(use-package diredfl
  :wal-ways nil

  :defer 1
  :after dired

  :config
  (diredfl-global-mode))
#+END_SRC

*** wdired
:PROPERTIES:
:UNNUMBERED: t
:END:

Did you know you can edit =dired= buffers using =C-x C-q=?

#+BEGIN_SRC emacs-lisp
(use-package wdired
  :ensure nil

  :custom
  (wdired-allow-to-change-permissions t)

  :bind
  (:map wdired-mode-map
   ("C-c C-k" . wdired-abort-changes)))
#+END_SRC

*** all-the-icons-dired
:PROPERTIES:
:UNNUMBERED: t
:END:

Show file icons.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :wal-ways nil

  :after all-the-icons

  :hook (dired-mode . all-the-icons-dired-mode)

  :custom
  (all-the-icons-dired-monochrome nil)

  :diminish)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-dired)

;;; wal-dired.el ends here
#+END_SRC

* Terminal
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-terminal.el" wal/emacs-config-package-path)
:END:

#+BEGIN_QUOTE
I am convinced that we are in a terminal process.
— E. P. Thompson
#+END_QUOTE

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-terminal.el --- Terminal. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide terminal packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function project-buffers "ext:project.el")
(declare-function projectile-project-p "ext:projectile.el")
(declare-function projectile-project-buffers "ext:projectile.el")
(declare-function vterm-mode "ext:vterm.el")
(declare-function vterm-send-return "ext:vterm.el")
(declare-function vterm-send-string "ext:vterm.el")
(declare-function wal/univ-p "wal-func.el")
(declare-function wdb/side "wal-func.el")

(defvar eshell-highlight-prompt)
(defvar eshell-prompt-function)
(defvar wal/use-projectile)
#+END_SRC

** Packages

*** with-editor
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package with-editor
  :custom
  (with-editor-mode-lighter " w/e"))
#+END_SRC

*** vterm
:PROPERTIES:
:UNNUMBERED: t
:END:

=vterm= is better[fn:15] than included shells.

Some common shell commands require an additional =C-c=:

+ =C-c C-c= to send =C-c=.
+ =C-c C-g= to send =C-g=.
+ =C-c C-u= to send =C-u=.
+ =C-c C-t= to enter/exit =copy-mode=.

#+BEGIN_SRC emacs-lisp
(defconst wal/vterm-prefix "VTerm")

(defun wal/vterm-run (cmd &optional action)
  "Run CMD in `vterm' terminal and switch to it.

Optionally, a buffer display action ACTION can be passed of the
form (FUNCTIONS . ALIST). See `display-buffer' for more
information."
  (interactive "sEnter command: ")
  (unless (executable-find (car (split-string-shell-command cmd)))
    (user-error (format "Unknown command '%s'" cmd)))

  (let* ((buffer (seq-find
                  (lambda (it)
                    (string-match cmd (buffer-name it)))
                  (buffer-list))))

    (if buffer
        (display-buffer buffer action)
      (with-current-buffer (get-buffer-create (format "*vterm-run-%s*" cmd))
        (vterm-mode)
        (vterm-send-string cmd)
        (vterm-send-return)
        (display-buffer (current-buffer) action)))))

(defun wal/vterm (&optional force-new)
  "Get a `vterm' buffer.

If called from a project buffer, this only creates a `vterm'
buffer if one doesn't exist yet (unless called with
FORCE-NEW/`universal-argument')."
  (interactive "P")
  (if-let* ((cont (and (not force-new)
                       (if wal/use-projectile
                           (projectile-project-p)
                         (project-current))))
            (buffers (if wal/use-projectile
                         (projectile-project-buffers)
                       (project-buffers (project-current))))
            (project-vterm
             (cl-find-if
              #'(lambda (it)
                  (and (provided-mode-derived-p
                        (buffer-local-value 'major-mode it)
                        'vterm-mode)
                       (string-match-p
                        wal/vterm-prefix
                        (buffer-name it))))
              buffers)))
      (switch-to-buffer project-vterm)
    (vterm)))

(use-package vterm
  :wal-ways nil

  :hook
  (vterm-mode . with-editor-export-git-editor)

  :init
  (wal/hook vterm-mode ()
    "Hook into `vterm-mode'. Ya.

  This sets the query on exit flag to nil for the vterm process."
    (when-let* ((buf (current-buffer))
                (proc (get-buffer-process buf)))

      (set-process-query-on-exit-flag proc nil)))

  :custom
  (vterm-buffer-name-string (concat wal/vterm-prefix ": %s"))
  (vterm-max-scrollback 10000)

  :bind
  ("C-c t" . wal/vterm)

  :delight
  (vterm-copy-mode " vcp"))
#+END_SRC

**** =fish= configuration
:PROPERTIES:
:UNNUMBERED: t
:END:

Add this function to your =fish= configuration to title your =vterm=
buffers.

#+BEGIN_SRC fish :tangle no
function fish_title
  if set -q argv[1] && test argv[1] != "fish"
    echo $argv[1]":"
  end
  echo (pwd)"@"(hostname)
end
#+END_SRC

** Eshell

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack eshell
  "Make eshell feel like a feature-complete shell."
  :packages (esh-autosuggest
             eshell-prompt-extras
             eshell-syntax-highlighting))
#+END_SRC

*** eshell
:PROPERTIES:
:UNNUMBERED: t
:END:

Set up =eshell=. I like the idea of it but I don't really use it.

#+BEGIN_SRC emacs-lisp
(defun wal/instead-truncate-buffer (&rest _r)
  "Advise to truncate buffer."
  (defvar eshell-buffer-maximum-lines)
  (let ((eshell-buffer-maximum-lines 0))

    (when (fboundp 'eshell-truncate-buffer)
      (eshell-truncate-buffer))))

(use-package eshell
  :ensure nil

  :hook
  ((eshell-mode . with-editor-export-editor)
   (eshell-mode . with-editor-export-git-editor))

  :config
  (advice-add
   'eshell/clear :override
   #'wal/instead-truncate-buffer)

  :general
  (wal/general-sink "e" '(eshell :wk "eshell")))
#+END_SRC

*** esh-autosuggest
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package esh-autosuggest
  :wal-ways nil

  :ensure nil

  :hook (eshell-mode . esh-autosuggest-mode))
#+END_SRC

*** eshell-prompt-extras
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package eshell-prompt-extras
  :wal-ways nil

  :ensure nil

  :demand
  :after eshell

  :config
  (setq eshell-highlight-prompt nil
        eshell-prompt-function 'epe-theme-lambda))
#+END_SRC

*** eshell-syntax-highlighting
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package eshell-syntax-highlighting
  :wal-ways nil

  :ensure nil

  :hook (eshell-mode . eshell-syntax-highlighting-mode))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-terminal)

;;; wal-terminal.el ends here
#+END_SRC

* Version Control
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-vc.el" wal/emacs-config-package-path)
:END:

I'm becoming an old git.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-vc.el --- Version control. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide version control packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wal/major "wal-key-bindings.el")
(declare-function wal/message-in-a-bottle "wal-lang.el")
#+END_SRC

** Magit

Forget remembering =git= commands, use =transient=.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack magit
  "Support pull requests and code reviews."
  :packages (forge code-review))
#+END_SRC

*** magit
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands (wal/magit-dispatch)

  :config
  (transient-define-prefix wal/magit-dispatch ()
    "Call `magit' commands in a `magit'-y way."
    [["Core"
      ("m" "status" magit-status)
      ("q" "status (quick)" magit-status-quick)
      ("b" "blame" magit-blame)]
     ["Files"
      ("f" "find" magit-find-file)
      ("o" "find other window" magit-find-file-other-window)]
     ["Diff"
      ("d" "file" magit-diff-buffer-file)
      ("r" "range" magit-diff-range)]
     ["Other"
      ("x" "run" magit-run)
      ("c" "clone" magit-clone)]])

  :wal-bind
  ("m" . wal/magit-dispatch)

  :custom
  (magit-blame-mode-lighter " mbl")
  (magit-bury-buffer-function 'magit-restore-window-configuration))
#+END_SRC

*** forge
:PROPERTIES:
:UNNUMBERED: t
:END:

Deal with pull/merge requests.

#+BEGIN_SRC emacs-lisp
(use-package forge
  :wal-ways nil

  :ensure nil

  :demand
  :after magit)
#+END_SRC

*** code-review
:PROPERTIES:
:UNNUMBERED: t
:END:

Review pull/merge requests.

#+BEGIN_SRC emacs-lisp
(use-package code-review
  :wal-ways nil

  :ensure nil

  :demand
  :after forge)
#+END_SRC

** Other

*** git-timemachine
:PROPERTIES:
:UNNUMBERED: t
:END:

If you want to go back in time and point fingers at the progenitors of
doom.

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :wal-ways nil

  :config
  (transient-append-suffix 'wal/magit-dispatch #'magit-clone
    '("t" "time machine" git-timemachine-toggle))

  :defer 2
  :after magit

  :delight " gtm")
#+END_SRC

*** git-modes
:PROPERTIES:
:UNNUMBERED: t
:END:

Syntax highlighting.

#+BEGIN_SRC emacs-lisp
(use-package git-modes
  :mode (("/\\.npmignore\\'" . gitignore-mode)
         (".projectile" . gitignore-mode)
         ("/\\.dockerignore" . gitignore-mode))

  :init
  (wal/hook gitignore-mode
    "Hook into `gitignore-mode'."
    :messages '("I don't think I know you")))
#+END_SRC

*** smerge-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

When resolving conflicts, using =ours= and =theirs= should be easy.

#+BEGIN_SRC emacs-lisp
(use-package smerge-mode
  :ensure nil

  :config
  (defhydra wal/smerge (:hint nil :foreign-keys warn)
    "
%s(wal/ascii-whale-hydra-offset 12)^_p_^
%s`wal/ascii-whale Resolve: _u_   _l_.
%s(wal/ascii-whale-hydra-offset 12)^_n_^
"
    ("p" smerge-prev)
    ("n" smerge-next)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all "keep all")
    ("q" nil "quit"))

  (with-eval-after-load 'which-key
    (which-key-add-key-based-replacements "C-c g" "smerge"))

  :bind-keymap
  (("C-c g" . smerge-basic-map))

  :general
  (wal/captain :keymaps 'smerge-mode-map
    "g" '(wal/smerge/body :wk "smerge"))

  :delight " smg")
#+END_SRC

*** ediff
:PROPERTIES:
:UNNUMBERED: t
:END:

Use a single frame and split horizontally when diffing.

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :ensure nil

  :custom
  (ediff-window-setup-function #'ediff-setup-windows-plain) ; Single frame.
  (ediff-split-window-function #'split-window-horizontally))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-vc)

;;; wal-vc.el ends here
#+END_SRC

* Languages
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-lang.el" wal/emacs-config-package-path)
:END:

Let's greet the world.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-lang.el --- Languages. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide Emacs settings/configurations.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function add-node-modules-path "ext:add-node-modules-path.el")
(declare-function poetry-get-virtualenv "ext:poetry.el")
(declare-function poetry-venv-exist-p "ext:poetry.el")
(declare-function prettier--quit-all-processes "ext:prettier.el")
(declare-function projectile-project-root "ext:projectile.el")
(declare-function wal/biased-random "wal-func.el")
(declare-function wal/disable-tabs "wal-func.el")
(declare-function wdb/side "wal-func.el")
(declare-function wal/install-packages "wal-func.el")
(declare-function wal/lsp "wal-lsp.el")
(declare-function wal/captain "wal-key-bindings.el")
(declare-function wal/maybe-enable-tabs "wal-func.el")
(declare-function wal/maybe-intern "wal-func.el")
(declare-function wal/message-in-a-bottle "wal-func.el")

(defvar js-mode-map)
(defvar prettier-processes)
(defvar wal/ascii-whale)
(defvar wal/lieutenant-key)
(defvar wal/use-projectile)

(defgroup wal-lang nil
  "Change language-specific settings."
  :group 'wal
  :tag "Langauge")

(defcustom wal/force-jsx nil
  "Whether `js-jsx-syntax' should always be set to t."
  :group 'wal-lang
  :type 'boolean)
#+END_SRC

** Elixir

Bitches brew.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack elixir
  "For Elixir developers."
  :packages (elixir-mode))
#+END_SRC

*** elixir-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package elixir-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook elixir-mode
    "Hook into `elixir-mode'."
    :lsp t
    :messages '("Mixin' potions" "A hex on you")))
#+END_SRC

** C/C++

I want to be ready for =jai=.

*** c++-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package cc-mode
  :ensure nil

  ;; I don't use C, no need to (often incorrectly) guess.
  :mode ("\\.h\\'" . c++-mode)

  :init
  (wal/hook c++-mode
    "Hook into `c++-mode'."
    :lsp t
    :lieutenant t
    :messages '("Make tidy! Make clean!" "Serenity now!"))

  :config
  ;; Eliminate conflicts with `delight'.
  (advice-add 'c-update-modeline :override #'ignore)

  (transient-define-prefix wal/c++-mode-dispatch ()
    "Access `c++-mode' commands."
    [["Style"
      ("s s" "set" c-set-style)
      ("s g" "guess" c-guess-install)]]))
#+END_SRC

** Rust

Consider the lobster.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack rust
  "For Rust developers."
  :packages (rust-mode cargo))
#+END_SRC

*** rust-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Follow [[https://rust-analyzer.github.io/manual.html#rust-analyzer-language-server-binary][these instructions]] to download the =rust-analyzer= binary.

#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :if (executable-find "cargo")
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook rust-mode
    "Hook into `rust-mode'."
    :lsp t
    :lieutenant t
    :messages '("Consider the lobster"))

  :config
  (transient-define-prefix wal/rust-mode-dispatch ()
    "Access `rust-mode' commands."
    [["Commands"
      ("c" "compile" rust-compile)
      ("r" "run" rust-run)]
     ["Test"
      ("t a" "test all" rust-test)
      ("t c" "current" cargo-process-current-test)
      ("t f" "file" cargo-process-current-file-tests)]]))
#+END_SRC

*** cargo
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package cargo
  :wal-ways nil

  :ensure nil

  :demand
  :after rust-mode)
#+END_SRC

** Python

Hide those details from me.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack python
  "Virtual environment, isort, poetry and notebook support."
  :packages (pet python-isort python-pytest python-black)
  :extras (lsp-pyright ein poetry))
#+END_SRC

*** python
:PROPERTIES:
:UNNUMBERED: t
:END:

Use snake when you can't =make=.

#+BEGIN_SRC emacs-lisp
(defun wal/in-python-project-p (&optional marker-file)
  "Check if we're currently in a Python project.

Unless another MARKER-FILE is provided, this will use the usual
TOML."
  (when-let* ((marker (or marker-file "pyproject.toml"))
              (current default-directory)
              (project-directory (locate-dominating-file current marker)))

    t))

(use-package python
  :ensure nil

  :init
  (wal/hook python-mode
    "Hook into `python-mode'."
    :lieutenant t
    :lsp t
    :lsp-ignores
    '("[/\\\\]\\.pytype\\'"
      "[/\\\\]__pycache__\\'"
      "[/\\\\]\\.pytest_cache\\'")

    :messages '("Watch out for snakes!" "Vegetation, aggravation")

    (setq-local comment-inline-offset 2))

  :config
  ;; Load default `dap-mode' templates.
  (with-eval-after-load 'dap-mode
    (require 'dap-python))

  ;; Show inferior shell at the bottom.
  (wdb/side 'inferior-python-mode)

  (transient-define-prefix wal/python-mode-dispatch ()
    "Access `python-mode' commands."
    [["Inferior shell"
      ("i r" "send region" python-shell-send-region)
      ("i b" "send buffer" python-shell-send-buffer)
      ("i f" "send file" python-shell-send-file)]
     ["Commands"
      ("r" "run shell" run-python)]])

  :custom
  (python-indent-guess-indent-offset nil))
#+END_SRC

*** lsp-pyright
:PROPERTIES:
:UNNUMBERED: t
:END:

Did Microsoft do the right thing?

#+BEGIN_SRC emacs-lisp
(defun wal/lsp-pyright-install-stubs ()
  "Install the pyright stubs."
  (interactive)

  (unless (wal/in-python-project-p)
    (user-error "You're not in a Python project!"))

  (when-let* ((dir (projectile-project-root))
              (stub-dir (expand-file-name "typings" dir)))

    (if (file-directory-p stub-dir)
        (user-error "Stubs directory already exists!")
      (make-directory stub-dir))

    (let ((cmd (concat "git clone https://github.com/microsoft/python-type-stubs "
                       stub-dir))
          (buffer (get-buffer-create "*Pyright Stubs*")))

      (display-buffer-in-side-window buffer '((side . bottom)))
      (async-shell-command cmd buffer))))

(use-package lsp-pyright
  :wal-ways nil

  :ensure nil

  :demand
  :after python)
#+END_SRC

*** python-isort
:PROPERTIES:
:UNNUMBERED: t
:END:

Sort with =isort=.

#+begin_src emacs-lisp
(use-package python-isort
  :ensure nil

  :defer 1
  :after python

  :config
  (transient-append-suffix 'wal/python-mode-dispatch '(0 1 -1)
    '("s" "isort" python-isort-buffer))

  :wal-ways nil)
#+end_src

*** python-pytest
:PROPERTIES:
:UNNUMBERED: t
:END:

Test with =pytest=.

#+BEGIN_SRC emacs-lisp
(use-package python-pytest
  :wal-ways nil

  :ensure nil

  :defer 2
  :after python

  :config
  (wdb/pop-up python-pytest-buffer-name)

  (transient-append-suffix 'wal/python-mode-dispatch '(0 1 -1)
    '("t" "test" python-pytest-dispatch))

  :bind
  (:map python-pytest-mode-map
   ("g" . python-pytest-repeat)
   ("q" . quit-window)))
#+END_SRC

*** python-black
:PROPERTIES:
:UNNUMBERED: t
:END:

Blacken buffers.

#+BEGIN_SRC emacs-lisp
(use-package python-black
  :wal-ways nil

  :defer 1
  :after python

  :config
  (transient-append-suffix 'wal/python-mode-dispatch '(0 1 -1)
    '("b" "black" python-black-buffer))

  :ensure nil)
#+END_SRC

*** ein
:PROPERTIES:
:UNNUMBERED: t
:END:

Work with Jupyter notebooks.

#+BEGIN_SRC emacs-lisp
(use-package ein
  :wal-ways nil

  :defer 3
  :after python

  :config
  (transient-append-suffix 'wal/python-mode-dispatch '(0 1 -1)
    '("e" "ein" ein:run))

  :ensure nil)
#+END_SRC

*** Virtual Envs

It takes more than one environment to make sense of Python code.

**** pet
:PROPERTIES:
:UNNUMBERED: t
:END:

Takes care[fn:16] of all your virtual environment needs.

#+BEGIN_SRC emacs-lisp
(use-package pet
  :if (and (executable-find "dasel")
           (executable-find "sqlite3"))
  :wal-ways nil

  :hook (python-mode . pet-mode)

  :ensure nil

  :delight " pet")
#+END_SRC

**** poetry
:PROPERTIES:
:UNNUMBERED: t
:END:

=poetry= is like =npm= for Python, it's why it rhymes.

#+BEGIN_SRC emacs-lisp
(use-package poetry
  :wal-ways nil

  :after python

  :config
  (transient-append-suffix 'wal/python-mode-dispatch '(0 1 -1)
    '("p" "poetry" poetry))

  :ensure nil)
#+END_SRC

**** pyvenv

#+BEGIN_SRC emacs-lisp
(use-package pyvenv
  :wal-ways nil

  :after python

  :config
  (transient-append-suffix 'wal/python-mode-dispatch '(0 1 -1)
    '("v" "activate venv" pyvenv-activate))

  :ensure nil)
#+END_SRC


** Lisp

The philosopher's choice.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack lisp
  "For (common-) Lisp developers using sbcl."
  :packages (highlight-quoted slime)
  :extras (lispy))

(wal/define-expansion-pack clojure
  "For Clojure developers using cider with lein."
  :packages (clojure-mode cider))
#+END_SRC

*** lispy
:PROPERTIES:
:UNNUMBERED: t
:END:

Deal with the parens[fn:17].

#+BEGIN_SRC emacs-lisp
(defvar-local wal/lispy-was-disabled-by-mc nil)

(defun wal/lispy-disable-before-mc ()
  "Disable `lispy-mode' for `multiple-cursors-mode'."
  (when (bound-and-true-p lispy-mode)
    (setq-local wal/lispy-was-disabled-by-mc t)
    (lispy-mode -1)))

(defun wal/lispy-reenable-after-mc ()
  "Re-enable `lispy-mode' if it was disabled by `mutliple-cursors-mode'."
  (when wal/lispy-was-disabled-by-mc
    (setq wal/lispy-was-disabled-by-mc nil)
    (lispy-mode 1)))

(use-package lispy
  :wal-ways nil

  :ensure nil

  :defer 1
  :after lisp-mode

  :hook
  ((multiple-cursors-mode-enabled . wal/lispy-disable-before-mc)
   (multiple-cursors-mode-disabled . wal/lispy-reenable-after-mc))

  :custom
  (lispy-compat '(edebug cider magit-blame-mode))
  (lispy-comment-use-single-semicolon t)
  (lispy-completion-method 'default)
  (lispy-imenu-function 'consult-imenu)
  (lispy-visit-method (if wal/use-projectile
                          'projectile
                        'ffip))

  :bind
  (:map lispy-mode-map
   ("M-o" . nil))

  :delight " '-y")
#+END_SRC

*** elisp-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package elisp-mode
  :ensure nil

  :init
  (wal/hook emacs-lisp-mode
    "Hook into `emacs-lisp-mode'."
    :lieutenant t
    :messages '("So it's just a bunch of lists?" "List your lambdas")
    (prettify-symbols-mode)
    (flycheck-mode 1))

  :config
  (transient-define-prefix wal/emacs-lisp-mode-dispatch ()
    "Access `elisp' commands."
    [["Utility"
      ("p" "check parens" check-parens)
      ("d" "edebug function" edebug-defun)
      ("h" "helpful" helpful-at-point)
      ("m" "expand macro" emacs-lisp-macroexpand)]])

  (with-eval-after-load 'lispy
    (transient-append-suffix 'wal/emacs-lisp-mode-dispatch '(0 0 -1)
      '("l" "lispy" lispy-mode))))
#+END_SRC

*** lisp-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package lisp-mode
  :ensure nil

  :init
  (wal/hook common-lisp-mode
    "hook into `common-lisp-mode'."
    :lieutenant t)

  :config
  (with-eval-after-load 'slime
    (transient-define-prefix wal/common-lisp-mode-dispatch ()
      "Access `slime' actions."
      [["Slime"
        ("s" "slime" slime-mode)
        ("r" "open REPL" slime)]])))
#+END_SRC

*** clojure-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Get some closure.

#+begin_src emacs-lisp
(use-package clojure-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook clojure-mode
    "Hook into `clojure-mode'."
    :lsp t
    :lieutenant t
    :messages '("Cider brew"))

  :config
  (with-eval-after-load 'cider
    (transient-define-prefix wal/clojure-mode-dispatch ()
      "Access `clojure-mode' commands."
      [["Cider"
        ("r" "repl" cider-jack-in)
        ("n" "set namespace" cider-repl-set-ns)]])))
#+end_src

*** cider
:PROPERTIES:
:UNNUMBERED: t
:END:

Can't have closure without REPL.

#+begin_src emacs-lisp
(use-package cider
  :wal-ways nil

  :ensure nil

  :demand
  :after clojure-mode

  :config
  (wdb/side 'cider-repl-mode)

  :custom
  (cider-jack-in-default 'lein))
#+end_src

*** highlight-quoted
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package highlight-quoted
  :wal-ways nil

  :ensure nil

  :hook (emacs-lisp-mode . highlight-quoted-mode))
#+END_SRC

*** slime
:PROPERTIES:
:UNNUMBERED: t
:END:

Check out the [[https://lispcookbook.github.io/cl-cookbook/getting-started.html][lisp cookbook]] for =slime=.

#+BEGIN_SRC emacs-lisp
(use-package slime
  :if (executable-find "sbcl")
  :wal-ways nil

  :ensure nil

  :demand
  :after lisp-mode

  :config
  (setq inferior-lisp-program "sbcl")
  (slime-setup '(slime-fancy slime-quicklisp slime-asdf))

  :delight " slm")
#+END_SRC

** JavaScript

Can we have =deno= instead of =node=?

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack javascript
  "For Node.js developers."
  :packages (add-node-modules-path prettier)
  :extras (typescript-mode jest))
#+END_SRC

*** js
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package js
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook js-mode
    "Hook into `js-mode'."
    :messages '("NaN !== NaN" "Null falsy values or undefined")
    :lieutenant t
    :tabs t
    :lsp t
    (when wal/force-jsx
      (setq-local js-jsx-syntax t))
    (when (fboundp 'add-node-modules-path)
      (add-node-modules-path))
    (prettier-mode))

  :config
  ;; Load default `dap-mode' templates.
  (with-eval-after-load 'dap-mode
    (require 'dap-node))

  (transient-define-prefix wal/js-mode-dispatch ()
    "Access JS commands."
    [["Actions"
      ("c" "context" js-syntactic-context)]]))
#+END_SRC

*** typescript-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Please use TypeScript.

#+BEGIN_SRC emacs-lisp
(use-package typescript-mode
  :wal-ways nil

  :ensure nil

  :mode "\\.ts\\(x\\)?\\'"

  :init
  (wal/hook typescript-mode
    "Hook into `typescript-mode'."
    :lsp t
    :tabs t
    :messages '("This is any, that is any, everything is any!")
    (add-node-modules-path)))
#+END_SRC

*** add-node-modules-path
:PROPERTIES:
:UNNUMBERED: t
:END:

Allow accessing a project's =node_modules=.

#+BEGIN_SRC emacs-lisp
(use-package add-node-modules-path
  :wal-ways nil

  :ensure nil)
#+END_SRC

*** prettier
:PROPERTIES:
:UNNUMBERED: t
:END:

Prettify your ugly JavaScript.

#+BEGIN_SRC emacs-lisp
(defvar wal/prettier-timer nil)

(defun wal/prettier-refresh ()
  "Force re-loading configuration and apply."
  (interactive)
  (when wal/prettier-timer
    (user-error "Refresh timer already running"))

  (prettier--quit-all-processes)

  (setq wal/prettier-timer
        (run-with-timer 0.1 0.1
                        (lambda ()
                          (when (zerop (hash-table-count prettier-processes))
                            (cancel-timer wal/prettier-timer)
                            (setq wal/prettier-timer nil)
                            (prettier-prettify)
                            (message "Refresh done"))))))

(use-package prettier
  :wal-ways nil

  :ensure nil

  :defer 1
  :after js

  :config
  (transient-append-suffix 'wal/js-mode-dispatch '(0 0 0)
    '("p" "prettier" prettier-prettify)))
#+END_SRC

*** jest
:PROPERTIES:
:UNNUMBERED: t
:END:

#+begin_src emacs-lisp
(use-package jest
  :wal-ways nil

  :ensure nil

  :defer 2
  :after js

  :config
  (transient-append-suffix 'wal/js-mode-dispatch '(0 0 -1)
    '("j" "jest" jest-popup)))
#+end_src

** Go

Ogling new languages.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack go
  "For Go developers."
  :packages (go-mode))
#+END_SRC

*** go-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Setup for LSP.

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook go-mode
    "Hook into `go-mode'."
    :lsp t
    :messages '("What does Sonic say?" "Put a golang under your tongue")))
#+END_SRC

** Scripting

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack fish
  "For fish shell users."
  :packages (fish-mode))

(wal/define-expansion-pack cli
  "For CLI power users."
  :packages (crontab-mode))
#+END_SRC

*** sh-script
:PROPERTIES:
:UNNUMBERED: t
:END:

Bash your head in!

#+BEGIN_SRC emacs-lisp
(use-package sh-script
  :ensure nil

  :init
  (wal/hook sh-mode
    "Hook into `sh-mode'."
    :messages '("Sh..sh..h.." "Bash your head in"))

  :custom
  (sh-basic-offset 2)
  (sh-indent-after-continuation nil))
#+END_SRC

*** crontab-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Sometimes you have to deal with things at their time.

#+BEGIN_SRC emacs-lisp
(use-package crontab-mode
  :wal-ways nil

  :ensure nil)
#+END_SRC

*** fish-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Support =fish= functions.

#+BEGIN_SRC emacs-lisp
(use-package fish-mode
  :wal-ways nil

  :ensure nil

  :custom
  (fish-indent-offset 2))
#+END_SRC

** Markup

Sometimes things that don't do things need to look nice.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack markdown
  "For MD users."
  :packages (markdown-mode))
#+END_SRC

*** markdown-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(defun wal/markdown-view ()
  "Toggle between different markdown views."
  (interactive)
  (cond
   ((eq major-mode 'markdown-mode)
    (markdown-view-mode)
    (mixed-pitch-mode 1))
   ((eq major-mode 'markdown-view-mode)
    (markdown-mode)
    (mixed-pitch-mode -1))
   (t
    (error "Can't change view outside of markdown modes"))))

(use-package markdown-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook markdown-mode
    "Hook into `markdown-mode'."
    :lieutenant t)

  :config
  (transient-define-prefix wal/markdown-mode-dispatch ()
    "Access `markdown-mode' commands."
    [["View"
      ("v" "toggle view" wal/markdown-view)]])

  :bind
  (:map markdown-mode-map
   ("M-<up>" . markdown-move-list-item-up)
   ("M-<down>" . markdown-move-list-item-down)))
#+END_SRC

** Flutter

Yes, you need to install *Android Studio* for some reason.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack flutter
  "Dart major mode and LSP package."
  :packages (dart-mode lsp-dart))
#+END_SRC

*** dart-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package dart-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook dart-mode
    "Hook into `dart-mode'."
    :lsp t
    :lieutenant t
    :messages '("Bull's eye!")))
#+END_SRC

*** lsp-dart
:PROPERTIES:
:UNNUMBERED: t
:END:

LSP support for Dart.

#+BEGIN_SRC emacs-lisp
(defun wal/find-dart-flutter-sdk-dir ()
  "Find the Dart Flutter SDK directory."
  (when-let* ((flutter-bin (executable-find "flutter"))
              (sdk-dir (string-trim (shell-command-to-string "flutter sdk-path"))))

    sdk-dir))

(defun wal/find-dart-sdk-dir ()
  "Find the Dart SDK directory."
  (when-let* ((flutter-sdk-dir (wal/find-dart-flutter-sdk-dir)))

    (expand-file-name "bin/cache/dart-sdk" flutter-sdk-dir)))

(defun wal/lsp-dart-set-process-query-on-exit-flag ()
  "Set the query-on-exit flag to nil for the Dart language server."
  (defvar lsp-dart-flutter-daemon-buffer-name)
  (when-let (proc (get-buffer-process lsp-dart-flutter-daemon-buffer-name))

    (set-process-query-on-exit-flag proc nil)))

(defun wal/lsp-dart-service-uri ()
  "Get the service URI (needed for devtools)."
  (interactive)
  (condition-case err
      (when (fboundp 'lsp-workspace-get-metadata)
        (let ((uri (lsp-workspace-get-metadata "devtools-vm-service-uri")))

          (kill-new uri)
          (message "Service URI (%s) copied to kill ring" uri)))
    (error
      (message "Couldn't get service URI: %s" err))))

(use-package lsp-dart
  :if (or (executable-find "flutter") (executable-find "dart"))
  :wal-ways nil

  :ensure nil

  :after lsp-mode

  :config
  ;; Kill process without a prompt.
  (add-hook
   'lsp-after-initialize-hook
   #'wal/lsp-dart-set-process-query-on-exit-flag)

  ;; Display at the bottom.
  (wdb/side "\\*Flutter")

  (transient-define-prefix wal/dart-mode-dispatch ()
    "Access flutter commands."
    [["Hot-reloading"
      ("R" "restart" lsp-dart-dap-flutter-hot-restart)
      ("r" "reload" lsp-dart-dap-flutter-hot-reload)]
     ["Test"
      ("t c" "current" lsp-dart-run-test-at-point)
      ("t a" "all" lsp-dart-run-all-tests)]
     ["Devtools"
      ("d" "open" lsp-dart-open-devtools)
      ("u" "get service URI" wal/lsp-dart-service-uri)]])

  :custom
  (lsp-dart-flutter-sdk-dir (wal/find-dart-flutter-sdk-dir))
  (lsp-dart-sdk-dir (wal/find-dart-sdk-dir))
  ;; Run `lsp-dart-dap-setup' once to install debugger.
  (lsp-dart-dap-use-sdk-debugger nil))
#+END_SRC

** Java

It's a =JavaEmacsPackageConfigurationSectionFactory=, mate.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack java
  "Java LSP package."
  :packages (lsp-java))
#+END_SRC

*** java-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
;; For some reason, this is also defined in `cc-mode'.
(use-package cc-mode
  :ensure nil

  :init
  (wal/hook java-mode
    "Hook into `java-mode'."
    :lsp t
    :lsp-ignores '("[/\\\\]\\.gradle\\'")
    :lieutenant t
    :messages '("Mmmh ... maven")))
#+END_SRC

*** lsp-java
:PROPERTIES:
:UNNUMBERED: t
:END:

LSP integration.

#+begin_src emacs-lisp
(defun wal/with-bash-shell (fun &rest args)
  "Run FUN with ARGS in bash shell."
  (let ((shell-file-name "/bin/bash"))
    (apply fun args)))

(defvar wal/lsp-java-before nil)

(defun wal/lsp-java-delete-server-log-window (_session)
  "Delete the window displaying the server logs."
  (when-let ((pattern "server log\\*")
             (windows (window-list))
             (window (seq-find (lambda (it)
                                 (let* ((buf (window-buffer it))
                                        (name (buffer-name buf)))

                                   (string-match pattern name)))
                               windows)))

    (setq wal/lsp-java-before (current-window-configuration))
    (delete-window window)))

(defun wal/lsp-java-restore-windows (_session)
  "Restore the window configuration."
  (when wal/lsp-java-before
    (set-window-configuration wal/lsp-java-before)
    (setq wal/lsp-java-before nil)))

(use-package lsp-java
  :wal-ways nil

  :ensure nil

  :hook ((dap-session-created . wal/lsp-java-delete-server-log-window)
         (dap-terminated . wal/lsp-java-restore-windows))

  :config
  (require 'dap-java)

  ;; Use bash shell for JUnit commands.
  (wal/advise-many
   'wal/with-bash-shell :around
   '(dap-java-debug-test-class
     dap-java-debug-test-method
     dap-java-run-test-class
     dap-java-run-test-method))

  (transient-define-prefix wal/java-mode-dispatch ()
    "Access `java-mode' commands."
    [["Debug"
      ("c" "class" dap-java-debug-test-class)
      ("m" "method" dap-java-debug-test-method)]
     ["Run"
      ("C" "class" dap-java-run-test-class)
      ("M" "method" dap-java-run-test-method)]])

  :custom
  (lsp-java-format-on-type-enabled nil) ; Suggested fix for failing completion.
  (lsp-java-references-code-lens-enabled t)
  (lsp-java-implementations-code-lens-enabled t)
  (lsp-java-signature-help-enabled nil))
#+end_src

** PHP

The elephant in the room.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack php
  "Major mode and web mode for templates."
  :packages (php-mode web-mode))
#+END_SRC

*** php-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package php-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook php-mode
    "Hook into `php-mode'."
    :lsp t
    :messages '("Stampy, no!"))

  :config
  (require 'dap-php) ; Run `dap-php-setup'.
  (wdb/side "\\*Php SOE"))
#+END_SRC

*** web-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :wal-ways nil

  :ensure nil

  :mode ("\\.vue\\'"
         "\\.blade.php\\'"
         "\\.component.html\\'")

  :init
  (wal/hook web-mode
    "Hook into `web-mode'."
    :lsp t
    :tabs t
    :messages '("This is the Internet"))

  :custom
  (web-mode-comment-style 2))
#+END_SRC

** Web

Does anyone actually like web development?

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack web
  "For web developers."
  :packages (yaml-mode jsonian)
  :extras (pug-mode po-mode))
#+END_SRC

*** jsonian
:PROPERTIES:
:UNNUMBERED: t
:END:

The only way to store strings, JSON.

#+BEGIN_SRC emacs-lisp
(use-package jsonian
  :wal-ways nil

  :ensure nil

  :after so-long

  :mode (("\\.arb\\'" . jsonian-mode)
         ("\\.\\([a-zA-Z]\\)+rc\\'" . jsonian-mode))

  :init
  (wal/hook jsonian-mode
    "Hook into `jsonian-mode'."
    :tabs t
    :lieutenant t
    :messages '("JSON ...? JSON?! JSON!!")
    (flycheck-mode 1))

  :config
  ;; Integrate with `flycheck' and `so-long-mode'.
  (jsonian-no-so-long-mode)
  (with-eval-after-load 'flycheck
    (jsonian-enable-flycheck))

  (transient-define-prefix wal/jsonian-mode-dispatch ()
    "Access `jsonian-mode' commands."
    [["Jsonian"
      ("f" "find" jsonian-find)
      ("e" "edit" jsonian-edit-string)]]))
#+END_SRC

*** mhtml-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package mhtml-mode
  :ensure nil

  :init
  (wal/hook mhtml-mode
    "Hook into `mhtml-mode'."
    :lsp t
    :messages '("Hodge-podge mark-up language"))

  :bind
  (:map html-mode-map
   ("M-o" . nil)))
#+END_SRC

*** nxml-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+begin_src emacs-lisp
(use-package nxml-mode
  :ensure nil

  :init
  (wal/hook nxml-mode
    "Hook into `nxml-mode'."
    :lsp t
    :messages '("Extreme mark-up language")
    :prog-like t))
#+end_src

*** yaml-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Sometimes things that do as well.

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :wal-ways nil

  :ensure nil

  :mode "\\.tpl\\'" ; Helm templates.

  :init
  (wal/hook yaml-mode
    "Hook into command `yaml-mode'."
    :messages '("JSON?! ... Ah, thank God it's you, YAML!")
    :prog-like t
    (flycheck-mode 1)))
#+END_SRC

*** css-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

We want quicker suggestions when in CSS modes.

#+BEGIN_SRC emacs-lisp
(use-package css-mode
  :ensure nil

  :init
  (wal/hook css-mode
    "Hook into `css-mode'."
    :tabs t
    :lsp t
    :messages '("Centering? It's simple. Here's 15 ways to do it.")
    (add-node-modules-path)
    (when (executable-find "stylelint")
      (add-hook
       'lsp-after-open-hook
       (lambda ()
         (if (equal major-mode 'scss-mode)
             (setq-local flycheck-checker 'wal/scss-stylelint)
           (setq-local flycheck-checker 'css-stylelint)))
       nil t))))
#+END_SRC

*** pug-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Support for =pug= templates.

#+BEGIN_SRC emacs-lisp
(use-package pug-mode
  :wal-ways nil

  :ensure nil)
#+END_SRC

*** po-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Get text.

#+BEGIN_SRC emacs-lisp
(use-package po-mode
  :wal-ways nil

  :ensure nil)
#+END_SRC

*** graphql
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package graphql
  :wal-ways nil

  :ensure nil)
#+END_SRC

** Games

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack games
  "For game developers."
  :packages (gdscript-mode))
#+END_SRC

*** gdscript-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

The engine you've been waiting for.

#+BEGIN_SRC emacs-lisp
;; Workaround from https://github.com/godotengine/emacs-gdscript-mode#known-issues
(defun wal/with-json-data-ignored-for-gdscript (fun &rest args)
  "Advise FUN, passing ARGS.

This will ignore the error message resulting from Godot not
replying to the `JSONRPC' request."
  (if (string-equal major-mode "gdscript-mode")
      (let ((json-data (nth 0 args)))

        (unless (and (string= (gethash "jsonrpc" json-data "") "2.0")
                     (not (gethash "id" json-data nil))
                     (not (gethash "method" json-data nil)))
          (apply fun args)))
    (apply fun args)))

(use-package gdscript-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook gdscript-mode
    "Hook into `gdscript-mode'."
    :lsp t
    :tabs always
    :messages '("I wish you were Estra-gone"))

  ;; Recognize Godot projects.
  (when wal/use-projectile
    (eval-after-load 'projectile
      '(projectile-register-project-type
        'godot
        '("project.godot")
        :project-file "project.godot")))

  :config
  (advice-add 'lsp--get-message-type :around
   #'wal/with-json-data-ignored-for-gdscript))
#+END_SRC

** Jakt

On the hunt for yet another language.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack jakt
  "Go on a hunt with Jakt."
  :recipes ((jakt-mode
             :fetcher url
             :url "https://raw.githubusercontent.com/Walheimat/jakt/main/editors/emacs/jakt-mode.el")))
#+END_SRC


*** jakt-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

This mode is currently included in the main repo.

#+BEGIN_SRC emacs-lisp
(use-package jakt-mode
  :wal-ways nil

  :ensure nil

  :quelpa
  (jakt-mode
   :fetcher url
   :url "https://raw.githubusercontent.com/Walheimat/jakt/main/editors/emacs/jakt-mode.el")

  :mode "\\.jakt\\'")
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-lang)

;;; wal-lang.el ends here
#+END_SRC

* Fixing Things
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-fix.el" wal/emacs-config-package-path)
:END:

Please let me know when I screwed up. I promise I will learn.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-fix.el --- Fixing things. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide fixing packages.

;;; Code:

(eval-when-compile
  (require 'flycheck))
#+END_SRC

** Packages

*** flycheck
:PROPERTIES:
:UNNUMBERED: t
:END:

=flycheck= is for all of our linting/code quality needs.

#+BEGIN_SRC emacs-lisp
(defconst wal/flycheck-file--buffer "*wal-flycheck-file*")

(defun wal/flycheck-file--get-buffer ()
  "Get a buffer for FILENAME to display errors in."
  (unless (get-buffer wal/flycheck-file--buffer)
    (with-current-buffer (get-buffer-create wal/flycheck-file--buffer)
      (local-set-key "k" 'kill-buffer-and-window)
      (local-set-key "q" 'quit-window)
      (setq buffer-read-only t)))
  (get-buffer wal/flycheck-file--buffer))

(defun wal/flycheck-file--write (message &optional skip-newline)
  "Write MESSAGE to the file check buffer.

Optionally don't concat a newline char if SKIP-NEWLINE is t."
  (let ((buffer (wal/flycheck-file--get-buffer)))

    (with-current-buffer buffer
      (setq buffer-read-only nil)
      (goto-char (point-max))
      (insert  message)
      (unless skip-newline (insert "\n"))
      (setq buffer-read-only t))))

(defun wal/flycheck-file--callback (file buffer &optional defer-display kill-buffer)
  "Show errors in FILE in a distinct buffer.

Unless DEFER-DISPLAY is t, show it.

If KILL-BUFFER is t, also kill its BUFFER."
  (lambda (_status &optional errors)
    (let* ((output-buffer (wal/flycheck-file--get-buffer))
           (filename (file-name-nondirectory file)))

      (if (null errors)
          (wal/flycheck-file--write (format "No errors in '%s'." filename))
        (wal/flycheck-file--write (format "Errors in file '%s':" filename))
        (seq-do (lambda (err)
                  (when-let ((err-message (flycheck-error-message err))
                             (line (flycheck-error-line err)))

                    (wal/flycheck-file--write (format "line %d: %s\n" line err-message))))
                errors))

      (unless defer-display (display-buffer output-buffer))

      (when kill-buffer (kill-buffer buffer)))))

(defun wal/flycheck-file (file &optional defer-display kill-buffer)
  "Check FILE with flycheck.

Display it afterwards unless DEFER-DISPLAY is t.

If KILL-BUFFER is t, kill the file's buffer."
  (interactive "fSelect file: ")
  (when (and (fboundp 'flycheck-get-checker-for-buffer)
             (fboundp 'flycheck-syntax-check-new)
             (fboundp 'flycheck-compute-working-directory)
             (fboundp 'flycheck-syntax-check-start))
    (with-current-buffer (find-file-noselect file)
      (let ((checker (flycheck-get-checker-for-buffer)))

        (if checker
            (let* ((check (flycheck-syntax-check-new
                           :buffer (current-buffer)
                           :checker checker
                           :context nil
                           :working-directory (flycheck-compute-working-directory checker)))
                   (callback (wal/flycheck-file--callback file (current-buffer) defer-display kill-buffer)))

              (flycheck-syntax-check-start check callback))
          (user-error "Couldn't determine checker for file"))))))

(use-package flycheck
  :commands (wal/flycheck-file)

  :hook ((sh-set-shell) . flycheck-mode)

  :config
  (transient-define-prefix wal/flycheck-dispatch ()
    "Access `flycheck' commands."
    [["Go to"
      ("n" "next error" flycheck-next-error)
      ("p" "previous error" flycheck-previous-error)]
     ["Show"
      ("l" "list" flycheck-list-errors)]])

  ;; TEMP: https://github.com/flycheck/flycheck/pull/1944
  (flycheck-define-checker wal/scss-stylelint
    "Same as default but not passing `--syntax' flag."
    :command ("stylelint"
              (eval flycheck-stylelint-args)
              (option-flag "--quiet" flycheck-stylelint-quiet)
              (config-file "--config" flycheck-stylelintrc))
    :standard-input t
    :error-parser flycheck-parse-stylelint
    :predicate flycheck-buffer-nonempty-p
    :modes (scss-mode))

  (with-eval-after-load 'which-key
    (which-key-add-key-based-replacements "C-c f" "flycheck"))

  :custom
  (flycheck-mode-line-prefix "fly")

  :bind-keymap
  (("C-c f" . flycheck-command-map))

  :general
  (wal/captain :keymaps 'flycheck-mode-map
    "f" '(wal/flycheck-dispatch :wk "flycheck")))
#+END_SRC

*** flyspell
:PROPERTIES:
:UNNUMBERED: t
:END:

My spelling is bad. Uses American English for =flyspell=.

#+BEGIN_SRC emacs-lisp
(defun wal/flyspell ()
  "(De-)Activate the appropriate `flyspell' mode."
  (interactive)
  (if (derived-mode-p 'prog-mode)
      (flyspell-prog-mode)
    (flyspell-mode)))

(use-package flyspell
  :ensure nil

  :custom
  (flyspell-issue-message-flag nil)
  (flyspell-mode-line-string " fsp")
  (flyspell-default-dictionary "american")

  :bind
  (:map flyspell-mode-map
   ("C-." . ispell-word)) ; Replaces `flyspell-auto-correct-word', which is still available via `C-M-i'.

  :general
  (wal/captain "s" '(wal/flyspell :predicate '(lambda () (not flyspell-mode)) :wk "flyspell"))
  (wal/captain :keymaps 'flyspell-mode-map
    "s" '(:ignore t :wk "flyspell")
    "sb" '(flyspell-buffer :wk "buffer")
    "sr" '(flyspell-region :wk "region")
    "sc" '(ispell-change-dictionary :wk "change dictionary")))
#+END_SRC

*** consult-flycheck
:PROPERTIES:
:UNNUMBERED: t
:END:

Find errors by severity.

#+BEGIN_SRC emacs-lisp
(use-package consult-flycheck
  :defer 2
  :after (consult flycheck)

  :general
  (general-define-key
    :keymaps 'flycheck-command-map
    "u" '(consult-flycheck :wk "consult flycheck")))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-fix)

;;; wal-fix.el ends here
#+END_SRC

* LSP
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-lsp.el" wal/emacs-config-package-path)
:END:

Language servers are awesome. Thanks, Microsoft.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-lsp.el --- LSP. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide LSP packages.

;;; Code:

(eval-when-compile
  (require 'transient)
  (require 'dash)
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function dap--completing-read "ext:dap-mode.el")
(declare-function dap--json-encode "ext:dap-mode.el")
(declare-function dap-register-debug-template "ext:dap-mode.el")
(declare-function lsp-enable-which-key-integration "ext:lsp-mode.el")
(declare-function wal/append "wal-func.el")
(declare-function wal/major "wal-key-bindings.el")
(declare-function wdb/side "wal-func.el")

(defvar dap-debug-template-configurations)
(defvar lsp-completion-provider)
(defvar lsp-file-watch-ignored-directories)

(defgroup wal-lsp nil
  "Change settings for LSP packages."
  :group 'wal
  :tag "LSP")

(defcustom wal/lsp-slow-modes '()
  "Modes that have slow language servers.

For these modes `corfu' settings will not be adjusted to be
smaller."
  :type '(repeat symbol)
  :group 'wal-lsp)
#+END_SRC

** Packages

*** lsp-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

=lsp-mode= is the fancy version. You'll have to install some language
servers yourself[fn:18].

#+BEGIN_SRC emacs-lisp
(defun wal/slow-lsp-p (mode)
  "Check if MODE is considered slow."
  (memq mode wal/lsp-slow-modes))

(defun wal/lsp-corfu-auto ()
  "Get the `corfu-auto' values as a list of (DELAY PREFIX)."
  (if (derived-mode-p 'js-mode) '(0.1 2) '(0.0 0)))

(defun wal/lsp ()
  "Defer LSP setup for the file.

Unless the associated server is considered slow, delays and
minimum prefixes are reduced."
  (unless (wal/slow-lsp-p major-mode)
    (let* ((values (wal/lsp-corfu-auto))
           (delay (car values))
           (prefix (cadr values)))

      (setq-local corfu-auto-delay delay
                  corfu-auto-prefix prefix)))
    (setq-local completion-styles '(orderless partial-completion basic))
    (lsp-deferred))

(defun wal/lsp-completion-with-corfu ()
  "Advise completion to work better with `corfu' and `orderless'."
  (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
        completion-styles))

(defun wal/first-prevent-adding-other-projects (&rest _args)
  "Prevent adding workspace roots from other projects."
  (eval '(setf (lsp-session-server-id->folders (lsp-session)) (ht))))

(use-package lsp-mode
  :wal-ways nil

  :hook (lsp-completion-mode . wal/lsp-completion-with-corfu)

  :config
  ;; Integrate with other packages.
  (require 'avy nil t)
  (lsp-enable-which-key-integration t)

  ;; Additional ignores.
  (wal/append
   'lsp-file-watch-ignored-directories
   '("[/\\\\]build\\'" "[/\\\\]vendor\\'"))

  ;; Don't keep track of multiple projects.
  (advice-add 'lsp :before #'wal/first-prevent-adding-other-projects)

  (transient-define-prefix wal/lsp-dispatch ()
    "Call `lsp-mode' functions."
    [["Format"
      ("f" "buffer" lsp-format-buffer)
      ("F" "region" lsp-format-region)]
     ["Actions"
      ("a" "execute" lsp-execute-code-action)
      ("l" "jump to lens" lsp-avy-lens)
      ("h" "highlight symbol" lsp-document-highlight)]
     ["Refactor"
      ("r" "rename" lsp-rename)
      ("o" "organize imports" lsp-organize-imports)]
     ["Go to"
      ("d" "definition" lsp-find-definition)
      ("e" "errors" lsp-treemacs-errors-list)
      ("H" "hierarchy" lsp-treemacs-call-hierarchy)]
     ["Workspace"
      ("R" "restart" lsp-workspace-restart)
      ("Q" "quit" lsp-workspace-shutdown)]])

  ;; JavaScript.
  (with-eval-after-load 'js-mode
    (transient-append-suffix 'wal/js-mode-dispatch '(0 0 -1)
      '("r" "rename file" lsp-javascript-rename-file)))

  (with-eval-after-load 'which-key
    (which-key-add-key-based-replacements "C-c l" "lsp"))

  :custom
  ;; Simplify visuals.
  (lsp-headerline-breadcrumb-enable nil)
  (lsp-signature-render-documentation nil)
  (lsp-signature-function 'lsp-signature-posframe)
  (lsp-signature-auto-activate '(:on-server-request))

  ;; Play nice with `corfu'.
  (lsp-completion-provider :none)

  (lsp-keep-workspace-alive nil)
  (lsp-keymap-prefix "C-c l")

  ;; Individual severs.
  (lsp-pylsp-plugins-jedi-use-pyenv-environment t)
  (lsp-clients-typescript-log-verbosity "off")
  (lsp-rust-analyzer-cargo-watch-command "clippy")
  (lsp-xml-format-split-attributes t)
  (lsp-xml-format-space-before-empty-close-tag nil)
  (lsp-xml-format-split-attributes-indent-size 1)

  :bind-keymap
  (("C-c l" . lsp-command-map))

  :general
  (wal/captain :keymaps 'lsp-mode-map "l" '(wal/lsp-dispatch :wk "lsp"))

  :delight
  (lsp-mode " lsp")
  (lsp-lens-mode " lns"))
#+END_SRC

*** lsp-ui
:PROPERTIES:
:UNNUMBERED: t
:END:

Don't clutter things up too much.

#+BEGIN_SRC emacs-lisp
(use-package lsp-ui
  :wal-ways nil

  :after lsp-mode

  :custom
  (lsp-ui-doc-show-with-cursor t)
  ;; No sideline stuff.
  (lsp-ui-sideline-enable nil)

  ;; Late and smaller docs.
  (lsp-ui-doc-delay 1.0)
  (lsp-ui-doc-max-height 30)
  (lsp-ui-doc-max-width 100)
  (lsp-ui-doc-text-scale-level -1))
#+END_SRC

*** dap-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Debugging using VSCode's DAP (in =lsp-mode=)

#+BEGIN_SRC emacs-lisp
(use-package dap-mode
  :wal-ways nil

  :after lsp-mode

  :hook (dap-terminated . (lambda (_session) (hydra-disable)))

  :config
  ;; Activate UI and configure.
  (dap-auto-configure-mode)

  (with-no-warnings
    (defhydra wal/dap-hydra (:hint nil :foreign-keys warn)
      "
%s`wal/ascii-whale _d_ebug: _n_ext, _i_n, _o_ut or _c_ontinue.
"
      ("n" dap-next)
      ("i" dap-step-in)
      ("o" dap-step-out)
      ("c" dap-continue)
      ("d" dap-debug :color blue)
      ("b" dap-breakpoint-toggle "toggle breakpoint")
      ("l" dap-go-to-output-buffer "show logs" :color blue)
      ("r" dap-ui-repl "repl" :color blue)
      ("f" dap-hydra "full" :color blue)
      ("x" dap-disconnect "disconnect" :color blue)
      ("q" nil)))

  :custom
  (dap-auto-show-output nil)
  (dap-auto-configure-features '(locals breakpoints))

  (dap-python-executable "python3")
  (dap-python-debugger 'debugpy)

  :general
  (wal/captain :keymaps 'lsp-mode-map "d" '(wal/dap-hydra/body :wk "debug"))

  :delight " dap")
#+END_SRC

*** consult-lsp
:PROPERTIES:
:UNNUMBERED: t
:END:

Jump to symbols with =consult=.

#+begin_src emacs-lisp
(use-package consult-lsp
  :wal-ways nil

  :after (consult lsp-mode))
#+end_src

** Debug Templates

Put these templates in a file in your project root, and evaluate them
there using =C-x C-e=.

#+BEGIN_SRC emacs-lisp
(defun wal/dap-create-launch-json-from-template ()
  "Create and write a VSCode launch configuration using a template."
  (interactive)
  (wal/try dap-mode
    (let* ((args (-> (dap--completing-read "Select template: "
                                           dap-debug-template-configurations
                                           'cl-first nil t)
                     cl-rest
                     copy-tree))

           (serialized (dap--json-encode args))
           (file-args (find-file-read-args "Find file (deleting other windows): "
                                           (confirm-nonexistent-file-or-buffer)))
           (filename (car file-args)))
      (with-temp-buffer
        (insert serialized)
        (json-pretty-print-buffer)
        (write-region (buffer-string) nil filename)))))
#+END_SRC

*** Node.js
:PROPERTIES:
:UNNUMBERED: t
:END:

This for attaching to a remote host (Docker container) using =nodemon=.

For TypeScript compile your =src= with =--sourceMap= or set =sourceMap= to
=true= in your =tsconfig.json=.

#+BEGIN_SRC emacs-lisp :tangle no
(when (require 'dap-mode nil 'noerror)
  (progn
    (let* ((use-source-maps t)          ; Turn off if not needed.
           (build-directory "build")    ; Set to `nil' if this isn't transpiled JavaScript.
           (remote-root "/usr/src/app") ; If this is running remotely.
           (local-root (if build-directory
                           (concat (file-name-directory buffer-file-name) build-directory)
                         (file-name-directory buffer-file-name))))

      (dap-register-debug-template
       "attach::node"
       (list :type "node"
             :request "attach"
             :sourceMaps use-source-maps
             :remoteRoot remote-root
             :localRoot local-root
             :port 9229)))))
#+END_SRC

*** Python
:PROPERTIES:
:UNNUMBERED: t
:END:

Attach to running process.

#+BEGIN_SRC emacs-lisp
(defun wal/dap-register-debugpy-template (name remote-root)
  "Create template for debugpy.

Prompts user for NAME of the template and the REMOTE-ROOT."
  (interactive "sName of the template: \nsRemote root: ")
  (wal/try dap-mode
    (let ((mapping `(:localRoot "${workspaceFolder}" :remoteRoot ,remote-root)))

      (dap-register-debug-template
       name
       (list :type "python"
             :request "attach"
             :connect (list :host "localhost" :port 5678)
             :pathMappings (vector mapping))))))
#+END_SRC

*** Flutter
:PROPERTIES:
:UNNUMBERED: t
:END:

Debugging without sound null safety.

#+BEGIN_SRC emacs-lisp :tangle no
(when (require 'dap-mode nil 'noerror)
  (dap-register-debug-template
   "flutter::unsound"
   (list
    :type "flutter"
    :program "lib/main.dart"
    :args '("--no-sound-null-safety"))))
#+END_SRC

*** Laravel
:PROPERTIES:
:UNNUMBERED: t
:END:

Make sure you expose port =9003=.

#+BEGIN_SRC emacs-lisp :tangle no
(when (require 'dap-mode nil 'noerror)
  (let ((mapping '(:/var/www/html "${workspaceFolder}")))

    (dap-register-debug-template
     "laravel::launch"
     (list
      :type "php"
      :request "launch"
      :port 9003
      :pathMappings mapping))))
#+END_SRC

**** XDebug Config

Put the following into your =php.ini=.

#+BEGIN_SRC conf
[XDebug]
xdebug.start_with_request = yes
xdebug.show_local_vars = on
xdebug.discover_client_host = true
xdebug.client_host = 0.0.0.0
xdebug.client_port = 9003
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-lsp)

;;; wal-lsp.el ends here
#+END_SRC

* DevOps
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-devops.el" wal/emacs-config-package-path)
:END:

Put it into a container and throw it in the garbage that is the
Internet.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-devops.el --- DevOps. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide DevOps packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wdb/side "wal-func.el")
(declare-function wdb/direction "wal-func.el")
(declare-function wal/message-in-a-bottle "wal-func.el")
#+END_SRC

** Docker

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack docker
  "Docker and Kubernetes."
  :packages (docker dockerfile-mode))
#+END_SRC

*** docker
:PROPERTIES:
:UNNUMBERED: t
:END:

What goes =docker-compose= up, goes =docker-compose= down.

#+BEGIN_SRC emacs-lisp
(use-package docker
  :wal-ways nil

  :ensure nil

  :config
  (wdb/side "\\*docker-containers\\*" :side 'top :height 15)
  (wdb/side "^\\* docker container")
  (wdb/side "^\\* docker-compose")

  :custom
  (docker-run-async-with-buffer-function 'docker-run-async-with-buffer-shell)
  (docker-container-default-sort-key '("Names"))
  (docker-image-default-sort-key '("Created" . t))
  (docker-volume-default-sort-key '("Name"))
  (docker-show-status nil)

  :bind
  (("C-c d" . docker)))
#+END_SRC

*** dockerfile-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Make =Dockerfiles= look nice.

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook dockerfile-mode
    "Hook into `dockerfile-mode'."
    :messages '("Have you ever given?")))
#+END_SRC

** Kubernetes

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack kubernetes
  "Kubernetes."
  :packages (kubernetes))
#+END_SRC

*** kubernetes
:PROPERTIES:
:UNNUMBERED: t
:END:

Who doesn't like pods and stuff?

#+BEGIN_SRC emacs-lisp
(use-package kubernetes
  :if (executable-find "kubectl")
  :wal-ways nil

  :ensure nil

  :custom
  (kubernetes-commands-display-buffer-function 'display-buffer)
  (kubernetes-poll-frequency 3600)
  (kubernetes-redraw-frequency 3600)
  (kubernetes-default-overview-view 'deployments)
  (kubernetes-json-mode (if (featurep 'jsonian-mode) 'jsonian-mode 'js-mode))

  :wal-bind
  ("8" . kubernetes-overview))
#+END_SRC

** Jenkins

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack jenkins
  "Kubernetes."
  :packages (jenkinsfile-mode))
#+END_SRC

*** jenkinsfile-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+begin_src emacs-lisp
(use-package jenkinsfile-mode
  :wal-ways nil

  :ensure nil

  :mode "Jenkinsfile")
#+end_src

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-devops)

;;; wal-devops.el ends here
#+END_SRC

* The Internet
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-web.el" wal/emacs-config-package-path)
:END:

I browse, I request.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-web.el --- The Internet. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide web packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wdb/pop-up "wal-func.el")
#+END_SRC

** Requests

*** verb
:PROPERTIES:
:UNNUMBERED: t
:END:

Make requests using Org.

#+BEGIN_SRC emacs-lisp
(defun wal/pick-windows-being-kept (&rest _args)
  "Provide t to `verb-kill-*' functions to keep window."
  (list t))

(use-package verb
  :wal-ways nil

  :after org

  :commands (wal/verb)

  :init
  ;; Make the tag available.
  (add-to-list 'org-tag-alist '("verb" . ?v))

  ;; Make sure windows are being kept.
  (advice-add
   'verb-kill-all-response-buffers :filter-args
   #'wal/pick-windows-being-kept)
  (advice-add
   'verb-kill-response-buffer-and-window :filter-args
   #'wal/pick-windows-being-kept)

  :config
  (transient-define-prefix wal/verb ()
    "Dispatch `verb' commands."
    [["Request"
      ("r" "send" verb-send-request-on-point
       :inapt-if-non-nil verb-response-body-mode)
      ("e" "export" verb-export-request-on-point
       :inapt-if-non-nil verb-response-body-mode)]
     ["Response"
      ("R" "resend" verb-re-send-request
       :inapt-if-nil verb-response-body-mode)
      ("k" "kill all" verb-kill-all-response-buffers)]
     ["Variables"
      ("v" "set" verb-set-var)
      ("V" "show" verb-show-vars)]])

  :bind
  (:map verb-response-body-mode-map
   ("k" . verb-kill-buffer-and-window)
   ("q" . quit-window))

  :general
  (wal/captain :keymaps '(verb-mode-map verb-response-body-mode-map)
    "r" '(wal/verb :wk "verb"))

  :delight
  (verb-mode " vrb")
  (verb-response-body-mode " vRb"))
#+END_SRC

** E-Mails

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack mailing
  "For people reading/writing emails in Emacs."
  :packages (smtpmail))
#+END_SRC

*** mu4e
:PROPERTIES:
:UNNUMBERED: t
:END:

You either need to install =maildir-utils= or build from [[https://github.com/djcb/mu][source]].

#+BEGIN_SRC emacs-lisp
(use-package mu4e
  :if (executable-find "mu")
  :wal-ways nil

  :ensure nil

  :config
  (setq mail-user-agent 'mu4e-user-agent)

  :custom
  (mu4e-confirm-quit nil)
  (mu4e-completing-read-function 'completing-read)
  (mu4e-compose-dont-reply-to-self t)
  (mu4e-get-mail-command "offlineimap") ; This one works nicely.

  :bind
  ("C-c p" . mu4e))
#+END_SRC

*** smtpmail
:PROPERTIES:
:UNNUMBERED: t
:END:

This configuration is from a (kind of) working [[https://www.djcbsoftware.nl/code/mu/mu4e/Gmail-configuration.html][Gmail setup]].

I recommend putting personal data in a =site-start.el= file somewhere in
your =load-path=.

#+BEGIN_SRC emacs-lisp
(use-package smtpmail
  :wal-ways nil

  :ensure nil

  :custom
  (message-send-mail-function 'smtpmail-send-it)
  (message-kill-buffer-on-exit t)
  (starttls-use-gnutls t))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-web)

;;; wal-web.el ends here
#+END_SRC

* Writing
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-writing.el" wal/emacs-config-package-path)
:END:

Sometimes you have to sit down and write something.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-writing.el --- Writing. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide writing packages.

;;; Code:
#+END_SRC

** Packages

*** typo
:PROPERTIES:
:UNNUMBERED: t
:END:

Access complex punctuation. To me this doesn't necessarily make sense
for all =text-mode= modes (like =org-mode=), so instead it needs to be
triggered explicitly.

#+BEGIN_SRC emacs-lisp
(use-package typo
  :wal-ways nil

  :defer 3
  :after text-mode

  :hook (typo-mode . flycheck-mode)

  :delight " typ")
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-writing)

;;; wal-writing.el ends here
#+END_SRC

* Fluff
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-fluff.el" wal/emacs-config-package-path)
:END:

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-fluff.el --- Fluff. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide fluff packages. These are not installed by default.

;;; Code:

(declare-function wal/pad-string "wal-func.el")
#+END_SRC


** Packages

*** display-wttr
:PROPERTIES:
:UNNUMBERED: t
:END:

Provide some knowledge of the outside world.

#+BEGIN_SRC emacs-lisp
(use-package display-wttr
  :wal-ways nil

  :ensure nil

  :defer 3

  :config
  (advice-add
   'display-wttr--clean-string :filter-return
   #'wal/pad-string)

  :custom
  (display-wttr-format "1"))
#+END_SRC

*** tokei
:PROPERTIES:
:UNNUMBERED: t
:END:

Display code statistics.

#+BEGIN_SRC emacs-lisp
(use-package tokei
  :if (executable-find "tokei")
  :wal-ways nil

  :ensure nil)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-fluff)

;;; wal-fluff.el ends here
#+END_SRC

* Config Package
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal.el" wal/emacs-config-package-path)
:END:

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal.el --- Walheimat's literate Emacs configuration. -*- lexical-binding: t -*-

;; Version: 1.7.12
;; Package-Requires: ((emacs "28.1"))

;;; Commentary:
;;
;; Require all sub-packages.

;;; Code:

(declare-function transient-define-prefix "ext:transient.el")
(declare-function posframe-delete "ext:posframe.el")
(declare-function posframe-refresh "ext:posframe.el")
(declare-function posframe-show "ext:posframe.el")
(declare-function wal/async-process "wal-func.el")
(declare-function wal/directory-files "init.el")
(declare-function wal/flycheck-file "wal-fix.el")
(declare-function wal/flycheck-file--get-buffer "wal-fix.el")
(declare-function wal/matches-in-string "wal-func.el")
(declare-function wal/tangle-config "wal-prelude.el")

(defvar wal/emacs-config-default-path)
(defvar wal/emacs-config-package-path)

(defgroup wal nil
  "Walheimat's configuration."
  :group 'convenience
  :prefix "wal/")

(defgroup wal-config nil
  "Customize configuring the packages."
  :group 'wal
  :tag "Configuration")

(defcustom wal/config-show-whale-animation t
  "Whether to show an animated whale while editing the config."
  :type 'boolean
  :group 'wal-config)

(defconst wal/sub-packages '(wal-func
                             wal-external
                             wal-settings
                             wal-key-bindings
                             wal-look
                             wal-fonts
                             ;; The following packages are optional.
                             wal-emacs
                             wal-edit
                             wal-movement
                             wal-find
                             wal-complete
                             wal-workspace
                             wal-windows
                             wal-org
                             wal-dired
                             wal-terminal
                             wal-vc
                             wal-visuals
                             wal-lang
                             wal-fix
                             wal-lsp
                             wal-devops
                             wal-web
                             wal-writing
                             wal-fluff)
  "List of sub-packages that will be loaded.

The order determines the load order as well.")
#+END_SRC

** Lovable Things

*** Whale Animation

Animate a swimming whale in a =posframe=.

#+BEGIN_SRC emacs-lisp
(defvar wal/ascii-whale-key-frames ["(__.- >{"
                                    "(__.' >{"
                                    "(__.- >{"
                                    "(__., >{"])
(defvar wal/ascii-whale-frame-index 0)
(defvar wal/ascii-whale-animation-speed 0.4)

(defvar wal/ascii-whale-buffer "*swimming-whale*")
(defvar wal/ascii-whale-timer nil)
(defvar wal/ascii-whale-parent-buffer nil)

(defun wal/ascii-whale-animate ()
  "Animate the ASCII whale."
  (with-current-buffer (get-buffer-create wal/ascii-whale-buffer)
    ;; Clear.
    (erase-buffer)

    ;; Render current frame.
    (let* ((frame (aref wal/ascii-whale-key-frames wal/ascii-whale-frame-index))
           (colored (propertize frame 'face 'mode-line-highlight)))

      (insert colored)

      ;; Advance to the next frame.
      (setq wal/ascii-whale-frame-index
            (mod
             (1+ wal/ascii-whale-frame-index)
             (length wal/ascii-whale-key-frames))))))

(defun wal/ascii-whale-setup ()
  "Set up the animated whale."
  (when (featurep 'posframe)
    ;; Integrate in current window configuration.
    (setq wal/ascii-whale-parent-buffer (current-buffer))
    (add-hook 'kill-buffer-hook #'wal/ascii-whale-clean-up nil t)
    (add-hook 'window-configuration-change-hook #'wal/ascii-whale-display nil t)

    ;; Queue up timer.
    (unless wal/ascii-whale-timer
      (setq wal/ascii-whale-timer (run-with-timer
                                   0
                                   wal/ascii-whale-animation-speed
                                   #'wal/ascii-whale-animate)))

    ;; Increase the font size.
    (with-current-buffer (get-buffer-create wal/ascii-whale-buffer)
      (defvar wal/fixed-font-height)
      (let ((fheight (* 2 wal/fixed-font-height)))
        (face-remap-add-relative 'default :height fheight)))

    ;; Make sure the first frame is animated before we display.
    (wal/ascii-whale-animate)

    (wal/ascii-whale-display)))

(defun wal/ascii-whale-clean-up ()
  "Clean up the animation."
  ;; Cancel and void the timer.
  (when wal/ascii-whale-timer
    (cancel-timer wal/ascii-whale-timer)
    (setq wal/ascii-whale-timer nil))

  ;; Delete the frame.
  (posframe-delete wal/ascii-whale-buffer)

  ;; Remove animation and re-positioning hooks.
  (remove-hook 'kill-buffer-hook #'wal/ascii-whale-clean-up t)
  (remove-hook 'window-configuration-change-hook #'wal/ascii-whale-display t))

(defun wal/ascii-whale-poshandler (info)
  "Position handler for ASCII whale.

INFO contains positioning information."
  (let* ((window-left (plist-get info :parent-window-left))
         (window-top (plist-get info :parent-window-top))
         (window-width (plist-get info :parent-window-width))
         (posframe-width (plist-get info :posframe-width))

         ;; Offset the frame, taking the pixel-height of a line into
         ;; account.
         (p-window (plist-get info :parent-window))
         (p-line-height (with-selected-window p-window (line-pixel-height)))
         (offset-x p-line-height)
         (offset-y p-line-height))

    (cons (- (+ window-left window-width
                (- 0 posframe-width))
             offset-x)
          (+ window-top offset-y))))

(defun wal/ascii-whale-hidehandler (info)
  "Check INFO whether the parent buffer is invisible."
  (when-let ((parent (cdr (plist-get info :posframe-parent-buffer))))

    (not (get-buffer-window parent t))))

(defun wal/ascii-whale-display ()
  "Display the running animation in a posframe."
  (posframe-show
     wal/ascii-whale-buffer
     :position (point)
     :border-width 6
     :border-color (face-attribute 'mode-line-highlight :background nil t)
     :poshandler 'wal/ascii-whale-poshandler
     :posframe-parent-buffer (or wal/ascii-whale-parent-buffer (current-buffer))
     :hidehandler 'wal/ascii-whale-hidehandler))

(defun wal/ascii-whale-toggle-display ()
  "Toggle the animation."
  (interactive)
  (if wal/ascii-whale-timer
      (wal/ascii-whale-clean-up)
    (wal/ascii-whale-setup)))
#+END_SRC

** Editing the Config

Minor mode for editing this config.

*** Version Info

#+BEGIN_SRC emacs-lisp
(defvar wal/tangle-do-prompt t
  "Whether to prompt user to tangle config.")

(defvar wal/config-mode-map (make-sparse-keymap)
  "Map for `wal/config-mode'.")

(defconst wal/readme-config (expand-file-name "README.org" wal/emacs-config-default-path)
  "The path to Walheimat's config.")

(defun wal/describe-config-version ()
  "Describe the config's version.

This returns the tag and its annotation as propertized strings."
  (interactive)
  (let* ((default-directory wal/emacs-config-default-path)
         (version (propertize
                   (string-trim
                    (shell-command-to-string "git describe --abbrev=0"))
                   'face 'bold))
         (cat (propertize
               (string-trim
                (shell-command-to-string (format "git cat-file tag %s" version)))
               'face 'italic))
         (out (concat version ": " (car (last (string-lines cat))))))

    (cond
     (noninteractive out)
     (t (message out)))))

(defun wal/show-config-diff-range ()
  "Call `magit-diff-range' with the latest tag."
  (interactive)
  (let ((version (shell-command-to-string "git describe --abbrev=0")))

    (magit-diff-range (string-trim version) '("--stat"))))
#+END_SRC

*** Tangling

#+BEGIN_SRC emacs-lisp
(defun wal/tangle-config-prompt ()
  "Prompt the user to tangle the config.
If the answer is no, there will be no additional prompt."
  (interactive)
  (let ((help-form (message "This will update your packages. Restart Emacs afterwards.")))

    (if (and wal/tangle-do-prompt (y-or-n-p "Config changed, want to tangle? "))
        (wal/tangle-config)
      (if wal/tangle-do-prompt
          (progn
            (setq-local wal/tangle-do-prompt nil)
            (message "To tangle, call `wal/tangle-config'"))
        (message "Config changed. To tangle, call `wal/tangle-config'")))))
#+END_SRC

*** Finding

#+BEGIN_SRC emacs-lisp
(defun wal/find-config ()
  "Find Walheimat's config.

This will activate minor mode `wal/config-mode'."
  (interactive)
  (let ((buf (find-file-noselect wal/readme-config)))

    (switch-to-buffer buf)
    (wal/config-mode 1)))

(defun wal/find-init ()
  "Find and switch to the `user-init-file'."
  (interactive)
  (switch-to-buffer (find-file-noselect (file-truename user-init-file))))

(defun wal/customize-group ()
  "Customize `wal' group."
  (interactive)
  (customize-group 'wal t))

(defun wal/dired-config-packages ()
  "Open the packages with Dired."
  (interactive)
  (pop-to-buffer-same-window
    (dired-noselect wal/emacs-config-package-path)))

(defun wal/find-config-changelog ()
  "Find the the changelog of the config."
  (interactive)
  (let* ((root wal/emacs-config-default-path)
         (changelog (expand-file-name "CHANGELOG.md" root)))

    (display-buffer-pop-up-window
     (find-file-noselect changelog)
     '((side . left)))))
#+END_SRC

*** Coverage

#+BEGIN_SRC emacs-lisp
(defun wal/check-coverage--calculate-coverage ()
  "Calculate the full coverage."
  (when-let* ((buf (seq-find (lambda (it) (string-match "-coverage\\*" (buffer-name it))) (buffer-list)))
              (matches (with-current-buffer buf
                         (wal/matches-in-string "\\(?1:[[:digit:]]+\\)%" (buffer-string))))
              (nums (mapcar (lambda (it) (string-to-number it)) matches)))
    (/ (apply '+ nums) (length nums))))

(defun wal/check-coverage ()
  "Check the current coverage for custom functionality."
  (interactive)
  (let* ((command "cask exec ert-runner && cat coverage.txt"))

    (wal/coverage--execute
     command
     (lambda ()
       (let ((average (wal/check-coverage--calculate-coverage)))
         (message "Tests succeed: %s" average)))
     (lambda (str) (message "Tests fail: %s" str)))))

(defun wal/create-json-coverage ()
  "Create a JSON report file."
  (interactive)
  (let* ((command "export COVERAGE_WITH_JSON=true && cask exec ert-runner"))

    (wal/coverage--execute
     command
     (lambda () (message "Coverage created"))
     (lambda (str) (message "Failed to create coverage: %s" str)))))

(defun wal/coverage--execute (command on-success on-failure)
  "Execute coverage command.

Runs COMMAND asynchronously and passes ON-SUCCESS and ON-FAILURE
handlers.

BUFFER-SUFFIX is a string to make sure existing buffers of that
name are deleted beforehand."
  (unless (executable-find "cask")
    (user-error "You need to install `cask' binary"))

  (let* ((dir wal/emacs-config-package-path)
         (full-command (concat "cd " dir " && " command))
         (buffer-name "\\*wal-async\\*"))

    (dolist (buf (buffer-list))
      (when (string-match buffer-name (buffer-name buf))
        (when-let ((window (get-buffer-window buf)))
          (delete-window window))
        (kill-buffer buf)))

    (wal/async-process full-command on-success on-failure t)))
#+END_SRC

*** Checking

#+BEGIN_SRC emacs-lisp
(defun wal/checkdoc-config-packages ()
  "Run `checkdoc-file' on all package files."
  (interactive)
  (defvar projectile-enable-caching)
  (let* ((projectile-enable-caching nil)
         (package-files (wal/directory-files wal/emacs-config-package-path))
         (el-files (seq-filter
                    (lambda (it)
                      (string-equal (file-name-extension it)
                                    "el"))
                    package-files)))

    (dolist (it el-files)
      (checkdoc-file it))))

(defun wal/flycheck-config-packages ()
  "Run `wal/flycheck' on all config package files."
  (interactive)
  (defvar projectile-enable-caching)
  (let ((output-buffer (wal/flycheck-file--get-buffer))
        (projectile-enable-caching nil))

    (with-current-buffer output-buffer
      (setq buffer-read-only nil)
      (erase-buffer)
      (setq buffer-read-only t))

    (display-buffer output-buffer)

    (let* ((package-files (wal/directory-files wal/emacs-config-package-path))
           (el-files (seq-filter
                      (lambda (it)
                        (string-equal (file-name-extension it)
                                      "el"))
                      package-files)))

      (dolist (it el-files)
        ;; Check the file but defer output and kill the buffers.
        (wal/flycheck-file it t t)))))
#+END_SRC

*** Minor Mode

#+BEGIN_SRC emacs-lisp
(defun wal/config-maybe-create-transient ()
  "Create a `transient' if it doesn't exist yet and bind it."
  (unless (fboundp 'wal/config-dispatch)
    (require 'transient)
    (with-no-warnings
      (transient-define-prefix wal/config-dispatch ()
        "Facilitate the usage of or the working on Walheimat's config."
        [["Use"
          ("t" "tangle" wal/tangle-config)
          ("x" "install expansion pack" wal/install-expansion-pack)
          ("g" "customize group" wal/customize-group)]
         ["Check"
          ("c" "checkdoc" wal/checkdoc-config-packages)
          ("f" "flycheck" wal/flycheck-config-packages)
          ("o" "coverage" wal/check-coverage)]
         ["View"
          ("p" "packages" wal/dired-config-packages)
          ("m" "show changes" wal/show-config-diff-range)
          ("l" "find changelog" wal/find-config-changelog)]
         ["Fluff"
          ("w" "toggle animation" wal/ascii-whale-toggle-display)]])
      (general-define-key
       :keymaps 'wal/config-mode-map
       "C-c 9" '(wal/config-dispatch :wk "config dispatch")))))

(define-minor-mode wal/config-mode
  "Mode for editing Walheimat's config."
  :init-value nil
  :global nil
  :lighter " wal"
  :keymap wal/config-mode-map
  (require 'transient nil t)
  (require 'checkdoc nil t)
  (require 'posframe nil t)
  (wal/config-maybe-create-transient)
  (add-hook 'after-revert-hook #'wal/tangle-config-prompt nil t)
  (when wal/config-show-whale-animation
    (wal/ascii-whale-setup)))
#+END_SRC

** Loading

This basically just a giant =require=.

#+BEGIN_SRC emacs-lisp
(when (boundp 'wal/emacs-config-package-path)
  (add-to-list 'load-path wal/emacs-config-package-path))

(dolist (it wal/sub-packages)
  (require it nil t))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal)

;;; wal.el ends here
#+END_SRC

* Additional Package Files

This package has a Cask file to set it up as a testable package.

** Cask File
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "Cask" wal/emacs-config-package-path)
:END:

#+BEGIN_SRC emacs-lisp
(source gnu)
(source melpa)

(development
 (depends-on "ert-runner")
 (depends-on "undercover"))

(package "wal" "1.7.12" "Walheimat's configuration")

(package-file "wal.el")

(files "*.el")
#+END_SRC

** Test Helper
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "test/test-helper.el" wal/emacs-config-package-path)
:END:

Provide common test functionality and require the packages.

#+BEGIN_SRC emacs-lisp
;;; test-helper.el --- Test helpers. -*- lexical-binding: t; -*-

;;; Commentary:
;;
;; Helper macros.

;;; Code:

(when (require 'undercover nil t)
  (cond
    ((getenv "CI")
     (undercover "*.el"
                 (:report-format 'lcov)
                 (:send-report nil)))
    ((getenv "COVERAGE_WITH_JSON")
     (setq undercover-force-coverage t)
     (undercover "*.el"
                 (:report-format 'simplecov)
                 (:report-file "../coverage/.resultset.json")
                 (:send-report nil)))
    (t
     (setq undercover-force-coverage t)
     (undercover "*.el"
                 (:report-format 'text)
                 (:report-file "coverage.txt")
                 (:send-report nil)))))

(setq wal/booting nil)

;; Create a dummy `use-package' definition.
(defmacro use-package (package-name &rest _args)
  "Message that PACKAGE-NAME would have been loaded."
  `(message "Would have loaded %s" ',package-name))

(defmacro with-mock (name fun &rest body)
  "Evaluate BODY while mocking function NAME using FUN."
  (declare (indent defun))
  `(cl-letf (((symbol-function ',name) ,fun))
     ,@body))

(defmacro with-mock-all (flist &rest body)
  "Evaluate BODY mocking alist of functions FLIST."
  (declare (indent defun))
  `(cl-letf (,@(mapcar (lambda (it) `((symbol-function ',(car it)) ,(cdr it))) flist))
     ,@body))

(defmacro match-expansion (form &rest value)
  "Match expansion of FORM against VALUE."
  `(should (pcase (macroexpand-1 ',form)
             ,@(mapcar #'(lambda (x) (list x t)) value))))

(require 'ert-x)
(require 'wal-func)
(require 'wal-look)
(require 'wal-fluff)
(require 'wal-fonts)

;;; test-helper.el ends here
#+END_SRC

* Footnotes

[fn:1] Jumped ship from =27.1=. Some minor things might not work there.
I currently use this config in =28.1.50= and =29.0.50=.

[fn:2] If you're feeling adventurous, [[https://git.savannah.gnu.org/cgit/emacs.git/tree/INSTALL][build from source]].

[fn:3] If you're not sure where your =user-emacs-directory= might be,
you can do the following:

+ Run Emacs
+ hit =M-x= (that is your Alt/Option key followed by the letter =x=)
+ type =describe-variable= and hit return
+ type =user-emacs-directory= and hit return again.

A window should pop up telling you the path.

Finally run =git clone git@gitlab.com:Walheimat/emacs-config.git
~/.emacs.d= (replace =~/.emacs.d= with your actual path if it differs).

[fn:4] This includes this very config which will be exported as a
package collection.

Packages that belong to an expansion pack (mainly language-specific
packages) or its extras need to be installed manually by calling
=wal/install-expansion-pack=.

[fn:5] Which means that a frame is reused or created and control
immediately returned. If you're using Emacs 29, consider using
=emacsclient -r= to reuse an existing frame.

[fn:6] Not including where =:tangle no= was set.

/Note/ they will not necessarily be evaluated in the same order they
appear in this file. The order of evaluation is determined by the
=wal.el= file from [[*Config Package][this section]].

[fn:7] Send me an email, why don't you?

[fn:8] To get a full overview you'll have to call
=describe-personal-keybindings= and =general-describe-keybindings=.

[fn:9] If hyper can't be used (or shouldn't be used if Emacs is run in
=no-window-system=), it is replaced by =C-c w <key>= for both leader keys
and other bindings.

[fn:10] Be careful! If you make a mistake you could render your
keyboard unusable.

[fn:11] Provided the modes are active.

[fn:12] Alternate spelling is "expansion pak".

[fn:13] The =all-the-icons= icons need to be downloaded manually by
running =M-x all-the-icons-install-fonts= and selecting =yes=.

If the installation process should fail for any reason, close Emacs
and re-run it.

[fn:14] You might have to call =emojify-download-emoji= to download a
set that supports your emojis.

[fn:15] If you're on an older distro your =libvterm= package might be
too old.

[fn:16] Currently requires [[https://daseldocs.tomwright.me/installation#manual ][dasel]].

[fn:17] Binding reference [[http://oremacs.com/lispy/][here]].

[fn:18] All languages listed [[https://emacs-lsp.github.io/lsp-mode/page/languages/][here]].
