#+TITLE: Walheimat's Emacs Config
#+AUTHOR: [[https://gitlab.com/Walheimat][@Walheimat]]
#+TOC: headlines 3

[[./assets/logo.png]]

* About

** Heads-Up

This project is my personal literate Emacs (28.0.50)[fn:1] configuration.

If you're a complete beginner,
you will find [[https://github.com/emacs-tw/awesome-emacs#starter-kit][more user-friendly and less tailor-made configs]] out there.

Feel free to consider it a jumping-off-point for your own custom config.
Just know that nothing in this config should be considered /good practice/,
it's mostly just how I (think I) like things to be.

** Try-Out

If you're interested in trying out Emacs using my config,
here are the necessary steps:

+ Install Emacs if you haven't[fn:2]
+ =git clone= this repository into your =user-emacs-directory=[fn:3]
+ copy the config file included in this repo by running =cp ~/.emacs.d/emacs-config/templates/.emacs ~=
+ close and re-run Emacs which should download and install all[fn:4] packages.

If you do not wish to =clone= this repo in your =user-emacs-directory= or use the default name,
you will need to adapt the variable =wal/emacs-config-default-path= in the example config you just copied.

** Peculiarities

*** Daemon Mode

This config is /daemon-ready/, i.e. if you start Emacs with the =--daemon= flag,
the config will make sure that any customization that requires a frame
will only be loaded once a frame was created.

A =systemd= service config can be found in the =/templates= directory to
get you started:

+ Run =mkdir -p ~/.config/systemd/user=
+ run =cp ~/.emacs.d/emacs-config/templates/emacs.service ~/.config/systemd/user=
+ adapt that =emacs.service= file to point to the correct path
+ run =systemctl --user enable emacs=.

Or you just execute =emacs --daemon= in a terminal or your shell's config.

In any case, an Emacs daemon will start (on start-up).
To connect you can use, for example, =emacsclient -c -n=[fn:5].

*** Scope

I've tried to keep custom functions and variables in a scope
called =wal= to avoid potential interference.

Enough preambling, let's configure some Emacs.
The init script will evaluate /everything/[fn:6] that follows.

* Pre-Export

You want speed? Then bind lexically!

#+BEGIN_SRC emacs-lisp
;;; README.el --- Walheimat's literate Emacs configuration. -*- lexical-binding: t; -*-

;;; Commentary:
;;
;; This file is an export of `README.org'.

;;; Code:
#+END_SRC

* Settings

** Personal

Set some personal info[fn:7].

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Krister Schuchardt"
      user-mail-address "krister.schuchardt@theventury.com")
#+END_SRC

** Start-Up

Customize start-up.

#+BEGIN_SRC emacs-lisp
;; Warn Mac/Windows users.
(unless (eq system-type 'gnu/linux)
  (warn "\
    Warning: Config only tested on Linux.
    While I did get in running on Windows 10,
    it was quite tricky and involved setting unsafe options."))

;; Maximize frame.
(setq frame-resize-pixelwise t)
(add-to-list 'initial-frame-alist '(fullscreen . maximized)) ; Leads to issues when using a tiling wm.

;; No splash.
(setq inhibit-startup-message t)
(setq initial-major-mode 'fundamental-mode) ; Avoids loading `prog-mode' derivatives.

;; Use a distinct file for customization and create it if it doesn't exist.
(setq custom-file (expand-file-name "custom.el" wal/emacs-config-default-path))
(unless (file-exists-p custom-file)
  (write-region "" nil custom-file))
(add-hook 'after-init-hook (lambda () (load custom-file)))

;; Accept redefinitions.
(setq ad-redefinition-action 'accept)
#+END_SRC

** Package Archives

Add MELPA to the package archives.
Most (if not all) packages will be installed from there.

#+BEGIN_SRC emacs-lisp
(require 'package)

(let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                    (not (gnutls-available-p))))
       (proto (if no-ssl "http" "https")))
  (when no-ssl (warn "\
   Your version of Emacs does not support SSL connections,
   which is unsafe because it allows man-in-the-middle attacks.
   There are two things you can do about this warning:
   1. Install an Emacs version that does support SSL and be safe.
   2. Remove this warning from your init file so you won't see it again."))
  (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t))

;; Don't pin packages.
(setq package-pinned-packages '())

(package-initialize)
#+END_SRC

** Core Packages

Packages are configured with the =use-package= macro.

#+BEGIN_SRC emacs-lisp
(defconst wal/core-packages '(diminish delight use-package)
  "Packages to install before using `use-package'.
Such as package `use-package'.")

(defun wal/install-packages (packages)
  "Install all PACKAGES unless already installed.
Concludes by calling `delete-other-windows'."
  (mapc (lambda (it)
            (when (not (package-installed-p it))
              (package-install it)))
          packages)
  (delete-other-windows))

;; Try to install. On fail refresh and install again.
(condition-case nil
    (wal/install-packages wal/core-packages)
  (error
   (package-refresh-contents)
   (wal/install-packages wal/core-packages)))

;; Ensure all packages by default.
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+END_SRC

** Directories

Make sure that custom directories exist.
We want:

+ A cache directory to store bookmarks, perspectives, prescience et al.
+ a directory for site lisp
+ a default directory for org files
+ a default directory for agenda tasks
+ a default directory for notes.

#+BEGIN_SRC emacs-lisp
(defvar wal/cache-directory
  (expand-file-name ".cache" user-emacs-directory)
  "The cache directory.")

;; Cf. next section.
(defvar wal/site-lisp-directory
  (expand-file-name "site-lisp" user-emacs-directory)
  "Directory of site Lisp packages.")

;; Change if necessary.
(defvar wal/org-directory (expand-file-name "org" "~")
  "Default directory for org files.")

;; I put all of my tasks into a subfolder `tasks' inside the org directory.
(defvar wal/agenda-tasks-directory
  (expand-file-name "tasks" wal/org-directory)
  "One-size-fits-all directory for agenda tasks.")

(defvar wal/org-roam-directory
  (expand-file-name "zettelkasten" wal/org-directory)
  "Directory for Zettelkasten note-taking.")

;; Create all dirs.
(mapc (lambda (it)
        (unless (file-directory-p it)
          (make-directory it)))
      `(,wal/cache-directory
        ,wal/site-lisp-directory
        ,wal/org-directory
        ,wal/agenda-tasks-directory
        ,wal/org-roam-directory))
#+END_SRC

** Site-Lisp

Add =site-lisp= directory and sub-directories to load path.
I put non-MELPA packages here.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path wal/site-lisp-directory)

;; Allow us to load from site-lisp package.
(add-to-list 'custom-theme-load-path
             (expand-file-name "emacs-site-lisp" wal/site-lisp-directory))

;; Add subdirs as well.
(dolist (project (directory-files wal/site-lisp-directory t "\\w+"))
  (when (file-directory-p project)
    (add-to-list 'load-path project)))
#+END_SRC

** Saving and Backups

Don't clutter up workspaces.

#+BEGIN_SRC emacs-lisp
;; Save places and do so in a file.
(setq save-place-file (expand-file-name ".places" user-emacs-directory))

;; Store backups in backups folder.
(setq backup-directory-alist
      `(("." . ,(expand-file-name (concat user-emacs-directory "backups")))))

;; Store autosaves in temp folder.
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))

;; We don't want this to mess with git.
(setq create-lockfiles nil)
#+END_SRC

** Global Modes

Any mode that should be on/off no matter what.

#+BEGIN_SRC emacs-lisp
;; A bunch of useful modes.
(show-paren-mode 1)
(global-auto-revert-mode 1)
(global-prettify-symbols-mode 1)
(save-place-mode 1)
(global-font-lock-mode 1)
(delete-selection-mode 1)
(column-number-mode 1)

;; No need for bars.
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

** Reasonable Sizes

Make things shorter and snappier.

#+BEGIN_SRC emacs-lisp
(defun wal/bytes-per-mb (num)
  "Return the integer value of NUM megabytes in bytes.
This function may be used to set variables that expect
bytes."
  (floor (* 1024 1024 num)))

(setq mouse-yank-at-point t
      show-paren-delay 0.1
      read-process-output-max (wal/bytes-per-mb 4)
      sentence-end-double-space nil
      echo-keystrokes 0.1
      ;; New in version 28. Otherwise you need an alias.
      use-short-answers t
      ;; Undo limits, keeping factor, defaults in side commments.
      undo-limit (wal/bytes-per-mb 1) ; 160000 bytes.
      undo-strong-limit (wal/bytes-per-mb 1.5) ; 240000 bytes.
      undo-outer-limit (wal/bytes-per-mb 150)) ; 24000000 bytes.
#+END_SRC

** Indentation

Set up an easy way to switch between tabs
and spaces for indentation.

#+BEGIN_SRC emacs-lisp
(defvar wal/indent-offset 4
  "The indent offset in spaces.")

(defvar wal/prefer-tabs nil
  "Whether tabs are preferred for indentation.")

(defvar wal/allow-custom-indent-line-fun t
  "Whether a custom `indent-line-function' can be passed.")

(defun wal/reset-to-standard (sym &optional locally)
  "Reset symbol SYM to its standard value.
If LOCALLY is t, the local variable is killed while its global
value is left untouched."
  (if (and locally (local-variable-p sym))
      (kill-local-variable sym)
    (set-default sym (eval (car (get sym 'standard-value))))))

(defun wal/reset-indent-defaults ()
  "Reset indent defaults.
Resets all variables that were initially set
by `wal/set-indent-defaults'."
  (interactive)
  (mapc (lambda (it)
          (wal/reset-to-standard it))
        '(python-indent-offset
          js-indent-level
          css-indent-offset
          electric-indent-inhibit
          tab-width
          indent-tabs-mode)))

(defun wal/disable-tabs ()
  "Disable tabs.
Unsets tab key and sets variable `indent-tabs-mode' to nil."
  (interactive)
  (local-unset-key (kbd "TAB"))
  (setq indent-tabs-mode nil))

(defun wal/enable-tabs ()
  "Enable tabs.
Sets tab key to `tab-to-tab-stop' and variable
`indent-tabs-mode' to t."
  (interactive)
  (local-set-key (kbd "TAB") 'tab-to-tab-stop)
  (setq indent-tabs-mode t))

(defun wal/maybe-enable-tabs (&optional tab-indent-fun mode-fun)
  "Maybe enable tabs.
Optionally set `indent-line-function' (if allowed) to TAB-INDENT-FUN
and call MODE-FUN after changes."
  (if wal/prefer-tabs
      (wal/enable-tabs)
    (wal/disable-tabs))
  (when (and wal/allow-custom-indent-line-fun tab-indent-fun)
    (setq-local indent-line-function tab-indent-fun))
  (when mode-fun
    (funcall mode-fun)))

(defun wal/set-indent-defaults (&optional num)
  "Set indent defaults.
All offsets are set to `wal/indent-offset' or
optionally to NUM."
  (interactive "nSet tab width to: ")
  (let ((offset (or num wal/indent-offset)))
    (setq-default python-indent-offset offset ; Python
                  js-indent-level offset ; JavaScript
                  css-indent-offset offset ; CSS and SCSS
                  tab-width offset
                  electric-indent-inhibit t
                  indent-tabs-mode wal/prefer-tabs)
    (setq backward-delete-char-untabify-method 'hungry)))

(add-hook 'after-init-hook 'wal/set-indent-defaults)
#+END_SRC

*** Dir Local Indentation

Sometimes you have to play using other people's rules.
You can run =add-dir-local-variable= to do so.
Check out the =.dir-locals.el= template found in the =/templates= folder
for an example using spaces.

** Persistent =*scratch*=

Let's keep the scratch contents.
This was cribbed from [[https://www.john2x.com/emacs.html][john2x's config]].

#+BEGIN_SRC emacs-lisp
;; Empty scratch message.
(setq initial-scratch-message "")

(defvar wal/scratch-persist-file
  (expand-file-name "scratch-persist" wal/cache-directory)
  "The file to persist the *scratch* buffer's content in.")

(defun wal/persist-scratch ()
  "Persist contents of *scratch* buffer.
The contents are stored in `wal/scratch-persist-file'."
  (with-current-buffer (get-buffer-create "*scratch*")
    (write-region (point-min) (point-max) wal/scratch-persist-file)))

(defun wal/rehydrate-scratch ()
  "Re-hydrate scratch buffer (if persisted).
This overrides the scratch buffer with the content
stored in `wal/scratch-persist-file'."
  (if (file-exists-p wal/scratch-persist-file)
      (with-current-buffer (get-buffer "*scratch*")
        (delete-region (point-min) (point-max))
        (insert-file-contents wal/scratch-persist-file))))

(add-hook 'after-init-hook #'wal/rehydrate-scratch)
(add-hook 'kill-emacs-hook #'wal/persist-scratch)
#+END_SRC

* Key Bindings

I use many[fn:8] custom keybindings.

** Prefix Keys

*** Control

There are some non-standard control sequences.
Anywhere:

+ =C->=/=C-<= expands/contracts region
+ =C-.= marks next like this allowing
  + =C-,= to delete last mark and
  + =C-/= to move it downward
+ =C-?= redoes (as =C-/= undoes).

User-reserved combinations are used for certain command maps:

+ =C-c b= for =bookmark=, and when the respective mode is active:
+ =C-c f= for =flycheck=
+ =C-c i= for =perspective=
+ =C-c p= for =projectile=
+ =C-c m= for =smerge=.

It's also used for certain dispatches:

+ =C-c a= for =org-agenda=
+ =C-c d= for =docker=.

*** Hyper

Most hyper bindings are quick-access actions:

+ =H-a= searches with =ag= and (=H-s= with =counsel-projectile-ag=)
+ =H-c= completes at point using =company= (in =company-mode=)
+ =H-d= duplicates current line/region with =crux=
+ =H-e= opens (and =H-r= cycles through) =popper= pop-up(s)
+ =H-f= finds project file using =counsel-projectile=
+ =H-g= to use =counsel-mark-ring=
+ =H-i= switches =perspective=
+ =H-k= to start (and =H-j= to end or call) macro
+ =H-l= jumps to line (and =H-o= to word) with =avy=
+ =H-<mouse3>= adds another =multiple-cursor= at point
+ =H-m= runs =magit-status=
+ =H-n= to capture (using =counsel-projectile-org-capture=)
+ =H-p= switches projects using =projectile=
+ =H-y= expands snippets (in =yas-minor-mode=)
+ =H-== to do a =quick-calc= (inserted if called with =C-u=)
+ =H-t= toggles =vterm=.

It's also used for some dispatches:

+ =H-w= for =ace-window=.

It's also used for three hydras:

+ =H-]= to resize window
+ =H-[= to scale text
+ =H-v= to scroll other window.

*** Case-Sensitivity

Some key-bindings have case-sensitive alternatives:

+ =C-K= kills lines backwards using =crux=
+ =C-x D= runs =dired= starting at =HOME= directory
+ =C-x K= kills any buffer (ignoring current perspective)
+ =H-F= finds directories using =counsel-projectile=
+ =H-L= jumps to line and char (while =H-O= jumps to word without first char).

*** Caps to Hyper

I re-bound my =<CAPS>= (caps-lock) key to =Hyper_L= to use the
hyper bindings above.

If you use Xorg Display Server, the risky quite[fn:9] way would be
to edit your =/usr/share/X11/xkb/symbols/pc= file like so:

#+BEGIN_SRC
...
// key <CAPS> {    [ Caps_Lock     ]   };
key <CAPS> {    [ Hyper_L       ]   };
...
// modifier_map Lock   { Caps_Lock };
modifier_map Mod3   { Hyper_L, Hyper_R };
...
// modifier_map Mod4   { <HYPR> };
modifier_map Mod3   { <HYPR> };
#+END_SRC

A safer alternative might be to create an =.xsession= file in
your home folder containing the following:

#+BEGIN_SRC sh :tangle no
xmodmap -e "keysym Caps_Lock = Hyper_L" \
		-e "remove Mod4 = Hyper_L" \
		-e "add Mod3 = Hyper_L"
#+END_SRC

This assumes that =Hyper_L= was assigned to modifier =Mod4= that's
already used by =Super_L= and modifier =Mod3= is an empty group.
I haven't gotten this safer alternative to work for me.

** Leader Keys

The are five multi-purpose =general= leader keys.
They prefix actions by common context.

#+BEGIN_SRC emacs-lisp
;; American ranks.
(defconst wal/general-key "H-;"
  "The primary (or general) leader key.")

(defconst wal/colonel-key "H-'"
  "The secondary (or colonel) leader key.")

(defconst wal/major-key "H-,"
  "The tertiary (or major) leader key.")

(defconst wal/captain-key "H-."
  "The quaternary (or captain) leader key.")

(defconst wal/lieutenant-key "H-/"
  "The quinary (or lieutenant) leader key.")

(cl-defmacro wal/create-leader-sink (name &key definer prefix)
  "Macro to create a leader sink `NAME-sink'.
NAME is the name of the macro. DEFINER is the definer to create the sink for
and PREFIX is its prefix."
  (let* ((defname (symbol-name definer))
         (pref (symbol-value prefix))
         (suf (substring pref -1))
         (wk (upcase (concat (substring defname 4) "!"))))
    (progn
      (general-define-key :prefix pref suf `(:ignore t :wk ,wk))
      `(defmacro ,name (&rest args)
         `(, ',definer ,@,`(mapcar (lambda (it)
                                     (if (stringp it)
                                         (concat ,suf it)
                                       it)) args))))))

(use-package general
  :demand
  :config
  (mapc (lambda (it)
          (let ((key (intern (format "%s-key" it)))
                (sink (intern (format "%s-sink" it))))
            (eval `(general-create-definer ,it :prefix ,key))
            (eval `(wal/create-leader-sink ,sink :definer ,it :prefix ,key))))
        '(wal/general wal/colonel wal/major wal/captain wal/lieutenant)))
#+END_SRC

*** About Leader Keys

Leader key =general= prefixes Emacs actions like loading a theme,
finding a library, quitting as well as opening =eshell= and =eww=.

Leader key =colonel= prefixes mode toggles.
Available modes may depend on =major-mode=.

Leader keys =major= and =captain= prefix mode-specific actions,
for major and minor modes respectively.

Leader key =lieutenant= prefixes non- or semi-mode package actions.
The package prefixes are:

+ =a= for =ag=
+ =.= for =multiple-cursors=
+ =l= and =r= for =avy= (line and region)
+ =m= for =magit=
+ =o= for =counsel=
+ =p= for =smartparens= (a =hydra=)
+ =u= for =consult=
+ =x= for =crux=
+ =z= for =org-roam=.

All leader keys have sinks for sporadically used actions that should
still always be available.

** Additional (Un-)Bindings

Most bindings are declared in the [[*Packages][packages]] section.

#+BEGIN_SRC emacs-lisp
(defvar wal/readme-config
  (expand-file-name "README.org" wal/emacs-config-default-path)
  "The path to Walheimat's config.")

(defun wal/get-config-version ()
  "Get the version of the config using git describe."
  (interactive)
  (let ((default-directory wal/emacs-config-default-path))
    (string-trim (shell-command-to-string "git describe --abbrev=0"))))

(defvar wal/tangle-do-prompt t
  "Whether to prompt user to tangle config.")

(defun wal/tangle-config-prompt ()
  "Prompt the user to tangle the config.
If the answer is no, there will be no additional prompt."
  (interactive)
  (let ((help-form (message "This will update your README.el. Restart Emacs afterwards.")))
    (if (and wal/tangle-do-prompt (y-or-n-p "Config changed, want to tangle? "))
        (wal/tangle-config)
      (if wal/tangle-do-prompt
          (progn
            (setq-local wal/tangle-do-prompt nil)
            (message "To tangle, call `wal/tangle-config'"))
        (message "Config changed. To tangle, call `wal/tangle-config'")))))

(defun wal/open-init ()
  "Open and switch to the `user-init-file'."
  (interactive)
  (switch-to-buffer (find-file-noselect user-init-file)))

(defun wal/open-config ()
  "Open Walheimat's config.
Saving the config after opening it with this function
will prompt the user to tangle its contents."
  (interactive)
  (switch-to-buffer (find-file-noselect wal/readme-config))
  (add-hook 'after-save-hook #'wal/tangle-config-prompt nil t)
  (add-hook 'after-revert-hook #'wal/tangle-config-prompt nil t))

(wal/general
  "c" '(wal/open-config :wk "open config")
  "i" '(wal/open-init :wk "open init"))

;; Killing Emacs.
(global-unset-key (kbd "C-x C-c"))
(wal/general "q" '(save-buffers-kill-terminal :wk "quit Emacs"))

;; Create dir locals.
(wal/general-sink "l" '(add-dir-local-variable :wk "add dir local variable"))
#+END_SRC

*** Hydra

Provides a context for related commands that can
be (re-)executed in quick succession.

Package =smartparens= also defines a =hydra=.

#+BEGIN_SRC emacs-lisp
(defvar wal/ascii-whale #("}< ,.__)" 0 8 (face mode-line-emphasis))
  "A small, highlighted ASCII whale.")

(defun wal/ascii-whale-hydra-offset ()
  "Get a string offset for the `wal/ascii-whale'."
  (make-string (length wal/ascii-whale) ? ))

(defun wal/text-scale-reset ()
  "Reset `text-scale' level to 0."
  (interactive)
  (text-scale-set 0))

(use-package hydra)

;; Scaling text in buffer.
(defhydra wal/text-scale (:hint nil)
  "
%s`wal/ascii-whale _i_ncrease, _d_ecrease or _r_eset text size. Or _q_uit.
"
  ("i" text-scale-increase)
  ("d" text-scale-decrease)
  ("r" wal/text-scale-reset)
  ("q" nil))

;; Move window splitter or balance windows.
(defhydra wal/resize-window (:hint nil)
  "
%s(wal/ascii-whale-hydra-offset)   ^_p_^
%s`wal/ascii-whale _b_   _f_ window splitter. Ba_l_ance. Or _q_uit.
%s(wal/ascii-whale-hydra-offset)   ^_n_^
"
  ("b" wal/edge-left)
  ("f" wal/edge-right)
  ("n" wal/edge-down)
  ("p" wal/edge-up)
  ("o" wal/split-window-the-other-way)
  ("l" balance-windows)
  ("q" nil))

(defhydra wal/scroll-other-window (:timeout 4 :hint nil)
  "
%s`wal/ascii-whale Scroll other window u_p_/dow_n_. Or _q_uit.
"
  ("p" scroll-other-window-down)
  ("n" scroll-other-window)
  ("q" nil))

(general-define-key
 "H-[" '(wal/text-scale/body :wk "text scale")
 "H-]" '(wal/resize-window/body :wk "resize window")
 "H-v" '(wal/scroll-other-window/body :wk "scroll other window"))
#+END_SRC

*** Additional Mode Controls

Turning on/off certain major modes
switching between =major-mode= and =fundamental-mode=.

#+BEGIN_SRC emacs-lisp
(defvar wal/before-fundamental-mode nil
  "The major mode before fundamental was engaged.")

(defun wal/fundamental-mode ()
  "Switch from `major-mode' to `fundamental-mode' and back."
  (interactive)
  (let ((m-mode major-mode))
    (if wal/before-fundamental-mode
        (progn
          (funcall wal/before-fundamental-mode)
          (setq wal/before-fundamental-mode nil))
      (fundamental-mode)
      (make-local-variable 'wal/before-fundamental-mode)
      (setq wal/before-fundamental-mode m-mode))))

;; Little EOF joke for ya.
(wal/colonel-sink
 "E" '(emacs-lisp-mode :wk "Elisp")
 "O" '(org-mode :wk "Org")
 "F" '(wal/fundamental-mode :wk "Fundamental"))
#+END_SRC

* Additional Functions

** Directories

Finding files should =mkdir -p= its parents.

#+BEGIN_SRC emacs-lisp
;; Creating parent dirs.
(defun wal/create-non-existent-directory ()
  "Ask whether to create non-existent directory.
If a file is found in a not (yet) existing directory,
ask if it should get created."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Create non-existing directory `%s'? " parent-directory)))
      (make-directory parent-directory t))))

(add-to-list 'find-file-not-found-functions #'wal/create-non-existent-directory)

;; Don't care about `.' and `..'.
(defun wal/directory-files (directory)
  "Get all directory files in DIRECTORY except for current and parent directories."
  (nthcdr 2 (directory-files directory t)))
#+END_SRC

** Buffers

Ignore some buffers when switching.

#+BEGIN_SRC emacs-lisp
(defvar wal/commonly-ignored-major-modes
  '(dired-mode wdired-mode helpful-mode magit-diff-mode magit-status-mode vterm-mode)
  "Major modes whose buffers should be commonly ignored.")

(defun wal/commmonly-ignored-buffer-p (buffer-or-string)
  "Check if provided BUFFER-OR-STRING is commonly ignored.
Commonly ignored buffers are those belonging to major modes
in `wal/commonly-ignored-major-modes' as well as starred
buffers other than scratch and eww buffers."
  (let ((maj (with-current-buffer
                 (get-buffer-create buffer-or-string)
               major-mode)))
    (or (member maj wal/commonly-ignored-major-modes)
        ;; Starred buffers other than scratch and eww buffers.
        (and (not (string-match "^\\*scratch" buffer-or-string))
             (not (string-match "^\\*eww\\*\\'" buffer-or-string))
             (string-match "^\\*[[:ascii:]]+\\*\\'" buffer-or-string)))))
#+END_SRC

*** Buffer Display

Utility functions to configure displaying buffers of a certain type.

#+BEGIN_SRC emacs-lisp
(defun wal/display-buffer-condition (buffer-or-mode)
  "Get a display buffer condition for BUFFER-OR-MODE."
  (pcase buffer-or-mode
    ((pred stringp) buffer-or-mode)
    ((pred symbolp) `(lambda (bufname _)
                       (with-current-buffer bufname
                         (equal major-mode ',buffer-or-mode))))
    (_ nil)))

(defun wal/display-buffer-in-pop-up (buffer &optional in-frame)
  "Display BUFFER in a pop-up.
The pop-up is a window unless IN-FRAME is t."
  (let ((condition (wal/display-buffer-condition buffer))
        (dispfun (if in-frame
                     'display-buffer-pop-up-frame
                   'display-buffer-pop-up-window)))
    (add-to-list 'display-buffer-alist
                 `(,condition
                   (,dispfun)))))

;; The next two functions make sense for `popper' buffers.

(defun wal/display-buffer-in-side-window (buffer &optional side loose no-other)
  "Display BUFFER in SIDE window.
This window will be on SIDE (on the bottom by default),
dedicated to the buffer (unless LOOSE),
available to `other-window' (unless NO-OTHER)
and visible frames are considered reusable."
  (let ((condition (wal/display-buffer-condition buffer)))
    (add-to-list 'display-buffer-alist
                 `(,condition
                   (display-buffer-reuse-window display-buffer-in-side-window)
                   (side . ,(or side 'bottom))
                   (dedicated . ,(not loose))
                   (reusable-frames . visible)
                   (window-parameters . ((no-other-window . ,no-other)))))))

(defun wal/display-buffer-in-direction (buffer &optional direction)
  "Display BUFFER in direction.
The direction is right-most or DIRECTION."
  (let ((condition (wal/display-buffer-condition buffer)))
    (add-to-list 'display-buffer-alist
                 `(,condition
                   (display-buffer-reuse-mode-window display-buffer-in-direction)
                   (direction . ,(or direction 'rightmost))))))
#+END_SRC

** Windows

I keep messing up, splitting vertically when I meant horizontally.
This is inspired by [[https://github.com/purcell/emacs.d/blob/master][purcell's config]].

#+BEGIN_SRC emacs-lisp
(defun wal/split-window-the-other-way ()
  "Split window the other way.
This means if horizontally split, split vertically;
if vertically split, split horizontally."
  (interactive)
  (let* ((other-buffer (and (next-window) (window-buffer (next-window))))
         (win (selected-window))
         (split-direction (cond ((or (windows-sharing-edge win 'above)
                                     (windows-sharing-edge win 'below))
                                 'vert)
                                ((or (windows-sharing-edge win 'right)
                                     (windows-sharing-edge win 'left))
                                 'hori)
                                (t nil))))
    (delete-other-windows)
    (pcase split-direction
      ('vert (split-window-horizontally))
      ('hori (split-window-vertically))
      (_ nil))
    (when other-buffer
      (set-window-buffer (next-window) other-buffer))))

(defun wal/edge (scale-above scale-below)
  "Move the window splitter using SCALE-ABOVE and SCALE-BELOW."
  (interactive)
  (let* ((win (selected-window))
         (direction (cond ((windows-sharing-edge win 'above) scale-above)
                          ((windows-sharing-edge win 'below) scale-below)
                          (t nil))))
    (pcase direction
      ('enlarge (wal/enlarge-window))
      ('shrink (wal/shrink-window))
      (_ (message "Selected window does not share a vertical edge with another window")))))

(defun wal/edge-horizontally (scale-left scale-right)
  "Move the window splitter using SCALE-LEFT and SCALE-RIGHT."
  (interactive)
  (let* ((win (selected-window))
         (direction (cond ((windows-sharing-edge win 'left) scale-left)
                          ((windows-sharing-edge win 'right) scale-right)
                          (t nil))))
    (pcase direction
      ('enlarge (wal/enlarge-window-horizontally))
      ('shrink (wal/shrink-window-horizontally))
      (_ (message "Selected window does not share a horizontal edge with another window")))))

(defun wal/edge-left ()
  "Move the splitter of the selected window left.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge-horizontally 'enlarge 'shrink))

(defun wal/edge-right ()
  "Move the splitter of the selected window right.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge-horizontally 'shrink 'enlarge))

(defun wal/edge-up ()
  "Move the splitter of the selected window up.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge 'enlarge 'shrink))

(defun wal/edge-down ()
  "Move the splitter of the selected window down.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge 'shrink 'enlarge))

(defun wal/shrink-window (&optional horizontally)
  "Shrink the selected window (HORIZONTALLY)."
  (interactive)
  (let* ((available (window-min-delta (selected-window) horizontally))
         (chunk (floor (* available 0.2))))
    (if horizontally
        (shrink-window-horizontally chunk)
      (shrink-window chunk))))

(defun wal/shrink-window-horizontally ()
  "Shrink the selected window horizontally."
  (interactive)
  (wal/shrink-window t))

(defun wal/enlarge-window (&optional horizontally)
  "Enlarge the selected window (HORIZONTALLY)."
  (interactive)
  (let* ((available (window-max-delta (selected-window) horizontally))
         (chunk (floor (* available 0.2))))
    (if horizontally
        (enlarge-window-horizontally chunk)
      (enlarge-window chunk))))

(defun wal/enlarge-window-horizontally ()
  "Enlarge the selected window horizontally."
  (interactive)
  (wal/enlarge-window t))
#+END_SRC

*** walled-mode

Minor mode to dedicate buffers to windows.

#+BEGIN_SRC emacs-lisp
(define-minor-mode walled-mode
  "Dedicate the window."
  :init-value nil
  :lighter " wld"
  (cond
   (noninteractive
    (setq walled-mode nil))
   (walled-mode
    (walled-mode--enable))
   (t
    (walled-mode--disable))))

(defun walled-mode--enable ()
  "Dedicate the window to the current buffer."
  (let ((window (selected-window))
        (bufname (current-buffer)))
    (set-window-dedicated-p window bufname)
    (message "Dedicating window to %s" bufname)))

(defun walled-mode--disable ()
  "Make window no longer dedicated to its buffer."
  (let* ((window (selected-window))
        (bufname (window-dedicated-p window)))
    (set-window-dedicated-p window nil)
    (message "Window no longer dedicated to %s" bufname)))

(use-package walled-mode
  :ensure nil
  :general
  (wal/colonel "." '(walled-mode :wk "walled")))
#+END_SRC

** Garbage Collection

Better(?) garbage collection.

#+BEGIN_SRC emacs-lisp
(defvar wal/gc-cons-threshold-in-mb 10
  "The default `gc-cons-threshold' epxressed in MB.")

(defun wal/minibuffer-setup-hook ()
  "Increase `gc-cons-threshold' to maximum on minibuffer setup."
  (setq gc-cons-threshold most-positive-fixnum))

(defun wal/minibuffer-exit-hook ()
  "Decrease `gc-cons-threshold' on minibuffer exit."
  (setq gc-cons-threshold (wal/bytes-per-mb wal/gc-cons-threshold-in-mb)))

(add-hook 'minibuffer-setup-hook #'wal/minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook #'wal/minibuffer-exit-hook)
(add-hook 'emacs-startup-hook #'wal/minibuffer-exit-hook)
#+END_SRC

** Files

Handling of files.

#+BEGIN_SRC emacs-lisp
;; Set to `t' in `.dir-locals.el' if whitespace should be removed on save.
(defvar wal/delete-trailing-whitespace nil
  "Whether to delete trailing whitespace.")

(defun wal/advise-hack-local-variables (&rest _r)
  "Advise to conditionally add before save hook.
When `wal/delete-trailing-whitespace' is t, trailing
whitespace is deleted."
  (when wal/delete-trailing-whitespace
    (add-hook 'before-save-hook #'delete-trailing-whitespace nil t)))

(advice-add 'hack-local-variables :after #'wal/advise-hack-local-variables)
#+END_SRC

* Look

Make frame transparent and set themes.
[[https://peach-melpa.org/][PeachMelpa]] has more themes.

#+BEGIN_SRC emacs-lisp
;; Mix of old and new.
(setq frame-title-format '(multiple-frames "%b"
                                           ("%b@" system-name)))

;; Transparency.
(defvar wal/transparency 90
  "The default frame transparency.")

(defun wal/transparency (&optional value)
  "Set the transparency of the frame to VALUE.
1 being (almost) completely transparent, 100 being opaque."
  (interactive "nSet transparency (1-100): ")
  (let ((transparency (min (max (or value wal/transparency) 1) 100))
        (default-param (assoc 'alpha default-frame-alist)))
    (set-frame-parameter (selected-frame) 'alpha transparency)
    (when default-param
      (setcdr default-param transparency))))

(defvar wal/theme nil
  "The theme.")

;; Some themes require configuration, so we only load after initialization.
(defun wal/setup-visuals ()
  "Setup visual frills like theme and transparency."
  (interactive)
  (when wal/theme
    (load-theme wal/theme t))
  (wal/transparency))

(if (daemonp)
    (add-hook 'server-after-make-frame-hook 'wal/setup-visuals)
  ;; Function `wal/transparency' hasn't been untangled yet.
  (add-hook 'after-init-hook 'wal/setup-visuals)
  ;; Add the transparency to the `default-frame-alist' as well.
  (add-to-list 'default-frame-alist `(alpha . ,wal/transparency)))
#+END_SRC

* Fonts

Set fonts (with preference).
To get support for ligatures, install the symbol font from [[https://github.com/tonsky/FiraCode/files/412440/FiraCode-Regular-Symbol.zip][here]].

#+BEGIN_SRC emacs-lisp
(defvar wal/fixed-fonts
  '("Iosevka"
    "Input Mono"
    "mononoki"
    "Fira Code"
    "JetBrains Mono"
    "Source Code Pro"
    "DejaVu Sans Mono"
    "Monoid" ; The calt version doesn't work properly!
    "Liberation Mono")
  "Fixed fonts ordered by preference.")

(defvar wal/variable-fonts
  '("Roboto" "Ubuntu" "San Francisco" "Arial")
  "Variable fonts ordered by preference.")

(defvar wal/preferred-fonts nil
  "List of (fixed and variable width) font names that should be preferred.")

(defvar wal/fixed-font-height 120
  "The font height for fixed fonts.
The default value is 98.")

(defvar wal/variable-font-height 140
  "The font height for variable fonts.
This has no default value.")

(defun wal/select-fixed-font (font)
  "Select fixed (available) FONT.
This sets both the `default' and `fixed-pitch' fonts.
If variable `doom-modeline-mode' is t, refresh font width cache."
  (interactive
   (list (completing-read "Select font: " (wal/available-fonts wal/fixed-fonts))))
  (set-face-attribute 'default nil :font font)
  (set-face-attribute 'fixed-pitch nil :font font)
  (when (and (boundp 'doom-modeline-mode) doom-modeline-mode)
    (run-with-idle-timer 0.2 nil #'doom-modeline-refresh-font-width-cache)))

(defun wal/available-fonts (fonts)
  "Filter FONTS down to available fonts."
  (delete nil
          (mapcar (lambda (it)
                    (if (find-font (font-spec :name it))
                        it))
                  fonts)))

(defun wal/preferred-fonts (fonts)
  "Filter FONTS down to preferred fonts."
  (delete nil
          (mapcar (lambda (it)
                    (if (member it wal/preferred-fonts)
                        it)) fonts)))

(defun wal/fonts-candidate (fonts &optional prefer)
  "Return the first available font from a list of FONTS.
If PREFER is true, variable `wal/preferred-fonts' is not nil
and preferred fonts are available, return the first of those instead."
  (let* ((available-fonts (wal/available-fonts fonts))
         (preferred (and prefer (wal/preferred-fonts available-fonts))))
    (if preferred
        (car preferred)
      (car available-fonts))))

(defun wal/setup-fonts ()
  "Setup fonts.
This sets `default' and `fixed-pitch' fonts to the first available
candidate from `wal/fixed-fonts'.
Does the same for `variable-pitch' using `wal/variable-fonts'."
  (set-face-attribute 'default nil
                      :font (wal/fonts-candidate wal/fixed-fonts t)
                      :height wal/fixed-font-height)
  (set-face-attribute 'fixed-pitch nil
                      :font (wal/fonts-candidate wal/fixed-fonts t)
                      :height wal/fixed-font-height)
  ;; Variable pitch face.
  (set-face-attribute 'variable-pitch nil
                      :font (wal/fonts-candidate wal/variable-fonts t)
                      :height wal/variable-font-height))

;; Fonts can't be initialized thru daemon.
(if (daemonp)
    (add-hook 'server-after-make-frame-hook 'wal/setup-fonts)
  (add-hook 'after-init-hook 'wal/setup-fonts))

;; I want my comments slanted and my keywords bold.
;; The FiraCode font does not support this.
(defun wal/font-lock ()
  "Set comment face to italic and keyword face to bold."
  ;; Slanted and enchanted.
  (set-face-attribute 'font-lock-comment-face nil :slant 'italic :weight 'normal)
  (set-face-attribute 'font-lock-keyword-face nil :weight 'bold))

(add-hook 'font-lock-mode-hook 'wal/font-lock)
#+END_SRC

* Packages

What follows is a list of packages[fn:10] that make Emacs even more awesome.

If you wish to know more about any of them
call =describe-package= (bound to =C-h P=) and type in the package name.

If you're looking for additional packages, check out the [[https://github.com/emacs-tw/awesome-emacs][awesome-emacs]] project
for inspiration.

** Emacs

Everything that has to do with Emacs-y stuff.

*** Built-In

Minor configurations for built-in packages[fn:11].

**** bookmark

Configure annotation usage.

#+BEGIN_SRC emacs-lisp
(use-package bookmark
  :ensure nil
  :custom
  (bookmark-use-annotations t)
  (bookmark-automatically-show-annotations t)
  (bookmark-menu-confirm-deletion t)
  :config
  (wal/display-buffer-in-side-window "\\*Bookmark Annotation\\*" 'left)
  :bind-keymap ("C-c b" . bookmark-map)
  :bind
  (:map bookmark-map
   ("l" . bookmark-bmenu-list)
   ("L" . bookmark-load)))
#+END_SRC

**** calc

Quick calculations.

#+BEGIN_SRC emacs-lisp
(use-package calc
  :ensure nil
  :bind
  ("H-=" . quick-calc))
#+END_SRC

**** debug

For internal debugging.

#+BEGIN_SRC emacs-lisp
(use-package debug
  :ensure nil
  :defer t
  :custom
  (debugger-bury-or-kill 'kill)
  :config
  (wal/display-buffer-in-side-window 'debug-mode))
#+END_SRC

**** dictionary

Look up words.

#+BEGIN_SRC emacs-lisp
(use-package dictionary
  :ensure nil
  :general
  (wal/lieutenant-sink
    "d" '(dictionary-lookup-definition :wk "lookup definition"))
  :custom
  (dictionary-server "dict.org")
  :config
  (wal/display-buffer-in-direction "^\\*Dictionary"))
#+END_SRC

**** ediff

Use a single frame and split horizontally.

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :ensure nil
  :defer t
  :custom
  (ediff-window-setup-function #'ediff-setup-windows-plain) ; Single frame.
  (ediff-split-window-function #'split-window-horizontally))
#+END_SRC

**** eldoc

Package =eglot= uses =eldoc= extensively.

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :ensure nil
  :defer t
  :delight " eld"
  :custom
  (eldoc-idle-delay 2.0)
  (eldoc-echo-area-use-multiline-p nil)
  (eldoc-echo-area-prefer-doc-buffer t)
  (eldoc-echo-area-display-truncation-message nil))
#+END_SRC

**** elec-pair

Less intrusive pairing mode than =smartparens=.

#+BEGIN_SRC emacs-lisp
(use-package elec-pair
  :ensure nil
  :hook (prog-mode . electric-pair-local-mode))
#+END_SRC

**** eww

Browse web in Emacs.
This requires Emacs to have been compiled with =--with-xml2= flag.

#+BEGIN_SRC emacs-lisp
(use-package eww
  :ensure nil
  :general
  (wal/general "b" '(eww :wk "eww"))
  (wal/general-sink "b" '(eww-search-words :wk "search words (eww)")))
#+END_SRC

**** help

#+BEGIN_SRC emacs-lisp
(use-package help-mode
  :ensure nil
  :defer t
  :config
  (wal/display-buffer-in-direction 'help-mode))
#+END_SRC

**** hl-line

Some modes can use some =hl-line-mode=.

#+BEGIN_SRC emacs-lisp
(use-package hl-line
  :ensure nil
  :hook
  ((tablist-minor-mode
    tabulated-list-mode
    dired-mode
    dashboard-mode) . hl-line-mode))
#+END_SRC

**** kmacro

#+BEGIN_SRC emacs-lisp
(use-package kmacro
  :ensure nil
  :bind
  ("H-k" . kmacro-start-macro-or-insert-counter)
  ("H-j" . kmacro-end-or-call-macro))
#+END_SRC

**** linum

#+BEGIN_SRC emacs-lisp
(use-package linum
  :ensure nil
  :general
  (wal/colonel "n" '(linum-mode :wk "linum")))
#+END_SRC

**** package

Bind some functions to refresh, install and delete.

#+BEGIN_SRC emacs-lisp
(use-package package
  :ensure nil
  :general
  (wal/general "p" '(:ignore t :wk "package")
    "pf" '(package-refresh-contents :wk "refresh")
    "pi" '(package-install :wk "install")
    "pl" '(list-packages :wk "list")
    "pr" '(package-reinstall :wk "re-install")
    "pd" '(package-delete :wk "delete")))
#+END_SRC

**** shortdoc

New in Emacs 28.1.

#+BEGIN_SRC emacs-lisp
(use-package shortdoc
  :ensure nil
  :defer t
  :config
  (wal/display-buffer-in-direction 'shortdoc-mode))
#+END_SRC

**** simple

Bind some useful functions.

#+BEGIN_SRC emacs-lisp
(use-package simple
  :ensure nil
  :general
  (wal/general-sink "p" '(list-processes :wk "list processes"))
  (wal/major-sink "w" '(delete-trailing-whitespace :wk "delete trailing whitespace"))
  :custom
  (kill-ring-max 120)
  (save-interprogram-paste-before-kill t)
  (mark-ring-max 32)
  (global-mark-ring-max 32)
  :bind
  ("C-?" . undo-redo))
#+END_SRC

**** smerge

Make the command map accessible.

#+BEGIN_SRC emacs-lisp
(use-package smerge-mode
  :ensure nil
  :delight " smg"
  :defer t
  :custom
  (smerge-command-prefix (kbd "C-c m")))
#+END_SRC

**** so-long

Some files are so long. This is now built-in.

#+BEGIN_SRC emacs-lisp
(use-package so-long
  :ensure nil
  :defer 5
  :custom
  (so-long-action 'so-long-minor-mode)
  :config
  (global-so-long-mode t))
#+END_SRC

**** time

What time is it?

#+BEGIN_SRC emacs-lisp
(use-package time
  :ensure nil
  :defer t
  :custom
  (display-time-format " %H:%M")
  (display-time-default-load-average nil))
#+END_SRC

**** whitespace-mode

#+BEGIN_SRC emacs-lisp
(defun wal/whitespace-mode ()
  "Hook into command `whitespace-mode'."
  (highlight-indent-guides-mode -1))

(use-package whitespace-mode
  :ensure nil
  :hook (whitespace-mode . wal/whitespace-mode)
  :general
  (wal/colonel "w" '(whitespace-mode :wk "whitespace")))
#+END_SRC

**** winner-mode

Allows restoring window configurations.

#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure nil
  :custom
  (winner-dont-bind-my-keys t)
  :general
  (wal/captain
    "w" '(:ignore t :wk "winner")
    "wu" '(winner-undo :wk "undo")
    "wr" '(winner-redo :wk "redo"))
  :config
  (winner-mode +1))
#+END_SRC

**** zone

Screen-saver.

Since this eats up a lot of CPU, the timer is disabled by
default but zoning can always be triggered using =C-z=.

#+BEGIN_SRC emacs-lisp
(defvar wal/zone-when-idle nil
  "Determine whether to zone out when idling.")

(defvar wal/zone-timer (* 5 60)
  "The time in seconds when we will zone out.")

(use-package zone
  :ensure nil
  :config
  (setq zone-programs [
                       zone-pgm-drip
                       zone-pgm-jitter
                       zone-pgm-dissolve
                       zone-pgm-rat-race
                       zone-pgm-whack-chars
                       ])
  (when wal/zone-when-idle
    (zone-when-idle wal/zone-timer))
  :bind
  ("C-z" . zone)) ; Replaces `suspend-frame'.
#+END_SRC

*** which-key

Show the next possible key presses towards an action.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :defer t
  :custom
  (which-key-lighter " wk?")
  (which-key-idle-delay 0.8)
  (which-key-idle-secondary-delay 0.4)
  :config
  (which-key-mode))
#+END_SRC

*** helpful

Let's try (to be) =helpful=.

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :after counsel
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  (counsel-describe-symbol-function #'helpful-symbol)
  :config
  (wal/display-buffer-in-direction 'helpful-mode)
  :general
  (wal/major :keymaps '(emacs-lisp-mode-map org-mode-map)
    "h"  '(helpful-at-point :wk "at point"))
  :bind
  (([remap describe-command] . helpful-command)
   ([remap describe-key] . helpful-key)
   ([remap describe-function] . counsel-describe-function)
   ([remap describe-variable] . counsel-describe-variable)
   ([remap describe-symbol] . counsel-describe-symbol)
   ([remap describe-face] . counsel-describe-face)))
#+END_SRC

*** dashboard

Let's have a dash of board.

#+BEGIN_SRC emacs-lisp
;; Using my GitLab status messages, only one so far.
(defvar wal/dashboard-footer-messages
  '("breaching your favorite stupid framework"
    "I propel myself forward on nothing but flukes"
    "devout and up the spout"
    "krill, filter feeders and hit sulphur bottom"
    "the founder of retiring gentlemen"
    "the loud keyboard shall vanquish the muscular mouse")
  "The footer messages I can stand to see.")

;; Ignore all files that were loaded on start-up.
(defvar wal/recentf-exclude
  (append (wal/directory-files wal/agenda-tasks-directory)
          (wal/directory-files wal/org-roam-directory)
          (wal/directory-files wal/cache-directory)
          (wal/directory-files user-emacs-directory))
  "Files that should not be considered recent files.")

(defun wal/advise-dashboard-insert-startupify-lists (fun &rest r)
  "Advise FUN to ignore certain directories, applying R."
  (let ((recentf-exclude wal/recentf-exclude))
    (apply fun r)))

(use-package dashboard
  :hook (after-init . dashboard-setup-startup-hook)
  :custom
  (dashboard-banner-logo-title (format "Walheimat's Emacs Config %s" (wal/get-config-version)))
  (dashboard-startup-banner (expand-file-name
                             "assets/logo.png"
                             wal/emacs-config-default-path))
  (dashboard-projects-backend 'projectile)
  (dashboard-items '((recents . 5)
                     (projects . 5)
                     (bookmarks . 5)))
  (dashboard-center-content t)
  (dashboard-set-file-icons t)
  (dashboard-set-navigator t)
  (dashboard-footer-icon ":whale:")
  (dashboard-footer-messages wal/dashboard-footer-messages)
  (dashboard-week-agenda nil)
  (dashboard-agenda-time-string-format "%d/%m/%y")
  :config
  (advice-add 'dashboard-insert-startupify-lists
              :around #'wal/advise-dashboard-insert-startupify-lists))
#+END_SRC

*** use-package-ensure-system-package

Ensure binaries.

#+BEGIN_SRC emacs-lisp
(use-package use-package-ensure-system-package
  :defer t)
#+END_SRC

*** restart-emacs

Sometimes I restart for fun.

#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :if (not (daemonp))
  :custom
  (restart-emacs-restore-frames nil)
  :general
  (wal/general "r" '(restart-emacs :wk "restart Emacs")))
#+END_SRC

*** async

It's currently mostly a dependency of other packages.

#+BEGIN_SRC emacs-lisp
(use-package async
  :defer 4
  :diminish 'dired-async-mode
  :config
  (dired-async-mode 1))
#+END_SRC

** Editing

It's fun to edit things /quickly/.

*** multiple-cursors

Don't you want to edit your buffer in multiple places at once?

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :init
  ;; Since the map is `nil', using `:bind' would fail.
  (setq mc/keymap (make-sparse-keymap))
  :custom
  (mc/always-run-for-all t)
  :general
  (wal/lieutenant
    "." '(:ignore t :wk "mc")
    ".a" '(mc/mark-all-like-this :wk "all like this")
    ".b" '(mc/edit-beginnings-of-lines :wk "beginnings (region)")
    ".e" '(mc/edit-ends-of-lines :wk "ends (region)"))
  :bind
  (("H-<mouse-3>" . mc/add-cursor-on-click)
   ("C-." . mc/mark-next-like-this)
   :map mc/keymap
   ("C-g" . mc/keyboard-quit) ; We keep this from the default map.
   ("C-," . mc/unmark-next-like-this)
   ("C-/" . mc/skip-to-next-like-this)))
#+END_SRC

*** crux

Let's use =crux= for some editing magic.
Check the [[*Key Bindings][key bindings section]] for descriptions.

#+BEGIN_SRC emacs-lisp
(use-package crux
  :general
  (wal/lieutenant
    "x" '(:ignore t :wk "crux")
    "xf" '(crux-recentf-find-file :wk "find recent file")
    "xr" '(crux-rename-file-and-buffer :wk "rename file and buffer")
    "xs" '(crux-sudo-edit :wk "sudo edit"))
  :bind
  (("M-o" . crux-other-window-or-switch-buffer)
   ("H-d" . crux-duplicate-current-line-or-region)
   ("C-S-k" . crux-kill-line-backwards)
   ("C-k" . crux-smart-kill-line)
   ("C-o" . crux-smart-open-line)
   ("C-S-o" . crux-smart-open-line-above)))
#+END_SRC

*** expand-region

One thing that can be a bit tricky is selecting regions, not anymore.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind
  (("C->" . er/expand-region)
   ("C-<" . er/contract-region)))
#+END_SRC

*** yasnippet

Use snippets in =prog= mode buffers.
Because I also use company, =yas-expand= is mapped to =H-<TAB>=.

#+BEGIN_SRC emacs-lisp
(defun wal/yas-expand ()
  "Call `yas-expand' in a `org-mode'-safe way.
Makes sure that indentation varialbes don't produce
unexepected results."
  (interactive)
  (let ((org-src-tab-acts-natively nil)
        (org-adapt-indentation nil))
    (yas-expand)))

(defun wal/yas-before-expand-snippet ()
  "Disable `company-idle-delay' before expansion."
  (when (and (boundp 'company-mode) company-mode)
    (setq-local company-idle-delay nil)))

(defun wal/yas-after-exit-snippet ()
  "Reset `company-idle-delay' after exiting snippet."
  (when (and (boundp 'company-mode) company-mode)
    (wal/reset-to-standard 'company-idle-delay t)))

(use-package yasnippet
  :delight " yas"
  :hook
  ((prog-mode . yas-minor-mode)
   (yas-before-expand-snippet . wal/yas-before-expand-snippet)
   (yas-after-exit-snippet . wal/yas-after-exit-snippet))
  :general
  (wal/colonel "y" '(yas-minor-mode :wk "yasnippet"))
  (wal/captain :keymaps 'yas-minor-mode-map
    "y" '(:ignore t :wk "yasnippet")
    "yv" '(yas-visit-snippet-file :wk "visit snippet file")
    "yn" '(yas-new-snippet :wk "create new snippet"))
  :bind
  (:map yas-minor-mode-map
   ("H-y" . #'wal/yas-expand))
  :config
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (yas-reload-all))

(use-package yasnippet-snippets
  :after yasnippet)
#+END_SRC

*** smartparens

I didn't have smart parens growing up so I need help.

#+BEGIN_SRC emacs-lisp
(defun wal/configure-smartparens ()
  "Configure `smartparens'."
  (add-to-list 'sp-lisp-modes 'lisp-data-mode)
  (sp-with-modes sp-lisp-modes
    (sp-local-pair "'" nil :actions nil))
  ;; Create a `hydra' for pair navigatino/editing.
  (defhydra wal/smartparens (:hint nil)
    "
%s(wal/ascii-whale-hydra-offset)   ^_p_^
%s`wal/ascii-whale _b_   _f_ Navigate pairs. Re_w_rap/_s_plice. Or _q_uit.
%s(wal/ascii-whale-hydra-offset)   ^_n_^
"
    ("b" sp-backward-sexp)
    ("f" sp-forward-sexp)
    ("p" sp-backward-up-sexp)
    ("n" sp-down-sexp)
    ("w" wal/sp-rewrap-sexp)
    ("s" sp-splice-sexp)
    ("q" nil)))

(defun wal/sp-rewrap-sexp ()
  "Call `sp--maybe-init' before `sp-rewrap-sexp'.
Advising the function does not work."
  (interactive)
  (unless (boundp 'smartparens)
    (require 'smartparens nil t))
  (with-current-buffer (current-buffer)
    (sp--maybe-init))
  (call-interactively 'sp-rewrap-sexp))

(use-package smartparens
  :defer t
  :config
  (wal/configure-smartparens)
  :general
  (wal/lieutenant :keymaps 'prog-mode-map
    "p" '(wal/smartparens/body :wk "smartparens")))
#+END_SRC

*** drag-stuff

Use the default key bindings.

#+BEGIN_SRC emacs-lisp
(use-package drag-stuff
  :delight " drg"
  :hook (prog-mode . drag-stuff-mode)
  :general
  (wal/colonel-sink "d" '(drag-stuff-mode :wk "drag-stuff"))
  :config
  (setq drag-stuff-modifier 'hyper)
  (drag-stuff-define-keys))
#+END_SRC

*** hungry-delete

I know you're hiding that sweet, sweet whitespace
in that basket, Little Red Riding Hood!

#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
  :delight " hun"
  :custom
  (hungry-delete-join-reluctantly t)
  :general
  (wal/colonel :keymaps 'prog-mode-map
    "h" '(hungry-delete-mode :wk "hungry delete")))
#+END_SRC

** Visuals

I like nice-looking things.

*** Themes

**** doom-themes

One of the nicest theme packages out there.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :defer t
  :config
  (doom-themes-org-config))
#+END_SRC

**** humanoid-themes

Very colorful.

#+BEGIN_SRC emacs-lisp
(use-package humanoid-themes
  :defer t)
#+END_SRC

**** kaolin-themes

This is a themes collection I sometimes pick from.

#+BEGIN_SRC emacs-lisp
(use-package kaolin-themes
  :defer t
  :custom
  (kaolin-themes-italic-comments t)
  (kaolin-themes-git-gutter-solid t)
  ;; Remove that `modeline' border.
  (kaolin-themes-modeline-border nil)
  ;; Distinct background for fringe and line numbers.
  (kaolin-themes-distinct-fringe t)
  ;; Distinct colors for company popup scrollbar.
  (kaolin-themes-distinct-company-scrollbar t)
  :config
  ;; Some packages use `treemacs'.
  (kaolin-treemacs-theme))
#+END_SRC

**** modus-themes

This is another themes collection with super configurable themes.

#+BEGIN_SRC emacs-lisp
(use-package modus-themes
  :defer t
  :custom
  (modus-themes-slanted-constructs t)
  (modus-themes-bold-constructs t)
  (modus-themes-mode-line 'borderless))
#+END_SRC

*** all-the-icons

You need to install the icons yourself[fn:4].
Packages =dired= and =ivy-rich= use and configure
their own sub-package.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :commands (all-the-icons-octicon)
  :defer t)
#+END_SRC

*** doom-modeline

Busier and prettier =modeline=.
/Note/ that this package requires you to install =all-the-icons= fonts[fn:4].

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :defer 0.5
  :custom
  (doom-modeline-project-detection 'projectile)
  (doom-modeline-minor-modes t)
  (doom-modeline-buffer-encoding nil)
  (doom-modeline-icon t)
  (doom-modeline-vcs-max-length 20)
  :config
  (doom-modeline-mode 1))
#+END_SRC

*** beacon

Help me find my cursor!

#+BEGIN_SRC emacs-lisp
(defun wal/configure-beacon ()
  "Configure `beacon' package."
  (add-to-list 'beacon-dont-blink-commands 'tab-to-tab-stop)
  (beacon-mode 1))

(use-package beacon
  :defer 3.25
  :config
  (wal/configure-beacon)
  :custom
  (beacon-blink-when-focused t)
  (beacon-color 0.4)
  (beacon-blink-duration 0.4)
  (beacon-blink-delay 0.2)
  (beacon-size 60)
  (beacon-blink-when-point-moves-vertically 2)
  (beacon-blink-when-point-moves-horizontally 8))
#+END_SRC

*** dimmer

Dim inactive frames.
Make dimmed frames a bit dimmer.

#+BEGIN_SRC emacs-lisp
;; Solution from buzztaiki https://github.com/gonewest818/dimmer.el/issues/49
(defun wal/lsp-ui-doc-frame-p ()
  "Check if buffer is a lsp-ui-doc frame buffer."
  (string-match-p "\\` \\*lsp-ui-doc" (buffer-name)))

(defun wal/advise-dimmer-config-change-handler ()
  "Advise to only force process if no predicate is truthy."
  (let ((ignore (cl-some (lambda (f) (and (fboundp f) (funcall f)))
                         dimmer-prevent-dimming-predicates)))
    (unless ignore
      (dimmer-process-all t))))

(defun wal/dimmer-configure-lsp-doc ()
  "Convenience settings for lsp-doc users."
  (add-to-list
   'dimmer-prevent-dimming-predicates
   #'wal/lsp-ui-doc-frame-p))

(use-package dimmer
  :defer 3
  :delight " dmm"
  :custom
  (dimmer-fraction 0.6)
  :config
  (advice-add 'dimmer-config-change-handler :override 'wal/advise-dimmer-config-change-handler)
  (dimmer-configure-company-box)
  (dimmer-configure-hydra)
  (dimmer-configure-magit)
  (dimmer-configure-org)
  (dimmer-configure-which-key)
  (wal/dimmer-configure-lsp-doc)
  (dimmer-mode t))
#+END_SRC

*** fira-code-mode

This mode allows us to use ligatures from FiraCode.
You don't need to use FiraCode as your main fixed font
for this to work but you should use =ligature= instead.

#+BEGIN_SRC emacs-lisp
(defun wal/use-fira-code-mode ()
  "Determine whether `fira-code-mode' can/should be used.
This is the case when:

1. We can't use `ligature'
2. The symbol font is installed
3. We're not using Monoid font"
  (and (not (require 'ligature nil t))
       (x-list-fonts "Fira Code Symbol")
       (not (string-match "Monoid" (face-font 'default)))))

(defun wal/fira-code ()
  "Wraps macro to only maybe enable."
  (use-package fira-code-mode
    :diminish
    ;; Use only if the code symbol font exists.
    :if (wal/use-fira-code-mode)
    :custom
    ;; Ligatures you don't want.
    (fira-code-mode-disabled-ligatures '("[]" "x"))
    :hook prog-mode))

;; We guard against font-related actions.
(if (daemonp)
    (add-hook 'server-after-make-frame-hook 'wal/fira-code t)
  (add-hook 'after-init-hook 'wal/fira-code t))
#+END_SRC

*** ligatures

This package is not on MELPA so you'll have to put it
in the load path.

#+BEGIN_SRC emacs-lisp
(use-package ligature
  :hook (prog-mode . ligature-mode)
  :load-path "site-lisp"
  :config
  ;; FIXME: This is still in progress.
  (ligature-set-ligatures 'prog-mode
                          '(">=" "<="  "+=" "-="
                            "||" "..." "??" "__"
                            "*/" "/*" "//" "/**"
                            "**/"))
  (ligature-set-ligatures 'lisp-data-mode '(";;"))
  (ligature-set-ligatures 'c++-mode
                          '("::" "->" ">>" "<<"
                            "++" "!=" "|=" "<<="
                            ">>=" "=="))
  (ligature-set-ligatures 'js2-mode
                          '("=>" "!==" "===" "!!"
                            "&&"))
  (ligature-set-ligatures 'elixir-mode '("|>" "#{" "\\\\"))
  (ligature-set-ligatures 'prolog-mode '(":-"))
  (ligature-set-ligatures 'html-mode '("<!--" "-->")))
#+END_SRC

*** diff-hl

Show diffs in the fringe (also in =dired= buffers).

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :defer 2.5
  :config
  (global-diff-hl-mode)
  :hook
  ((magit-post-refresh . diff-hl-magit-post-refresh)
   (dired-mode . diff-hl-dired-mode)))
#+END_SRC

*** delight

Refine a couple of major and minor mode names.

#+BEGIN_SRC emacs-lisp
(defvar wal/major-delight t
  "Whether some major modes are delighted beyond reason.")

(use-package delight
  :defer t
  :config
  (delight 'dired-mode "Dired" :major)
  (delight 'emacs-lisp-mode "Elisp" :major)
  (delight 'wdired-mode "DirEd" :major)
  (delight 'c++-mode "CPP" :major)
  (delight 'compilation-shell-minor-mode " csh" "compile")
  (delight 'abbrev-mode " abb" "abbrev")
  (delight 'auto-fill-function " aff" t)
  (delight 'with-editor-mode " w/e" "with-editor")
  ;; Only confuse/delight if allowed.
  (when wal/major-delight
    (delight 'elixir-mode "Homebrew" :major)
    (delight 'c++-mode "*&" :major)
    (delight 'python-mode "Snake" :major)
    (delight 'js2-mode "NaNsense" :major)
    (delight 'inferior-python-mode "Bite" :major)))
#+END_SRC

*** highlight-indent-guides

Show indentation.

#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :delight " hig"
  :custom
  (highlight-indent-guides-method 'character)
  (highlight-indent-guides-responsive 'top)
  :hook ((prog-mode yaml-mode) . highlight-indent-guides-mode)
  :general
  (wal/colonel :keymaps '(prog-mode-map yaml-mode-map)
    "i" '(highlight-indent-guides-mode :wk "highlight indent")))
#+END_SRC

*** highlight-numbers

Make numbers stand out.

#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers
  :hook (prog-mode . highlight-numbers-mode))
#+END_SRC

*** rainbow

Show colors in source code and make delimiters stand out.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))

(use-package rainbow-mode
  :defer t
  :delight " rbm")
#+END_SRC

*** hl-todo

Highlight =TODO=, =FIXME= etc. in =prog= modes.

#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :hook (prog-mode . hl-todo-mode)
  :general
  (wal/lieutenant-sink "t" '(hl-todo-insert :wk "insert todo")))
#+END_SRC

*** visual-fill-column

Makes presentations a bit nicer.

#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :defer t)
#+END_SRC

*** mode-line-bell

Make the bell visual.

#+BEGIN_SRC emacs-lisp
(use-package mode-line-bell
  :defer 3.5
  :custom
  (mode-line-bell-flash-time 0.1)
  :config
  (mode-line-bell-mode))
#+END_SRC

*** emojify

Display emojis.
You might have to call =emojify-download-emoji= to
download a set that supports your emojis.

#+BEGIN_SRC emacs-lisp
(use-package emojify
  :hook (dashboard-mode . emojify-mode)
  :general
  (wal/colonel "e" '(emojify-mode :wk "emojify")))
#+END_SRC

** Windows

Everything that has to do with windows.

*** ace-window

Allows for some nifty window swapping.

#+BEGIN_SRC emacs-lisp
(defun wal/aw-delete-window-kill-buffer (window)
  "Call `aw-delete-window' on WINDOW requesting buffer kill."
  (aw-delete-window window t))

(defun wal/advise-aw--switch-buffer (&rest r)
  "Call `wal/ivy-switch-buffer' with R instead."
  (wal/ivy-switch-buffer r))

(use-package ace-window
  :delight " ace"
  :custom
  (aw-fair-aspect-ratio 4)
  (aw-dispatch-always t)
  (aw-keys '(?j ?k ?l ?\; ?u ?i ?o ?p))
  (aw-ignored-buffers '(vterm-mode))
  :config
  (setq aw-dispatch-alist '((?h aw-split-window-horz "horizontal split")
                            (?v aw-split-window-vert "vertical split")
                            (?d aw-delete-window "delete")
                            (?x wal/aw-delete-window-kill-buffer "kill")
                            (?w delete-other-windows "delete other")
                            (?s aw-swap-window "swap")
                            (?m aw-move-window "move")
                            (?b aw-switch-buffer-in-window "switch focused")
                            (?o aw-switch-buffer-other-window "switch unfocused")
                            (?f aw-split-window-fair "fair split")
                            ;; If this has a description, it doesn't work.
                            (?? aw-show-dispatch-help)))
  (advice-add 'aw--switch-buffer :override #'wal/advise-aw--switch-buffer)
  :bind
  ("H-w" . ace-window))
#+END_SRC

*** golden-ratio

Use the golden ratio.

#+BEGIN_SRC emacs-lisp
(defun wal/aw-switch-maybe-golden-ratio (_window)
  "Invoke `golden-ratio' if mode is active.
Used to advise `aw-switch-to-window'."
  (when (eq golden-ratio-mode t)
    (golden-ratio)))

(use-package golden-ratio
  :delight " gol"
  :config
  ;; Make sure to run golden ratio after `aw-switch-to-window'.
  (advice-add 'aw-switch-to-window :after #'wal/aw-switch-maybe-golden-ratio)
  :general
  (wal/colonel "g" '(golden-ratio-mode :wk "golden ratio")))
#+END_SRC

*** popper

Accommodate =winner=.

#+BEGIN_SRC emacs-lisp
(defun wal/popper-toggle ()
  "Toggle latest or cycle when focusing pop-up."
  (interactive)
  (if (popper-popup-p (current-buffer))
      (popper-cycle)
    (popper-toggle-latest)))

(defun wal/popper-dead-shell-p ()
  "Check if the current buffer is a shell or comint pop-up with no process."
  (interactive)
  (let ((buf (current-buffer)))
    (with-current-buffer buf
      (and (popper-popup-p buf)
           (or (derived-mode-p 'shell-mode) (derived-mode-p 'comint-mode))
           (not (comint-check-proc buf))))))

(defun wal/popper-open-all ()
  "Same as `popper-open-all' but interactive."
  (interactive)
  (popper-open-all))

(use-package popper
  :after perspective
  :defer 1
  :bind
  (:map popper-mode-map
   ("H-e" . popper-toggle-latest)
   ("H-r" . popper-cycle))
  :general
  (wal/captain :keymaps 'popper-mode-map
    "e" '(:ignore t :wk "popper")
    "er" '(popper-toggle-type :wk "raise or drop")
    "ek" '(popper-kill-latest-popup :wk "kill latest")
    "ea" '(wal/popper-open-all :wk "open all"))
  (general-define-key
   :keymaps 'popper-mode-map
   :predicate '(wal/popper-dead-shell-p)
   "q" 'kill-buffer-and-window)
  :custom
  ;; Prime candidates for `popper' are those shown in-direction and in-side.
  (popper-reference-buffers '(docker-container-mode
                              debugger-mode
                              "\\*Bookmark Annotation\\*"
                              "\\*org-roam\\*"
                              ;; Shell(-like).
                              "*eshell*"
                              "\\*poetry-shell\\*"
                              "^\\*docker-compose"
                              "^\\* docker"
                              dap-ui-repl-mode
                              inferior-python-mode
                              ;; Help(-like).
                              helpful-mode
                              help-mode
                              dictionary-mode
                              shortdoc-mode))
  (popper-group-function #'popper-group-by-perspective)
  (popper-display-control 'user)
  ;; Remove if you don't use/have `doom-modeline'.
  (popper-mode-line '(:eval (concat
                             " "
                             (doom-modeline-icon 'faicon "fort-awesome" nil nil
                                                 :face 'all-the-icons-dsilver
                                                 :height 0.9
                                                 :v-adjust 0.0)
                             " ")))
  :config
  (popper-mode +1))
#+END_SRC

** Movement

Moving around should be fun.

*** avy

Jumping to (visible) lines and chars is fun if you are too lazy to use your mouse.

#+BEGIN_SRC emacs-lisp
(defun wal/avy-goto-line-and-char ()
  "Go to line and then to char in line.
Just goes to line if line is empty."
  (interactive)
  (avy-goto-line)
  (let ((line-length (save-excursion (end-of-line) (current-column))))
    (unless (zerop line-length)
      (let ((char (read-char "char: " t)))
        (avy-goto-char-in-line char)))))

(use-package avy
  :custom
  (avy-background t)
  (avy-ignored-modes '(image-mode
                       doc-view-mode
                       pdf-view-mode
                       shell-mode
                       vterm-mode))
  :bind
  (("H-l" . avy-goto-line)
   ("H-L" . wal/avy-goto-line-and-char)
   ("H-o" . avy-goto-word-1)
   ("H-O" . avy-goto-word-0))
  :general
  (wal/lieutenant
    ;; Lines.
    "l" '(:ignore t :wk "avy (line)")
    "lc" '(avy-copy-line :wk "copy")
    "lk" '(avy-kill-whole-line :wk "kill")
    "lm" '(avy-move-line :wk "move")
    ;; Region.
    "r" '(:ignore t :wk "avy (region)")
    "rc" '(avy-copy-region :wk "copy")
    "rk" '(avy-kill-region :wk "kill")
    "rm" '(avy-move-region :wk "move")))
#+END_SRC

*** mwim

Move where I want.
Useful for comments.

#+BEGIN_SRC emacs-lisp
(use-package mwim
  :bind
  (("C-a" . mwim-beginning)
   ("C-e" . mwim-end)))
#+END_SRC

*** consult

More useful replacements and extensions.
We have do advise some of the functions to play
nice despite us using =ivy= for completion everywhere.

#+BEGIN_SRC emacs-lisp
(use-package consult
  :custom
  (consult-project-root-function #'projectile-project-root)
  :init
  (setq xref-show-definitions-function #'consult-xref)
  :bind
  (("M-g g" . consult-goto-line)
   ("M-g M-m" . consult-global-mark))
  :config
  ;; Advise functions to use `selectrum' when `ivy' behaves unpredictably.
  (mapc (lambda (it)
          (advice-add it :around #'wal/advise-selectrum))
        '(consult-buffer
          consult-focus-lines
          consult-flymake
          consult-global-mark
          consult-grep
          consult-minor-mode-menu
          consult-mode-command
          consult-xref
          consult-recent-file
          consult-outline))
  :general
  (wal/major-sink "c" '(consult-mode-command :wk "invoke mode command"))
  (wal/major :keymaps 'org-mode-map
    "j" '(consult-outline :wk "jump to heading"))
  (wal/lieutenant
    "u" '(:ignore t :wk "consult")
    "uf" '(consult-recent-file :wk "open recent")
    "ul" '(consult-focus-lines :wk "focus lines")))

(use-package consult-flycheck
  :after (consult flycheck)
  :config
  (advice-add 'consult-flycheck :around #'wal/advise-selectrum))
#+END_SRC

** Finding Things

I mostly search.

*** ag

Highlight search results using the *Silver Searcher*.

This package /requires/ the =ag= binary which you can get from [[https://github.com/ggreer/the_silver_searcher#installation][here]][fn:12].

#+BEGIN_SRC emacs-lisp
(use-package ag
  :config
  (wal/display-buffer-in-pop-up "*ag search*")
  :ensure-system-package ag
  :custom
  (ag-highlight-search t)
  (ag-reuse-buffers t)
  ;; Include hidden files. We ignore only specific dirs.
  (ag-arguments '("--smart-case" "--stats" "--hidden"))
  (ag-ignore-list '(".git"
                    ".idea"
                    ".ccls-cache"
                    ".vscode"
                    "node_modules"
                    "coverage"
                    "deps"
                    "dist"
                    "build"
                    "*.svg"
                    "*.min.js"))
  :bind ("H-a" . ag)
  :general
  (wal/lieutenant
    "a" '(:ignore t :wk "ag")
    "at" '(ag-files :wk "by file-type")
    "ap" '(ag-project :wk "in project")
    "af" '(ag-dired :wk "for file")))
#+END_SRC

*** ctrlf

Replacement for =isearch=.
Important command is =C-o s= to change search style.

#+BEGIN_SRC emacs-lisp
(defvar wal/ctrlf-cancel-commands
  '(ace-window
    other-window
    crux-other-window-or-switch-buffer)
  "Commands that are remapped to `ctrlf-cancel'.
Commands that unfocus the ctrlf minibuffer should quit it.")

(use-package ctrlf
  :defer 3
  :custom
  (ctrlf-auto-recenter t)
  (ctrlf-show-match-count-at-eol nil)
  (ctrlf-default-search-style 'fuzzy)
  (ctrlf-alternate-search-style 'literal)
  :config
  (mapc (lambda (it)
          (add-to-list
           'ctrlf-minibuffer-bindings
           `([remap ,it] . ctrlf-cancel)))
        wal/ctrlf-cancel-commands)
  (ctrlf-mode +1))
#+END_SRC

*** dumb-jump

Better definition look-up when no LSP is already doing it.
Configure it for =ivy= and =ag=.
Jumping is done using =xref-find-definitions= (=M-.=).

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :defer t
  :custom
  (dumb-jump-selector 'ivy)
  (dumb-jump-force-searcher 'ag)
  :init
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+END_SRC

** Completion

You complete me.

*** ivy

We use =ivy= for narrowing our options.

#+BEGIN_SRC emacs-lisp
(defun wal/ivy-switch-ignored-buffers (&rest r)
  "Show only commonly ignored buffers.
Pass R to the switch buffer function."
  (interactive)
  (let ((ivy-ignore-buffers
         '((lambda (buffer-or-string)
             (not (wal/commmonly-ignored-buffer-p buffer-or-string))))))
    (wal/ivy-switch-buffer r)))

;; Change to `ivy-switch-buffer' if you don't use `perspective' and `counsel'.
(defalias 'wal/ivy-switch-buffer 'persp-counsel-switch-buffer)

;; Hide `dired', `docker', `ag' and default Emacs buffers when switching.
(defvar wal/ivy-ignore-buffers
  '(wal/commmonly-ignored-buffer-p
    "\\` "
    "\\`\\*tramp/")
  "Buffers that are commonly ignored when switching.")

(use-package ivy
  :defer 1.5
  :custom
  (ivy-use-virtual-buffers t)
  (ivy-ignore-buffers wal/ivy-ignore-buffers)
  (ivy-count-format "%d/%d ")
  (ivy-wrap t)
  :config
  (setq enable-recursive-minibuffers t)
  (ivy-mode 1)
  :bind
  (:map ivy-mode-map
   ("C-x b" . wal/ivy-switch-buffer)
   ;; Replaces `list-buffers'.
   ("C-x C-b" . wal/ivy-switch-ignored-buffers)))
#+END_SRC

**** ivy-avy

Using =avy= inside =ivy=.

#+BEGIN_SRC emacs-lisp
(use-package ivy-avy
  :after ivy
  :bind
  (:map ivy-minibuffer-map
   ("H-l" . ivy-avy)))
#+END_SRC

**** ivy-rich

Some nicer candidate view when switching buffers.

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :after ivy
  :demand
  :config
  (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
  (ivy-rich-mode 1))

(use-package all-the-icons-ivy-rich
  :after ivy-rich
  :config
  ;; Prettify some additional functions.
  (mapc (lambda (it)
          (plist-put all-the-icons-ivy-rich-display-transformers-list it
                     '(:columns
                       ((all-the-icons-ivy-rich-file-icon)
                        (ivy-rich-candidate))
                       :delimiter "\t")))
        '(counsel-projectile-switch-to-buffer
          persp-kill-buffer*
          persp-add-buffer ; This one doesn't seem to work ...
          persp-remove-buffer
          crux-recentf-find-file))
  (all-the-icons-ivy-rich-mode 1)
  (add-hook 'after-init-hook #'all-the-icons-ivy-rich-reload))
#+END_SRC

*** counsel

=counsel= me this, Counselor.

#+BEGIN_SRC emacs-lisp
;; `prescient' is defined later, so we have to define it here.
(defvar wal/use-prescient t
  "Whether `prescient' is used.")

(use-package counsel
  :after ivy
  :demand
  :custom
  (counsel-linux-app-format-function #'counsel-linux-app-format-function-command-only)
  :config
  ;; Package ivy-prescient sets `ivy-initial-inputs-alist' to nil!
  (unless wal/use-prescient
    (setcdr (assq 'counsel-M-x ivy-initial-inputs-alist) ""))
  :general
  (wal/general
    "t" '(counsel-load-theme :wk "load theme")
    "h" '(counsel-command-history :wk "show command history")
    "l" '(counsel-find-library :wk "find library")
    "v" '(counsel-set-variable :wk "set variable"))
  (wal/lieutenant
    "o" '(:ignore t :wk "counsel")
    "os" '(counsel-search :wk "search")
    "ox" '(counsel-find-file-extern :wk "(external) find file")
    "ol" '(counsel-linux-app :wk "Linux app"))
  :bind
  (:map ivy-mode-map
   ("M-g m" . counsel-mark-ring)
   ("H-g" . counsel-mark-ring)
   ("M-x" . counsel-M-x)
   ("<menu>" . counsel-M-x)
   ("C-x C-f" . counsel-find-file)
   :map bookmark-map
   ("b" . counsel-bookmark)))
#+END_SRC

*** company

Code completion in a box.

#+BEGIN_SRC emacs-lisp
(use-package company
  :delight " cmp"
  :general
  (wal/colonel :keymaps '(prog-mode-map dap-ui-repl-mode-map)
    "c" '(company-mode :wk "company"))
  :custom
  (company-idle-delay 0.4) ;; Bigger/smaller delays should be set by modes.
  :hook (prog-mode . company-mode)
  :bind
  (:map company-mode-map
   ("H-c" . company-complete)))

(use-package company-box
  :diminish
  :hook (company-mode . company-box-mode))
#+END_SRC

*** prescient

Better short-term-memory for =ivy=.

#+BEGIN_SRC emacs-lisp
(use-package prescient
  :after counsel
  :if wal/use-prescient
  :custom
  (prescient-sort-length-enable nil)
  (prescient-save-file (expand-file-name "prescient-persist" wal/cache-directory))
  (prescient-filter-method '(literal regexp))
  :config
  (prescient-persist-mode +1))

(use-package ivy-prescient
  :if wal/use-prescient
  :after (counsel prescient)
  :custom
  (ivy-prescient-retain-classic-highlighting t)
  :config
  (ivy-prescient-mode +1))
#+END_SRC

*** selectrum

A potential =ivy= replacement.
Sunken cost thinking prevents a switch for now
but we still use it to advise a few =consult= functions.

#+BEGIN_SRC emacs-lisp
(defun wal/advise-selectrum(fun &rest r)
  "Call FUN using `selectrum' for read completion, applying R."
  (let ((completing-read-function #'selectrum-completing-read)
        (read-buffer-function #'selectrum-read-buffer)
        (read-file-name-function #'selectrum-read-file-name)
        (completion-in-region-function #'selectrum-completion-in-region)
        (coompleting-read-multiple #'selectrum-completing-read-multiple)
        (read-libary-name #'selectrum-read-libarary-name)
        (completion-styles '(substring partial-completion))
        ;; Cannot advise `dired-read-dir-and-switches' and `minibuffer-message'.
        (map (make-sparse-keymap)))
    (set-keymap-parent map minibuffer-local-map)
    (define-key map [remap previous-matching-history-element] 'selectrum-select-from-history)
    (apply fun r)))

(use-package selectrum
  :defer t)
#+END_SRC

** Workspace

Everything workspace-related.

*** perspective

Have some perspective, man.

#+BEGIN_SRC emacs-lisp
(defvar wal/default-perspective
  "walheimat"
  "The name of my default perspective.")

(defun wal/advise-persp-kill (fun &rest r)
  "Advises FUN to kill processes without querying, applying R.
This only removes `process-kill-buffer-query-function'."
  (let ((kill-buffer-query-functions (delq 'process-kill-buffer-query-function
                                           kill-buffer-query-functions)))
    (apply fun r)))

(use-package perspective
  :defer 0.25
  :hook (kill-emacs . persp-state-save)
  :custom
  (persp-modestring-dividers '(" (" ")" "/")) ;; Add space for `doom-modeline'.
  (persp-initial-frame-name wal/default-perspective)
  (persp-state-default-file (expand-file-name "persp-persist" wal/cache-directory))
  (persp-mode-prefix-key (kbd "C-c i"))
  :config
  (advice-add 'persp-kill :around #'wal/advise-persp-kill)
  (persp-mode)
  :bind
  (:map persp-mode-map
   ("H-i" . persp-switch)
   ("C-x k" . persp-kill-buffer*)
   ("C-x K" . all-the-icons-ivy-rich-kill-buffer)))
#+END_SRC

*** projectile

Projects in Emacs.

#+BEGIN_SRC emacs-lisp
(defvar wal/projectile-globally-ignored-directories nil
  "Additional directories to ignore.")

(defvar wal/projectile-globally-ignored-files
  '("yarn.lock" "package.lock" "bundle.js")
  "Additional files to ignore.")

(defvar wal/projectile-globally-ignored-file-suffixes
  '(".min.js")
  "Additional file suffixes to ignore.")

(use-package projectile
  :defer 0.75
  :delight " pjt"
  :bind
  (:map projectile-mode-map
   ("H-p" . projectile-switch-project))
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :custom
  (projectile-completion-system 'ivy)
  (projectile-switch-project-action #'projectile-dired)
  (projectile-sort-order 'recentf)
  ;; Allow finding files that are ignored by `.gitignore'.
  (projectile-indexing-method 'hybrid)
  (projectile-enable-caching t)
  :config
  (mapc (lambda (it)
          (add-to-list 'projectile-globally-ignored-directories it))
        wal/projectile-globally-ignored-directories)
  (mapc (lambda (it)
          (add-to-list 'projectile-globally-ignored-files it))
        wal/projectile-globally-ignored-files)
  (mapc (lambda (it)
          (add-to-list 'projectile-globally-ignored-file-suffixes it))
        wal/projectile-globally-ignored-file-suffixes)
  (projectile-mode +1))
#+END_SRC

**** counsel-projectile

Add =counsel= integration to =projectile=.

#+BEGIN_SRC emacs-lisp
(defun wal/advise-counsel-projectile-ag-around (fun &rest r)
  "Call `counsel-ag' not FUN with R outside of projects.
This eliminates getting prompted to open one first"
  (if (projectile-project-p)
      (apply fun r)
    (apply 'counsel-ag r)))

(defun wal/advise-counsel-projectile-ag-override (&optional options)
  "Override of `counsel-projectile-ag' with same OPTIONS.
The differences being that:
  (1) we call `counsel-ag' if we're not in a project and
  (2) we don't call `shell-quote-argument' on the ignored arguments which doesn't seem to work."
  (interactive)
  (if (and (eq projectile-require-project-root 'prompt)
           (not (projectile-project-p)))
      (counsel-ag options)
    (let* ((ivy--actions-list (copy-sequence ivy--actions-list))
           (ignored
            (mapconcat (lambda (i)
                         (concat "--ignore " i))
                       (append
                        (projectile--globally-ignored-file-suffixes-glob)
                        (projectile-ignored-files-rel)
                        (projectile-ignored-directories-rel))
                       " "))
           (counsel-ag-base-command
            (let ((counsel-ag-command counsel-ag-base-command))
              (counsel--format-ag-command ignored "%s"))))
      (ivy-add-actions
       'counsel-ag
       counsel-projectile-ag-extra-actions)
      (when (= (prefix-numeric-value current-prefix-arg) 4)
        (setq current-prefix-arg '(16)))
      (counsel-ag (eval counsel-projectile-ag-initial-input)
                  (projectile-project-root)
                  options
                  (projectile-prepend-project-name
                   (concat (car (if (listp counsel-ag-base-command)
                                    counsel-ag-base-command
                                  (split-string counsel-ag-base-command)))
                           ": "))))))

(use-package counsel-projectile
  :after (projectile counsel)
  :demand
  :custom
  (counsel-projectile-preview-buffers t)
  (counsel-projectile-org-capture-templates
     ;; Reminders are stored relative to the project root
   `(("r" "[${name}] reminder" entry
      (file+headline "${root}/reminders.org" "Reminders")
      "* TODO %?\n%i\n%U -- %a")
     ;; Tasks are stored in the common task directory
     ("t" "[${name}] task" entry
      (file+headline ,(expand-file-name "${name}.org" wal/agenda-tasks-directory) "Tasks")
      "* TODO %?")
     ("n" "[${name}] note" entry
      (file+olp+datetree "${root}/notes.org")
      "* %?")))
  :config
  ;; Make opening with `dired' the default action.
  (setf (nth 0 counsel-projectile-switch-project-action) 4)
  ;; (advice-add 'counsel-projectile-ag :around #'wal/advise-counsel-projectile-ag-around)
  (advice-add 'counsel-projectile-ag :override #'wal/advise-counsel-projectile-ag-override)
  (counsel-projectile-mode +1)
  :bind
  (:map projectile-mode-map
   ("H-f" . counsel-projectile-find-file)
   ("H-F" . counsel-projectile-find-dir)
   ("H-n" . counsel-projectile-org-capture)
   ("H-s" . counsel-projectile-ag)))
#+END_SRC

** Org

The best thing about Emacs. Check out the [[https://orgmode.org/manual/][manual]].
This configuration is a bit elaborate.

#+BEGIN_SRC emacs-lisp
(defun wal/org-mode ()
  "Hook into `org-mode'."
  (message "Organize! Seize the means of production!")
  ;; Since `9.4' org tries to please `electric-indent'.
  ;; (electric-indent-local-mode -1)
  (wal/disable-tabs)
  (hack-local-variables))

(defun wal/advise-org-export-dispatch (&rest _r)
  "Advise to require `ox-md' export dispatch."
  (require 'ox-md nil t))

(defun wal/configure-org ()
  "Configure `org'."
  (define-key org-mode-map (kbd "C-,") nil) ; Remove `org-cycle-agenda-files'.
  (advice-add 'org-export-dispatch :before #'wal/advise-org-export-dispatch))

(defun wal/org-content (level)
  "Interactively call `org-content' with LEVEL."
  (interactive "nShow content up to level: ")
  (org-content level))

(use-package org
  :ensure nil
  :hook (org-mode . wal/org-mode)
  :config
  (wal/configure-org)
  :custom
  (org-adapt-indentation nil) ; Defaults to `t' nowadays ...
  (org-ellipsis "")
  (org-hide-emphasis-markers t)
  (org-log-done 'time)
  (org-directory wal/org-directory)
  (org-default-notes-file (concat org-directory "/notes.org"))
  (org-agenda-files `(,wal/agenda-tasks-directory))
  (org-startup-with-inline-images t)
  ;; Be sure to add archive tag with `org-toggle-archive-tag'.
  (org-archive-location "::* Archived")
  ;; Too many clock entries clutter up a heading.
  (org-log-into-drawer t)
  (org-todo-keywords
   '((sequence "TODO(t)" "IN PROGRESS(p)" "WAITING(w)" "BLOCKED (b)" "|" "DONE(d)" "CANCELED(c)")))
  (org-tag-alist
   '(;; Depth.
     ("@immersive" . ?i)
     ("@process" . ?p)
     ;; Context.
     ("@work" . ?w)
     ("@home" . ?h)
     ("@away" . ?a)
     ("@repeated" . ?r)
     ;; Time.
     ("@short" . ?<)
     ("@medium" . ?=)
     ("@long" . ?>)
     ;; Energy.
     ("@easy" . ?1)
     ("@average" . ?2)
     ("@challenge" . ?3)
     ;; Category.
     ("@dev" . ?d)
     ("@bla" . ?b)
     ("@edu" . ?e)))
  :general
  (wal/major :keymaps 'org-mode-map
    "s" '(:ignore t :wk "subtree")
    "sw" '(org-cut-subtree :wk "cut subtree")
    "sy" '(org-paste-subtree :wk "paste subtree")
    "e" '(org-edit-src-code :wk "edit source code")
    "n" '(org-add-note :wk "add note")
    "a" '(org-show-all :wk "show all")
    "l" '(wal/org-content :wk "show level")
    "f" '(:ignore t :wk "footnotes")
    "fc" '(org-footnote-new :wk "create")
    "fn" '(org-footnote-normalize :wk "normalize"))
  (wal/colonel :keymaps 'org-mode-map
    "i" '(org-indent-mode :wk "org-indent")))
#+END_SRC

*** Agendas

Everything concerning agendas.

This is mostly based on [[https://github.com/mwfogleman/.emacs.d/blob/master/michael.org][mwfogleman]]'s Emacs config.

#+BEGIN_SRC emacs-lisp
(use-package org-agenda
  :ensure nil
  :custom
  (org-agenda-hide-tags-regexp "^@")
  (org-agenda-span 'day)
  (org-agenda-restore-windows-after-quit t)
  (org-agenda-time-leading-zero t)
  :bind
  ("C-c a" . org-agenda))
#+END_SRC

**** org-super-agenda

Nice agendas.

#+BEGIN_SRC emacs-lisp
(defvar wal/org-super-agenda-groups
  '((:name "Schedule"
           :time-grid t)
    (:name "Unscheduled"
           :scheduled nil)
    (:name "Leftovers"
           :and (:todo ("IN PROGRESS" "WAITING")
                       :scheduled past
                       :not (:tag "@repeated")))
    (:name "Blocked"
           :todo ("BLOCKED"))
    (:discard (:anything t)))
  "The super agenda groups.")

(use-package org-super-agenda
  :after org-agenda
  :demand
  :custom
  (org-super-agenda-groups wal/org-super-agenda-groups)
  :config
  (org-super-agenda-mode)
  :general
  (wal/major :keymaps 'org-agenda-keymap
    "w" '(org-agenda-write :wk "write")))
#+END_SRC

*** Presentations

Packages I use to prettify presentations.

**** mixed-pitch

Used for the next package.

#+BEGIN_SRC emacs-lisp
(use-package mixed-pitch
  :defer t
  :delight " mpm"
  :custom
  (mixed-pitch-variable-pitch-cursor nil)
  (mixed-pitch-fixed-pitch-faces '(org-code
                                   org-block
                                   org-verbatim
                                   org-table)))
#+END_SRC

**** org-tree-slide

Presentations.

#+BEGIN_SRC emacs-lisp
(defvar wal/org-tree-slide-visual-fill-column-width 160
  "The base `visual-fill-column-width' for `org-tree-slide' presentations.")

(defun wal/relative-column-width (&optional target-width)
  "Get the relative column width of TARGET-WIDTH."
  (let ((width (or target-width 160))
         (scale (if (and (boundp 'text-scale-mode-amount)
                         (numberp text-scale-mode-amount))
                    (expt text-scale-mode-step text-scale-mode-amount)
                  1)))
    (ceiling (/ width scale))))

(defun wal/org-tree-slide-toggle-visibility ()
  "Toggle visibility of cursor."
  (interactive)
  (if cursor-type
      (setq cursor-type nil)
    (setq cursor-type t)))

(defun wal/org-tree-slide-play ()
  "Hook into `org-tree-slide-play'."
  (setq visual-fill-column-width (wal/relative-column-width
                                  wal/org-tree-slide-visual-fill-column-width)
        visual-fill-column-center-text t
        cursor-type nil)
  (beacon-mode -1)
  (visual-fill-column-mode 1)
  (mixed-pitch-mode +1))

(defun wal/org-tree-slide-stop ()
  "Hook into `org-tree-slide-stop'."
  (setq visual-fill-column-width nil
        visual-fill-column-center-text nil
        cursor-type t)
  (beacon-mode 1)
  (visual-fill-column-mode -1)
  (outline-show-all)
  (mixed-pitch-mode -1))

(defun wal/org-tree-slide-text-scale ()
  "Hook into `text-scale-mode-hook' for `org-tree-slide'."
  (when (and (boundp 'org-tree-slide-mode) org-tree-slide-mode)
    (wal/org-tree-slide-play)))

(use-package org-tree-slide
  :custom
  (org-tree-slide-never-touch-face t)
  (org-tree-slide-cursor-init nil)
  (org-tree-slide-activate-message "We're on a road to nowhere")
  (org-tree-slide-deactivate-message "Take you here, take you there")
  (org-tree-slide-indicator '(:next "   >>>" :previous "<<<" :content "< Here is where time is on our side >"))
  :diminish buffer-face-mode
  :hook
  ((org-tree-slide-play . wal/org-tree-slide-play)
   (org-tree-slide-stop . wal/org-tree-slide-stop)
   (text-scale-mode . wal/org-tree-slide-text-scale))
  :general
  (wal/major :keymaps 'org-mode-map
    "p" '(org-tree-slide-mode :wk "presentation"))
  :bind
  (:map org-tree-slide-mode-map
   ("q" . org-tree-slide-mode) ; To close it again.
   ("n" . org-tree-slide-move-next-tree)
   ("p" . org-tree-slide-move-previous-tree)
   ("i" . text-scale-increase)
   ("d" . text-scale-decrease)
   ("v" . wal/org-tree-slide-toggle-visibility)))
#+END_SRC

*** Zettelkasten

Trying to organize my thoughts using Zettelksten.
/Note/ that you will need to install =sqlite3= and =graphviz= manually.

#+BEGIN_SRC emacs-lisp
(defvar wal/org-roam-dailies-directory "tagebuch/"
  "The directory for dailies.")

(use-package org-roam
  :if (executable-find "sqlite3")
  :commands
  (org-roam-buffer-display-dedicated
   org-roam-capture
   org-roam-node-create
   org-roam-node-find
   org-roam-node-read)
  :custom
  (org-roam-completion-system 'ivy)
  (org-roam-directory wal/org-roam-directory)
  (org-roam-dailies-directory wal/org-roam-dailies-directory)
  :general
  (wal/lieutenant
    "z" '(:ignore t :wk "roam")
    "zf" '(org-roam-node-find :wk "find")
    "zc" '(org-roam-capture :wk "capture")
    "zr" '(org-roam-buffer-display-dedicated :wk "roam buffer"))
  (wal/lieutenant :keymaps 'org-mode-map
    "zi" '(org-roam-node-insert :wk "insert node"))
  (wal/lieutenant :keymaps 'org-roam-mode-map
    "zg" '(org-roam-graph :wk "write graph"))
  :config
  (org-roam-setup)
  (wal/lieutenant
    "zd" '(org-roam-dailies-goto-date :wk "dailies")))
#+END_SRC

*** Other Packages

Configurations of sub-packages.

**** Internal

***** org-capture

Capturing is mainly done using =counsel-projectile=
but there are some global templates.

#+BEGIN_SRC emacs-lisp
(use-package org-capture
  :ensure nil
  :after org
  :defer t
  :delight " cap"
  :custom
  (org-capture-templates
   `(("m" "meeting" entry (file+olp+datetree ,(concat org-directory "/meetings.org")) "* %?")
     ("d" "daily" plain (file+olp+datetree ,(concat org-directory "/dailies.org")) "%i\n%?")))
  ;; This leads to endless edit buffers opening since we annotate bookmarks
  (org-capture-bookmark nil))
#+END_SRC

***** org-src

Editing source blocks.

#+BEGIN_SRC emacs-lisp
(defvar wal/org-src-lang-modes
  '(("dockerfile" . dockerfile)
    ("conf" . conf)
    ("markdown" . markdown))
  "Additional mappings to add to `org-src-lang-modes'.")

(defun wal/org-src-mode ()
  "Hook into function `org-src-mode'."
  (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

(use-package org-src
  :ensure nil
  :after org
  :delight " osc"
  :hook (org-src-mode . wal/org-src-mode)
  :custom
  (org-src-tab-acts-natively nil) ; Defaults to `t' nowadays.
  (org-edit-src-content-indentation 0) ; Defaults to `2' nowadays.
  :config
  (mapc (lambda (it)
          (add-to-list 'org-src-lang-modes it))
        wal/org-src-lang-modes)
  :bind
  (:map org-src-mode-map
   ("C-c C-c" . org-edit-src-exit)))
#+END_SRC

***** org-clock

You know the drill. Clock in, clock out.

#+BEGIN_SRC emacs-lisp
(use-package org-clock
  :ensure nil
  :after org
  :custom
  (org-clock-idle-time 10)
  (org-clock-continuously t)
  (org-clock-persist t)
  (org-clock-in-switch-to-state "IN PROGRESS")
  (org-clock-in-resume t)
  (org-clock-report-include-clocking-task t)
  (org-clock-out-remove-zero-time-clocks t)
  (org-clock-into-drawer t))
#+END_SRC

***** org-keys

#+BEGIN_SRC emacs-lisp
(use-package org-keys
  :ensure nil
  :after org
  :custom
  (org-use-speed-commands t)
  (org-speed-commands-user
   '(("w" widen)
     ("n" org-narrow-to-subtree)
     ;; Defaults are I and O.
     ("i" org-clock-in)
     ("o" org-clock-out)
     ("a" org-archive-subtree)
     ("r" org-clock-report))))
#+END_SRC

**** External

***** org-bullets

Prettier headlines.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :after org
  :custom
  (org-bullets-bullet-list '("" "" "" "" "" "" ""))
  :hook (org-mode . org-bullets-mode))
#+END_SRC

** Dired

Group directories first in =dired=,
override some keybindings.

Did you know you can edit =dired= buffers using =C-x C-q=?

Run =dired= with =C-x d=.

#+BEGIN_SRC emacs-lisp
(defun wal/dired-from-home (dirname &optional switches)
  "Open DIRNAME local to HOME directory.
Uses the same optional SWITCHES."
  (interactive (let ((default-directory "~"))
                 (require 'dired nil t)
                 (dired-read-dir-and-switches "")))
  (pop-to-buffer-same-window (dired-noselect dirname switches)))

(defun wal/image-dired ()
 "Run `image-dired' in the `default-directory'."
 (interactive)
 (image-dired (expand-file-name default-directory)))

(use-package dired
  :ensure nil
  :config
  (put 'dired-find-alternate-file 'disabled nil)
  :custom
  (dired-listing-switches "-lah --group-directories-first")
  (dired-auto-revert-buffer t)
  (dired-kill-when-opening-new-dired-buffer t) ;; New in Emacs 28.1.
  :general
  (wal/major :keymaps 'dired-mode-map
    "e" '(dired-create-empty-file :wk "create empty file")
    "i" '(wal/image-dired :wk "show images"))
  :bind
  (("C-x j" . dired-jump-other-window)
   ("C-x D" . wal/dired-from-home)
   :map dired-mode-map
   ("." . dired-up-directory) ; Overrides `dired-clean-directory'.
   ("," . dired-display-file)))

;; Use it for dired.
(use-package all-the-icons-dired
  :after all-the-icons
  :diminish
  :hook (dired-mode . all-the-icons-dired-mode))

;; Hit `/' to filter in dired buffers.
(use-package dired-filter
  :after dired
  :delight " def")

;; Highlighting in dired buffers.
(use-package diredfl
  :after dired
  :config
  (diredfl-global-mode))

(use-package wdired
  :ensure nil
  :custom
  (wdired-allow-to-change-permissions t)
  :bind
  (:map wdired-mode-map
   ("C-c C-k" . wdired-abort-changes)))
#+END_SRC

** Terminal

#+BEGIN_QUOTE
I am convinced that we are in a terminal process.
 E. P. Thompson
#+END_QUOTE

*** vterm

Better[fn:13] than included shells.

#+BEGIN_SRC emacs-lisp
(defun wal/vterm-mode ()
  "Adjustments for `vterm'."
  (ctrlf-local-mode -1))

(use-package vterm
  :hook (vterm-mode . wal/vterm-mode)
  :delight
  (vterm-copy-mode " vcp")
  :custom
  (vterm-kill-buffer-on-exit t)
  :config
  (wal/display-buffer-in-side-window (concat "\\" vterm-buffer-name) nil nil t))

(defun wal/advise-vterm-toggle (&rest _r)
  "Advise `vterm-toggle' to show unless the window is a vterm buffer."
  (unless (derived-mode-p 'vterm-mode)
    (vterm-toggle-show)))

(use-package vterm-toggle
  :custom
  (vterm-toggle-fullscreen-p nil)
  (vterm-toggle-scope 'project)
  :config
  (advice-add 'vterm-toggle :before-until #'wal/advise-vterm-toggle)
  :bind
  ("H-t" . vterm-toggle))
#+END_SRC

**** =vterm= Key Bindings

Some common shell commands require an additional =C-c=:

+ =C-c C-c= to send =C-c=.
+ =C-c C-g= to send =C-g=.
+ =C-c C-u= to send =C-u=.
+ =C-c C-t= to enter/exit =copy-mode=.

*** eshell

Set up =eshell=.
I like the idea of it but I don't really use it.

#+BEGIN_SRC emacs-lisp
(use-package esh-autosuggest
  :hook (eshell-mode . esh-autosuggest-mode))

(use-package eshell-prompt-extras
  :after eshell
  :config
  (setq eshell-highlight-prompt nil
        eshell-prompt-function 'epe-theme-lambda))

(use-package eshell-syntax-highlighting
  :hook (eshell-mode . eshell-syntax-highlighting-mode))

(defun wal/advise-eshell/clear (&rest _r)
  "Advise to truncate buffer."
  (let ((eshell-buffer-maximum-lines 0))
    (eshell-truncate-buffer)))

(use-package eshell
  :ensure nil
  :config
  (advice-add 'eshell/clear :override #'wal/advise-eshell/clear)
  (wal/display-buffer-in-side-window "*eshell*")
  :general
  (wal/general "e" '(eshell :wk "eshell"))
  :bind
  (:map eshell-mode-map
   ([remap eshell-pcomplete] . completion-at-point)))
#+END_SRC

** Version Control

I'm becoming an old =git=.

*** magit

Version control has never been this easy before.

#+BEGIN_SRC emacs-lisp
(defun wal/magit-display-buffer-new-frame-status (buffer)
  "Display BUFFER in new frame if it is a status buffer.
Otherwise use `magit-display-buffer-traditional'.

It probably makes sense to bind `q' to `delete-frame'
in `magit-status-mode-map' when using this function."
  (if (eq (with-current-buffer buffer major-mode)
          'magit-status-mode)
      (display-buffer buffer '(display-buffer-pop-up-frame))
    (magit-display-buffer-traditional buffer)))

(use-package magit
  :custom
  (magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1)
  (magit-blame-mode-lighter " mbl")
  :general
  (wal/lieutenant
    "m" '(:ignore t :wk "magit")
    "mf" '(magit-find-file :wk "find file")
    "mo" '(magit-find-file-other-window :wk "find file other window")
    "md" '(magit-diff-range :wk "diff range"))
  :bind
  ("H-m" . magit-status))
#+END_SRC

*** git-timemachine

If you want to go back in time and point fingers at the progenitors of doom.

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :delight " gtm"
  :general
  (wal/colonel :keymaps 'prog-mode-map
    "m" '(git-timemachine-toggle :wk "git-timemachine")))
#+END_SRC

*** gitignore-mode

Syntax highlighting.

Necessary even for =.gitignore= files.

#+BEGIN_SRC emacs-lisp
(defun wal/gitignore-mode ()
  "Hook into `gitignore-mode'."
  (message "I don't think I know you"))

(use-package gitignore-mode
  :mode ("/\\.npmignore\\'" "/\\.gitignore\\'")
  :hook (gitignore-mode . wal/gitignore-mode))
#+END_SRC

** Languages

Let's greet the world.

*** Elixir

We don't use tabs here.

#+BEGIN_SRC emacs-lisp
(defun wal/elixir-mode ()
  "Hook into `elixir-mode'."
  (message "Mixin' potions")
  (wal/disable-tabs)
  (hack-local-variables)
  (wal/lsp))

(use-package elixir-mode
  :hook (elixir-mode . wal/elixir-mode)
  :general
  (wal/major :keymaps 'elixir-mode-map
    "f" '(elixir-format :wk "format with mode")))
#+END_SRC

*** Python

No tabs here either.
This mode is built-in.

#+BEGIN_SRC emacs-lisp
(defun wal/python-mode ()
  "Hook into `python-mode'."
  (message "Watch out for snakes!")
  (wal/disable-tabs)
  (hack-local-variables)
  (wal/lsp))

(use-package python
  :ensure nil
  :hook (python-mode . wal/python-mode)
  :general
  (wal/major :keymaps 'python-mode-map
    "i" '(run-python :wk "inferior shell")
    "s" '(:ignore t :wk "send")
    "sr" '(python-shell-send-region :wk "region")
    "sb" '(python-shell-send-buffer :wk "buffer")
    "sf" '(python-shell-send-file :wk "file"))
  :config
  ;; Treat inferior shell as a pop-up.
  (wal/display-buffer-in-side-window 'inferior-python-mode))
#+END_SRC

**** poetry

It's like =npm= for Python, it's why it rhymes.

#+BEGIN_SRC emacs-lisp
(defun wal/configure-lsp-server-commands (venv)
  "Configure server commands for `lsp-mode' using VENV."
  (let ((pylsp (file-exists-p (expand-file-name "bin/pylsp" venv)))
        (pyls (file-exists-p (expand-file-name "bin/pyls" venv))))
    (when pylsp
      (setq-local lsp-pylsp-server-command '("poetry" "run" "pylsp")))
    (when pyls
      (setq-local lsp-pyls-server-command '("poetry" "run" "pyls")))))

(defun wal/activate-venv ()
  "Activate venv using poetry.
This also works if the project isn't a poetry project."
  (unless (fboundp 'poetry-venv-exist-p)
    (require 'poetry))
  (ignore-errors
    (let* ((venv (poetry-venv-exist-p))
           (is-poetry (poetry-ensure-in-project)))
      (when venv
        (if is-poetry
            (progn
              (wal/configure-lsp-server-commands venv)
              (poetry-venv-workon))
          (pyvenv-activate venv))))))

(use-package pyvenv
  :hook (python-mode . wal/activate-venv)
  :general
  (wal/major :keymaps 'python-mode-map
    "v" '(pyvenv-activate :wk "activate venv")))

(use-package poetry
  :config
  (wal/display-buffer-in-side-window "\\*poetry-shell\\*")
  :general
  (wal/major :keymaps 'python-mode-map
    "p" '(poetry :wk "poetry")))
#+END_SRC

*** JavaScript

Disable internal checker and definition jumping.

#+BEGIN_SRC emacs-lisp
(defun wal/js2-mode ()
  "Hook into `js2-mode'."
  (message "NaN !== NaN")
  (add-node-modules-path)
  (hack-local-variables)
  (wal/maybe-enable-tabs)
  (when-let ((eslint (wal/find-local-node-binary "eslint")))
    (setq-local flycheck-javascript-eslint-executable eslint))
  (wal/lsp))

(use-package js2-mode
  :mode "\\.js\\'"
  :config
  (setq-default js2-show-parse-errors nil
                js2-strict-missing-semi-warning nil)
  ;; Remove `js2-jump-to-definition' binding which
  ;; rarely works and gets in the way of `dumb-jump-go'.
  (define-key js2-mode-map (kbd "M-.") nil)
  :hook (js2-mode . wal/js2-mode))
#+END_SRC

**** Node.js

Can we have =deno= instead?

***** add-node-modules-path

Allows accessing a project's =node_modules=.

#+BEGIN_SRC emacs-lisp
(use-package add-node-modules-path
  :defer t)
#+END_SRC

**** TypeScript

Same as JavaScript. But typed.

#+BEGIN_SRC emacs-lisp
(defun wal/typescript-mode ()
  "Hook into `typescript-mode'."
  (message "This is any, that is any, everything is any!")
  (add-node-modules-path)
  (hack-local-variables)
  (wal/maybe-enable-tabs)
  (when-let ((tslint (wal/find-local-node-binary "tslint")))
    (setq-local flycheck-javascript-eslint-executable tslint))
  (wal/lsp))

(use-package typescript-mode
  :mode "\\.ts\\'"
  :hook (typescript-mode . wal/typescript-mode))
#+END_SRC

**** React/Vue

Pretty much like =js2=.

#+BEGIN_SRC emacs-lisp
(defun wal/rjsx-mode ()
  "Hook into `rjsx-mode'."
  (message "Extend those ugly JavaScripts of yours!")
  (wal/maybe-enable-tabs 'js-jsx-indent-line))

(use-package rjsx-mode
  :mode "\\.jsx\\'"
  :hook (rjsx-mode . wal/rjsx-mode))
#+END_SRC

**** Linting

***** flymake-eslint

Plugin for =flymake=.

#+BEGIN_SRC emacs-lisp
(use-package flymake-eslint
  :after eglot
  :demand
  :custom
  (flymake-eslint-defer-binary-check t))
#+END_SRC

***** prettier

Prettify your ugly JavaScript.

#+BEGIN_SRC emacs-lisp
(use-package prettier
  :general
  (wal/major :keymaps '(js2-mode-map typescript-mode-map)
    "p" '(prettier-prettify :wk "run prettier")))
#+END_SRC

***** Additional Functions

#+BEGIN_SRC emacs-lisp
(defun wal/find-local-node-binary (local-binary)
  "Find LOCAL-BINARY in project's node_modules."
  (let* ((root (locate-dominating-file
                (or (buffer-file-name) default-directory)
                "node_modules"))
         (bin
          (and root
               (expand-file-name (concat "node_modules/.bin/" local-binary)
                                 root))))
    (when (and bin (file-executable-p bin))
      bin)))
#+END_SRC

*** Lisp

**** emacs-lisp

Enable =flycheck= and disable tabs.

Check out the [[https://lispcookbook.github.io/cl-cookbook/getting-started.html][lisp cookbook]] for =slime=.

#+BEGIN_SRC emacs-lisp
(defun wal/elisp-mode ()
  "Hook into `emacs-lisp-mode'."
  (message "So it's just a bunch of lists?")
  (wal/disable-tabs)
  (hack-local-variables)
  (flycheck-mode 1))

(use-package emacs-lisp
  :ensure nil
  :hook (emacs-lisp-mode . wal/elisp-mode))

(use-package highlight-quoted
  :hook (emacs-lisp-mode . highlight-quoted-mode))
#+END_SRC

**** slime

#+BEGIN_SRC emacs-lisp
(use-package slime
  :delight " slm"
  :ensure-system-package sbcl
  :general
  (wal/colonel :keymaps 'lisp-mode-map
    "l" '(slime-mode :wk "slime"))
  (wal/major :keymaps 'slime-mode-map
    "r" '(slime :wk "open REPL"))
  :config
  (setq inferior-lisp-program "sbcl")
  (slime-setup '(slime-fancy slime-quicklisp slime-asdf slime-company)))

(use-package slime-company
  :defer t)
#+END_SRC

*** C

I want to be ready for =jai=.

**** cc-mode

Make sure to install =ccls= and =clang=.

#+BEGIN_SRC emacs-lisp
(defun wal/c++-mode ()
  "Hook into `cc-mode'."
  (message "Make tidy! Make clean!")
  (wal/disable-tabs)
  (setq-local company-idle-delay 0.1)
  (hack-local-variables)
  (wal/lsp))

(use-package cc-mode
  :ensure nil
  :ensure-system-package (ccls clang)
  :config
  ;; Eliminates conflicts with `delight'.
  (advice-add 'c-update-modeline :override #'ignore)
  :hook (c++-mode . wal/c++-mode))
#+END_SRC

*** Web

Does anyone actually like web development?

**** css-mode

We want quicker =company= suggestions when in CSS modes.

#+BEGIN_SRC emacs-lisp
(defun wal/css-mode ()
  "Hook into `css-mode'."
  (message "Centering? It's simple. Here's 15 ways to do it.")
  ;; Faster `company'.
  (setq-local company-idle-delay 0.1)
  (hack-local-variables)
  (wal/maybe-enable-tabs)
  (flycheck-mode 1))

(use-package css-mode
  :ensure nil
  :hook (css-mode . wal/css-mode))
#+END_SRC

*** Other

Mostly mode configs.

**** yaml-mode

Sometimes you need YAMLs.

#+BEGIN_SRC emacs-lisp
(defun wal/yaml-mode ()
  "Hook into command `yaml-mode'."
  (message "JSON?! ... Ah, thank God it's you, YAML!")
  (drag-stuff-mode +1)
  (hack-local-variables)
  (wal/maybe-enable-tabs))

(use-package yaml-mode
  :hook (yaml-mode . wal/yaml-mode))
#+END_SRC

**** crontab-mode

It's time to deal with this.

#+BEGIN_SRC emacs-lisp
(use-package crontab-mode
  :defer t)
#+END_SRC

**** markdown-mode

Markdown. Sometimes you need it.

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :defer t)
#+END_SRC

**** json-mode

Enable tabs and =flycheck=.

#+BEGIN_SRC emacs-lisp
(defun wal/json-mode ()
  "Hook into `json-mode'."
  (message "JSON ...? JSON?! JSON!!")
  (rainbow-delimiters-mode)
  (hack-local-variables)
  (wal/maybe-enable-tabs)
  (flycheck-mode 1))

(use-package json-mode
  :hook (json-mode . wal/json-mode))
#+END_SRC

**** go-mode

Setup for LSP.

#+BEGIN_SRC emacs-lisp
(defun wal/go-mode ()
  "Hookp into `go-mode'."
  (message "What does Sonic say?")
  (wal/disable-tabs)
  (hack-local-variables)
  (wal/lsp))

(use-package go-mode
  :hook (go-mode . wal/go-mode))
#+END_SRC

**** pug-mode

Support for =pug= templates.

#+BEGIN_SRC emacs-lisp
(use-package pug-mode
  :defer t)
#+END_SRC

**** fish-mode

Support for =fish= functions.

#+BEGIN_SRC emacs-lisp
(use-package fish-mode
  :defer t)
#+END_SRC

** Fixing

Please let me know when I screwed up.
I promise I will learn.

#+BEGIN_SRC emacs-lisp
(defun wal/fly-check ()
  "Call either `consult-flymake' or `consult-flycheck'.
This depends on `wal/lsp-client'."
  (interactive)
  (cond ((and (boundp 'flymake-mode) flymake-mode) (consult-flymake))
        ((and (boundp 'flycheck-mode) flycheck-mode) (consult-flycheck))
        (t nil)))

(wal/captain :keymaps '(flymake-mode-map flycheck-mode-map)
  "f" '(:ignore t :wk "fly-check")
  "fs" '(wal/fly-check :wk "search"))
#+END_SRC

*** flymake

Built-in syntax checker. Used by =eglot=.

#+BEGIN_SRC emacs-lisp
(use-package flymake
  :ensure nil
  :defer t
  :config
  (setq flymake-mode-line-title "flm")
  :general
  (wal/captain :keymaps 'flymake-mode-map
    "fn" '(flymake-goto-next-error :wk "next")
    "fp" '(flymake-goto-prev-error :wk "prev")))
#+END_SRC

*** flycheck

=flycheck= is for all of our linting/code quality needs.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :defer t
  :delight " fly"
  :custom
  (flycheck-keymap-prefix (kbd "C-c f"))
  :general
  (wal/colonel :keymaps 'prog-mode-map
    "f" '(flycheck-mode :wk "flycheck")))
#+END_SRC

**** Finding ESLint

Configs can be found using a file, not a directory.

#+BEGIN_SRC emacs-lisp
(defun flycheck-eslint-config-exists-p ()
  "Check if there is a valid ESLint config for the current buffer."
  (let* ((executable (flycheck-find-checker-executable 'javascript-eslint))
         (exitcode (and executable (call-process executable
                                                 nil
                                                 nil
                                                 nil
                                                 "--print-config"
                                                 ".eslintrc"))))
    (eq exitcode 0)))
#+END_SRC

**** Fix =pylint= False Positives

The =pylint= checker creates false positives for relative import mistakes.
There is a [[https://github.com/bkhl/flycheck/commit/3f9582d2df42d4f55ee1fc33aae1a56bf1dab421][fix]] but it's trapped.

#+BEGIN_SRC emacs-lisp :tangle no
(defun flycheck-pylint-find-project-root (_checker)
  "Find the directory to invoke pylint from.

The algorithm is the same as used by epylint: find the first
directory that doesn't have a __init__.py file."
  (locate-dominating-file
   (if buffer-file-name
       (file-name-directory buffer-file-name)
     default-directory)
   (lambda (dir)
     (not (file-exists-p (expand-file-name "__init__.py" dir))))))

(flycheck-define-checker python-pylint
  "A Python syntax and style checker using Pylint.

This syntax checker requires Pylint 1.0 or newer.

See URL `https://www.pylint.org/'."
  :command ("python3"
            (eval (flycheck-python-module-args 'python-pylint "pylint"))
            "--reports=n"
            "--output-format=json"
            (config-file "--rcfile=" flycheck-pylintrc concat)
            source-inplace)
  :error-parser flycheck-parse-pylint
  :enabled (lambda ()
             (or (not (flycheck-python-needs-module-p 'python-pylint))
                 (flycheck-python-find-module 'python-pylint "pylint")))
  :verify (lambda (_) (flycheck-python-verify-module 'python-pylint "pylint"))
  :error-explainer (lambda (err)
                     (-when-let (id (flycheck-error-id err))
                       (apply
                        #'flycheck-call-checker-process-for-output
                        'python-pylint nil t
                        (append
                         (flycheck-python-module-args 'python-pylint "pylint")
                         (list (format "--help-msg=%s" id))))))
  :working-directory flycheck-pylint-find-project-root
  :modes python-mode
  :next-checkers ((warning . python-mypy)))
#+END_SRC

*** flyspell

My spelling is bad.
Uses American English for =flyspell=.

#+BEGIN_SRC emacs-lisp
(defun wal/flyspell-prog-mode ()
  "Toggle function `flyspell-prog-mode' properly."
  (interactive)
  (if flyspell-mode
      (flyspell-mode -1)
    (flyspell-prog-mode)))

(defun wal/flyspell-mode ()
  "Toggle function `flyspell-mode' properly."
  (interactive)
  (if flyspell-mode
      (flyspell-mode -1)
    (flyspell-mode 1)))

(use-package ispell
  :defer t
  :custom
  (ispell-silently-savep t))

(use-package flyspell
  :ensure nil
  :custom
  (flyspell-issue-message-flag nil)
  (flyspell-mode-line-string " fsp")
  (flyspell-default-dictionary "american")
  :bind
  (:map flyspell-mode-map
   ("C-." . ispell-word)) ;; Replaces `flyspell-auto-correct-word'.
                          ;; But still available via `C-M-i'.
  :general
  (wal/colonel :keymaps '(text-mode-map org-mode-map)
    "s" '(wal/flyspell-mode :wk "flyspell"))
  (wal/colonel :keymaps 'prog-mode-map
    "s" '(wal/flyspell-prog-mode :wk "flyspell-prog"))
  (wal/captain :keymaps 'flyspell-mode-map
    "s" '(:ignore t :wk "flyspell")
    "sb" '(flyspell-buffer :wk "buffer")
    "sr" '(flyspell-region :wk "region")))
#+END_SRC

** LSP

Language servers are awesome. Thanks, Microsoft.

#+BEGIN_SRC emacs-lisp
(defvar wal/lsp-client 'eglot
  "Which LSP client to use.")

(defun wal/lsp ()
  "Activate LSP client."
  (pcase wal/lsp-client
    ('lsp-mode (lsp-deferred))
    ('eglot (eglot-ensure))
    (_ nil)))
#+END_SRC

*** lsp-mode

This is the fancy version.
You'll have to install some language servers yourself[fn:14].

#+BEGIN_SRC emacs-lisp
(defvar wal/lsp-file-watch-ignored
  '("[/\\\\]_build$"
    "[/\\\\]deps$")
  "Additional directories to not monitor.")

(use-package lsp-mode
  :delight " lsp"
  :hook (lsp-mode . flycheck-mode)
  :general
  (wal/colonel :keymaps 'prog-mode-map
    "l" '(lsp-mode :wk "lsp"))
  (wal/captain :keymaps 'lsp-mode-map
    "l" '(:ignore t :wk "lsp")
    "lr" '(lsp-rename :wk "rename")
    "lf" '(lsp-format-buffer :wk "format"))
  :custom
  (lsp-completion-provider :capf)
  (lsp-prefer-capf t)
  (lsp-idle-delay 1.5)
  (lsp-enable-dap-auto-configure nil)
  ;; These have to be defined here.
  (lsp-headerline-breadcrumb-enable nil)
  (lsp-log-io t)
  ;; Enable `pylint' and pyenv for `jedi'.
  (lsp-pyls-plugins-pylint-enabled t)
  (lsp-pyls-plugins-jedi-use-pyenv-environment t)
  (lsp-pylsp-plugins-pylint-enabled t)
  (lsp-pylsp-plugins-jedi-use-pyenv-environment t)
  :config
  (lsp-enable-which-key-integration t)
  (mapc (lambda (it)
          (add-to-list 'lsp-file-watch-ignored it))
        wal/lsp-file-watch-ignored))

(use-package lsp-ui
  :after lsp-mode
  :custom
  (lsp-ui-sideline-enable nil)
  ;; (lsp-ui-sideline-delay 1.5)
  (lsp-ui-doc-position 'top) ; Alternatively, `at-point'.
  (lsp-ui-doc-delay 0.4))
#+END_SRC

**** dap-mode

Debugging using VSCode's DAP.
Since this only works with =lsp-mode=, I consider
it a sub-package of it.

#+BEGIN_SRC emacs-lisp
(use-package dap-mode
  :delight " dap"
  :custom
  (dap-python-executable "python3")
  (dap-python-debugger 'debugpy)
  (dap-print-io t)
  (dap-auto-show-output nil)
  (dap-auto-configure-features '(repl))
  :config
  (dap-ui-mode 1)
  (dap-auto-configure-mode)
  (require 'dap-node)
  (require 'dap-python)
  (wal/display-buffer-in-side-window 'dap-ui-repl-mode)
  :general
  (wal/colonel :keymaps 'prog-mode-map
    "d" '(dap-mode :wk "dap"))
  (wal/captain :keymaps 'dap-mode-map
    "d" '(dap-hydra :wk "dap")))
#+END_SRC

***** Debug Templates

Put these templates in a file in your project root,
and evaluate them there using =C-x C-e=.

****** Node.js

This for attaching to a remote host (Docker container) using =nodemon=.

For TypeScript compile your =src= with =--sourceMap= or set =sourceMap=
to =true= in your =tsconfig.json=.

#+BEGIN_SRC emacs-lisp :tangle no
(when (require 'dap-mode nil 'noerror)
  (progn
    (let* ((use-source-maps t) ; Turn off if not needed.
           (build-directory "build") ; Set to `nil' if this isn't transpiled JavaScript.
           (remote-root "/usr/src/app") ; If this is running remotely.
           (local-root (if build-directory
                           (concat (file-name-directory buffer-file-name) build-directory)
                         (file-name-directory buffer-file-name))))
      (dap-register-debug-template
       "attach::node"
       (list :type "node"
             :request "attach"
             :sourceMaps use-source-maps
             :remoteRoot remote-root
             :localRoot local-root
             :port 9229)))))
#+END_SRC

****** Python

Attach to running process.

#+BEGIN_SRC emacs-lisp :tangle no
;; Adapt your remote root
(when (require 'dap-mode nil 'noerror)
  (let ((mapping '(:localRoot "${workspaceFolder}" :remoteRoot "/usr/src/app")))
    (dap-register-debug-template
     "python::attach"
     (list :type "python"
           :request "attach"
           :connect (list :host "localhost" :port 5678)
           :pathMappings (vector mapping)))))
#+END_SRC

*** eglot

This is the light-weight alternative.

#+BEGIN_SRC emacs-lisp
(defun wal/eglot-managed-mode ()
  "Hook into `eglot-managed-mode-hook'."
  (pcase major-mode
    ((or 'js2-mode 'rjsx-mode)
     (if (eglot-managed-p)
         (add-hook 'flymake-diagnostic-functions 'flymake-eslint--checker nil t)
       (remove-hook 'flymake-diagnostic-functions 'flyamke-eslint--checker t)))
    (_ nil)))

(use-package eglot
  :hook (eglot-managed-mode . wal/eglot-managed-mode)
  :custom
  (eglot-autoshutdown t)
  :general
  (wal/captain :keymaps 'eglot-mode-map
    "l" '(:ignore t :wk "eglot")
    "lc" '(eglot-reconnect :wk "reconnect")
    "lf" '(eglot-format :wk "format")
    "lr" '(eglot-rename :wk "rename")
    "ls" '(eglot-shutdown :wk "shutdown")
    "la" '(eglot-code-actions :wk "code actions")))
#+END_SRC

**** Server Configurations

Configure or register language servers that aren't as straight forward.

=eglot= prefers using a =.dir-locals.el= file to configure
a language server.

***** Elixir

#+BEGIN_SRC emacs-lisp
;;; Elixir:
(defvar elixir-ls-release-location
  (expand-file-name "ls/elixir" user-emacs-directory)
  "Location of the Elixir language server.")

;; Add executable to path.
(when (file-exists-p (expand-file-name "language_server.sh" elixir-ls-release-location))
  (add-to-list 'exec-path elixir-ls-release-location))
#+END_SRC

***** =pylint=

This one assumes you want to enable =pylint= and you're
using =poetry=.

#+BEGIN_SRC emacs-lisp :tangle no
((python-mode
  . ((eglot-workspace-configuration
      . ((pyls . ((plugins (pylint (enabled . t)))
                  (executable  . "poetry run pyls")))
         (pylsp . ((plugins (pylint (enabled . t)))
                   (executable  "poetry run pylsp"))))))))
#+END_SRC

***** =gopls=

Taken from the official documentation.

#+BEGIN_SRC emacs-lisp :tangle no
((go-mode
  . ((eglot-workspace-configuration
      . ((gopls . ((staticcheck . t)
                    (matcher . "CaseSensitive"))))))))
#+END_SRC

***** prolog

Using =swipl=.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'lsp-mode
  (lsp-register-client
   (make-lsp-client
    :new-connection
    (lsp-stdio-connection (list "swipl"
                                "-g" "use_module(library(lsp_server))."
                                "-g" "lsp_server:main"
                                "-t" "halt"
                                "--" "stdio"))
    :major-modes '(prolog-mode)
    :priority 1
    :multi-root t
    :server-id 'prolog-ls)))
#+END_SRC

** DevOps

Put it into a container and throw it in the
garbage that is the Internet.

*** Docker

What goes =docker-compose= up, goes =docker-compose= down.

#+BEGIN_SRC emacs-lisp
(use-package docker
  :defer 2 ; This package does not get autoloaded correctly.
  :config
  (wal/display-buffer-in-side-window "\\*docker-containers\\*" 'top)
  (wal/display-buffer-in-side-window "^\\* docker shell")
  (wal/display-buffer-in-direction "^\\* docker container")
  (wal/display-buffer-in-direction "^\\*docker-compose")
  :custom
  (docker-container-default-sort-key '("Names"))
  :bind
  (("C-c d" . docker)))
#+END_SRC

**** dockerfile-mode

Make =Dockerfiles= look nice.

#+BEGIN_SRC emacs-lisp
(defun wal/dockerfile-mode ()
  "Hook into `dockerfile-mode'."
  (message "Have you ever given?"))

(use-package dockerfile-mode
  :hook (dockerfile-mode . wal/dockerfile-mode))
#+END_SRC

** The Internet

I browse, I request.

*** restclient

Postman is pass.
I use a =.http= file extension for my request examples.

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :config
  (wal/display-buffer-in-pop-up "\\*HTTP Response\\*")
  :mode ("\\.http\\'" . restclient-mode))

;; We use this for hooks.
(use-package jq-mode
  :after restclient
  :ensure-system-package jq)

;; You will need to clone restclient repo.
(use-package restclient-jq
  :load-path "site-lisp"
  :defer t
  :config
  (require 'cl nil t))
#+END_SRC

** Writing

Sometimes you have to sit down and write something.

*** typo

Access complex punctuation.
To me this doesn't necessarily make sense for all =text-mode=
modes (like =org-mode=), so instead it needs to be triggered
explicitly.

#+BEGIN_SRC emacs-lisp
(use-package typo
  :delight " typ"
  :general
  (wal/colonel :keymaps '(text-mode-map org-mode-map)
    "t" '(typo-mode :wk "toggle typo mode")))
#+END_SRC

*** writeroom-mode

Create a room of one's own.
I use a different (light) theme here.

#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
  :config
  (setq writeroom-global-effects (remove 'writeroom-set-alpha writeroom-global-effects)) ; Keep transparency.
  :custom
  (writeroom-width 0.618) ; Golden ratio.
  (writeroom-restore-window-config t)
  (writeroom-extra-line-spacing 0.1)
  :general
  (wal/colonel "r" '(writeroom-mode :wk "toggle writeroom")))
#+END_SRC

* Post-Export

We're not gonna byte compile this file.
And make the exported file happy.

#+BEGIN_SRC emacs-lisp
;; Local Variables:
;; no-byte-compile: t
;; End:

;;; README.el ends here
#+END_SRC

* Footnotes

[fn:1] Jumped ship from =27.1=. Some minor things might not work there.

[fn:2] If you're feeling adventurous, [[https://git.savannah.gnu.org/cgit/emacs.git/tree/INSTALL][build from source]].

[fn:3] If you're not sure where your =user-emacs-directory= might be,
you can do the following:

+ Run Emacs
+ hit =M-x= (that is your Alt/Option key followed by the letter =x=)
+ type =describe-variable= and hit return
+ type =user-emacs-directory= and hit return again.

A window should pop up telling you the path.

Finally run =git clone git@gitlab.com:Walheimat/emacs-config.git ~/.emacs.d=
(replace =~/.emacs.d= with your actual path if it differs).

[fn:4] This config uses the =all-the-icons= package
whose icons need to be downloaded manually
by running =M-x all-the-icons-install-fonts= and selecting =yes=.

If the installation process should fail for any reason,
close Emacs and re-run it.

[fn:5] Which means that a frame is created and control immediately returned

[fn:6] Not including where =:tangle no= was set, somewhere around 150 code blocks.

[fn:7] Send me an email, why don't you?

[fn:8] To get a full overview you'll have to call =describe-personal-keybindings=
and =general-describe-keybindings=.

[fn:9] Be careful! If you make a mistake you could render your
keyboard unusable.

[fn:10] Mostly from MELPA.
/Note/ that many packages bind keys.
Check the [[*Key Bindings][key bindings section]] if you need a list of the important ones,
in that section you also find package configurations for key-binding-related
packages =general= and =hydra=.

[fn:11] The following packages (and their related or sub-packages) have their own sections:

+ [[*Org][=org-mode=]] (including org sub-packages)
+ [[*Agendas][=org-agenda=]]
+ [[*flymake][=flymake=]]
+ [[*flyspell][=flyspell=]]
+ [[*Dired][=dired=]]
+ [[*eshell][=eshell=]]
+ [[*Python][=python=]]
+ [[*emacs-lisp][=emacs-lisp=]]
+ [[*css-mode][=css-mode=]]
+ [[*cc-mode][=cc-mode=]]

[fn:12]  We will try to download it automatically, but might fail.

[fn:13] If you're on an older distro your =libvterm= package might be too old.

[fn:14] All languages listed [[https://emacs-lsp.github.io/lsp-mode/page/languages/][here]].
