#+TITLE: Walheimat's Emacs Config
#+AUTHOR: [[https://gitlab.com/Walheimat][@Walheimat]]

[[./assets/logo.png]]

* About

** Heads-Up

This project is my personal literate Emacs[fn:1] configuration.

If you're a complete beginner, you will find [[https://github.com/emacs-tw/awesome-emacs#starter-kit][more user-friendly and
less tailor-made configs]] out there.

Feel free to consider it a jumping-off-point for your own custom
config. Just know that nothing in this config should be considered
/good practice/, it's mostly just how I (think I) like things to be.

** Try-Out

If you're interested in trying out Emacs using my config, here are the
necessary steps:

+ install Emacs if you haven't[fn:2]
+ =git clone= this repository into your =user-emacs-directory=[fn:3]
+ run =load-file= and navigate to =setup/wal-setup=, run =wal/setup=, select
  =init file= and choose =link= or =copy=
+ close and re-run Emacs which should (download and) install all[fn:4]
  packages.

If you do not wish to =clone= this repo in your =user-emacs-directory= or
use the default name, you will need to adapt the variable
=wal/emacs-config-default-path= in the example init file you just
copied.

You can then use =customize-group= to change settings for various
aspects of the config.

** Peculiarities

*** As a Daemon

This config is /daemon-ready/, i.e. if you start Emacs with the =--daemon=
flag, the config will make sure that any customization that requires a
frame will only be loaded once a frame was created.

You can install either a =systemd= service using =wal/setup= (described
above) or just execute =emacs --daemon= in a terminal or your login
shell's configuration.

In any case, an Emacs daemon will start (on start-up). To connect, you
can use, for example, =emacsclient -c -n=[fn:5].

*** Package-Like

Custom functions and variables use the =wal/= scope and belong to their
respective section's package. Each package/section defines a group for
customization purposes.

With a few exceptions, each package has a *Header* and a *Footer* that
contains declarations for the package, as well as either a *Packages*
section or several sections grouping packages.

Enough preambling, let's configure some Emacs. The init script will
evaluate /everything/[fn:6] that follows.

* Settings
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-settings.el" wal/emacs-config-package-path)
:END:

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-settings.el --- Settings. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; The global settings.

;;; Code:

(declare-function wal/bytes-per-mb "wal-func.el")
(declare-function wal/install-packages "wal-func.el")
(declare-function wal/is-expansion-pack "wal-func.el")
(declare-function wal/maybe-make-directory "wal-func.el")
(declare-function wal/prefix-user-key "wal-key-bindings.el")
(declare-function wal/reset-to-standard "wal-func.el")

(defvar compilation-scroll-output)
(defvar global-auto-revert-non-file-buffers)
(defvar debugger-bury-or-kill)
(defvar display-time-default-load-average)
(defvar display-time-format)
(defvar native-comp-async-report-warnings-errors)
(defvar so-long-action)
(defvar use-package-always-ensure)
(defvar use-package-always-defer)
(defvar wal/doctor)

(defgroup wal-settings nil
  "Change core settings."
  :group 'wal
  :tag "Settings")

;;;; Customization:

(defcustom wal/cache-directory (expand-file-name ".cache" user-emacs-directory)
  "The cache directory."
  :type 'string
  :group 'wal-settings)

(defcustom wal/site-lisp-directory (expand-file-name "site-lisp" user-emacs-directory)
  "Directory of site Lisp packages."
  :type 'string
  :group 'wal-settings)

(defcustom wal/org-directory (expand-file-name "org" "~")
  "Default directory for org files."
  :type 'string
  :group 'wal-settings)

(defcustom wal/agenda-tasks-directory (expand-file-name "tasks" wal/org-directory)
  "One-size-fits-all directory for agenda tasks."
  :type 'string
  :group 'wal-settings)

(defcustom wal/org-roam-directory (expand-file-name "zettelkasten" wal/org-directory)
  "Directory for Zettelkasten note-taking."
  :type 'string
  :group 'wal-settings)

(defcustom wal/custom-file (expand-file-name "custom.el" user-emacs-directory)
  "Location of the custom file."
  :type 'string
  :group 'wal-settings)

(defcustom wal/read-process-output-max (wal/bytes-per-mb 50)
  "Increased `read-process-output-max'."
  :type 'integer
  :group 'wal-settings)

(defcustom wal/indent-offset 4
  "The indent offset in spaces."
  :type 'integer
  :group 'wal-settings)

(defcustom wal/prefer-tabs nil
  "Whether tabs are preferred for indentation."
  :type 'boolean
  :group 'wal-settings)

(defcustom wal/scratch-persist-file (expand-file-name "scratch-persist" wal/cache-directory)
  "The file to persist the *scratch* buffer's content in."
  :type 'string
  :group 'wal-settings)

(defcustom wal/minimal nil
  "Whether to use a minimal configuration."
  :type 'boolean
  :group 'wal-settings)

(defcustom wal/minimal-exclude '()
  "Packages that are not part of a minimal configuration but should be installed."
  :type '(repeat symbol)
  :group 'wal-settings)

(defcustom wal/maximize-new-frames t
  "Whether to maximize new frames by default."
  :type 'boolean
  :group 'wal-settings)

(defcustom wal/ack-warnings nil
  "Acknowledge all warnings."
  :type 'boolean
  :group 'wal-settings)
#+END_SRC

** Personal

Set some personal info[fn:7].

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Krister Schuchardt"
      user-mail-address "krister.schuchardt@gmail.com")
#+END_SRC

** Start-Up

Customize start-up.

#+BEGIN_SRC emacs-lisp
(defconst wal/experimental (> emacs-major-version 28)
  "Set to t if Emacs was built from master branch.
This variable is used to account for certain features (and
bugs).")

;; Load custom file. Create it if it doesn't yet exist.
(setq custom-file wal/custom-file)
(unless (file-exists-p custom-file)
  (write-region "" nil custom-file))
(load custom-file)

;; Maximize frame.
(setq frame-resize-pixelwise t)
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
(when wal/maximize-new-frames
  (add-to-list 'default-frame-alist '(fullscreen . maximized)))

;; No splash.
(setq inhibit-startup-message t)
(setq initial-major-mode 'fundamental-mode) ; Avoids loading `prog-mode' derivatives.

;; Accept redefinitions.
(setq ad-redefinition-action 'accept)

;; Warn Mac/Windows users.
(unless (or (eq system-type 'gnu/linux) wal/ack-warnings)
  (warn "\
     Warning: Config only tested on Linux. The configuration may
     not work correctly on your system.

     Set `wal/ack-warnings' to t to ignore this warning."))
#+END_SRC

** Package Archives

Add MELPA to the package archives. Most (if not all) packages will be
installed from there.

#+BEGIN_SRC emacs-lisp
(require 'package)

(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+END_SRC

** Core Packages

Before =use-package= macro can be used to configure other packages it
needs to be installed. We also install optional dependencies to
diminish and delight minor modes.

#+BEGIN_SRC emacs-lisp
(defconst wal/core-packages
  '(diminish
    delight
    use-package)
  "Packages to install before using `use-package'.
Such as package `use-package'.")

;; Try to install. On fail refresh and install again.
(condition-case nil
    (wal/install-packages wal/core-packages :delete-windows t)
  (error
   (package-refresh-contents)
   (wal/install-packages wal/core-packages :delete-windows t)))

;; Always ensure and defer.
(setq use-package-always-ensure t
      use-package-always-defer t)

(eval-when-compile
  (require 'use-package))

(when wal/doctor
  (setq use-package-compute-statistics t)
  (when (fboundp 'use-package-report)
    (add-hook 'after-init-hook #'use-package-report)))
#+END_SRC

*** Extend =use-package=

#+BEGIN_SRC emacs-lisp
(defun wal/insert-use-package-keyword (keyword preceding)
  "Insert KEYWORD after PRECEDING keyword into `use-package-keywords'."
  (let* ((kw use-package-keywords)
         (remainder (nthcdr (cl-position preceding kw) kw)))
    (setcdr remainder (cons keyword (cdr remainder)))))
#+END_SRC

**** =:wal-bind=

We'll add keyword =:wal-bind= to =use-package= in order to create bindings
prefixed by =wal/prefix-user-key=.

#+BEGIN_SRC emacs-lisp
(defun use-package-normalize/:wal-bind (name keyword args)
  "Normalize NAME, KEYWORD, ARGS.

This normalizer is a copy of the normalizer for `:bind'. There
are two differences:

1. It prefixes the key strings with `wal/prefix-user-key'.
2. On recursion it calls this normalizer."
  (let ((arg args)
        args*)
    (while arg
      (let ((x (car arg)))
        (cond
         ((and (consp x)
               (or (stringp (car x))
                   (vectorp (car x)))
               (fboundp 'use-package-recognize-function)
               (or (use-package-recognize-function (cdr x) t #'stringp)))
          ;; This is where we deviate from the `:bind' normalizer.
          (setq args* (nconc args* (list (cons (wal/prefix-user-key (car x)) (cdr x)))))
          (setq arg (cdr arg)))
         ((or (and (eq x :map) (symbolp (cadr arg)))
              (and (eq x :prefix) (stringp (cadr arg)))
              (and (eq x :prefix-map) (symbolp (cadr arg)))
              (and (eq x :prefix-docstring) (stringp (cadr arg)))
              (eq x :filter)
              (and (eq x :menu-name) (stringp (cadr arg)))
              (and (eq x :package) (symbolp (cadr arg))))
          (setq args* (nconc args* (list x (cadr arg))))
          (setq arg (cddr arg)))
         ((listp x)
          (setq args*
                (nconc args* (use-package-normalize/:wal-bind name keyword x)))
          (setq arg (cdr arg)))
         (t
          (use-package-error
           (concat (symbol-name name)
                   " wants arguments acceptable to the `bind-keys' macro,"
                   " or a list of such values"))))))
    args*))

;; We can use the same handler as `:bind'.
(defalias 'use-package-handler/:wal-bind 'use-package-handler/:bind)

;; Make sure that functions are autoloaded.
(defalias 'use-package-autoloads/:wal-bind 'use-package-autoloads-mode)

(wal/insert-use-package-keyword :wal-bind :bind-keymap*)
#+END_SRC

**** =:wal-ways=

Certain packages do not belong to a minimal setup, these are tagged
with =:wal-ways nil=.

#+BEGIN_SRC emacs-lisp
(defalias 'use-package-normalize/:wal-ways 'use-package-normalize-predicate)

(defun use-package-handler/:wal-ways (name _keyword pred rest state)
  "Only expand conditionallly.

The conditions for normla packages are: (1) the PRED is t, (2)
`wal/minimal' is nil or (3) NAME is never excluded.

If NAME is an expansion pack package, the conditions are: (1) the
PRED is t or (2) NAME is installed.

The STATE is updated as well before parsing REST if we want to
use the result further down the line."
  (when (and (fboundp 'use-package-process-keywords)
             (fboundp 'use-package-plist-maybe-put))
    (let* ((active (or pred
                       (if (wal/is-expansion-pack name)
                           (not (null (package-installed-p name)))
                         (or (not wal/minimal)
                             (not (null (memq name wal/minimal-exclude)))))))
           (body (use-package-process-keywords
                   name
                   rest
                   (use-package-plist-maybe-put state :wal-ways active))))
      `((when ,active
          ,@body)))))

(wal/insert-use-package-keyword :wal-ways :pin)

(add-to-list 'use-package-defaults '(:wal-ways t t))
#+END_SRC

*** quelpa
:PROPERTIES:
:UNNUMBERED: t
:END:

Allows installing from other sources (like GitHub) using recipes.

#+BEGIN_SRC emacs-lisp
(use-package quelpa
  :custom
  (quelpa-update-melpa-p nil)
  :demand)

(use-package quelpa-use-package
  :config
  (when (fboundp 'quelpa-use-package-activate-advice)
    (quelpa-use-package-activate-advice))
  :after quelpa
  :demand)
#+END_SRC

** Directories

Make sure that custom directories exist. We want:

+ A cache directory to store bookmarks etc.
+ a directory for site lisp
+ a default directory for org files
+ a default directory for agenda tasks
+ a default directory for notes.

#+BEGIN_SRC emacs-lisp
(defun wal/maybe-create-directories ()
  "Create directories if they don't exist."
  (mapc #'wal/maybe-make-directory
        `(,wal/cache-directory
          ,wal/site-lisp-directory
          ,wal/org-directory
          ,wal/agenda-tasks-directory
          ,wal/org-roam-directory)))

(add-hook 'emacs-startup-hook #'wal/maybe-create-directories)
#+END_SRC

** Site-Lisp

Add all sub-directories of the site lisp directory to load path (and
custom theme load path). I put non-MELPA packages here.

#+BEGIN_SRC emacs-lisp
(dolist (project (directory-files wal/site-lisp-directory t "\\w+"))
  (when (file-directory-p project)
    (add-to-list 'load-path project)
    (add-to-list 'custom-theme-load-path project)))
#+END_SRC

** Saving and Backups

Don't clutter up workspaces.

#+BEGIN_SRC emacs-lisp
;; Store backups in backups folder and back up by copying.
(setq backup-directory-alist
      `(("." . ,(expand-file-name (concat user-emacs-directory "backups"))))
      backup-by-copying t)

;; Store autosaves in temp folder.
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))

;; We don't want this to mess with git.
(setq create-lockfiles nil)
#+END_SRC

** Global Modes

Any mode that should be on/off no matter what.

#+BEGIN_SRC emacs-lisp
;; A bunch of useful modes.
(show-paren-mode 1)
(global-auto-revert-mode 1)
(save-place-mode 1)
(delete-selection-mode 1)
(column-number-mode 1)
(global-so-long-mode 1)
(savehist-mode 1)

;; No need for bars.
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)

;; Emacs 29.
(when wal/experimental
  (pixel-scroll-precision-mode 1))
#+END_SRC

** Reasonable Values

Make things shorter and snappier. These settings don't belong to
packages.

#+BEGIN_SRC emacs-lisp
(setq read-process-output-max wal/read-process-output-max
      echo-keystrokes 0.1
      use-short-answers t ; New in Emacs 28. Otherwise you need an alias.
      ;; Undo limits.
      undo-limit (wal/bytes-per-mb 1)
      undo-strong-limit (wal/bytes-per-mb 1.5)
      undo-outer-limit (wal/bytes-per-mb 150)
      ;; Mouse.
      mouse-yank-at-point t
      ;; Native compilation.
      package-native-compile t
      native-comp-async-report-warnings-errors 'silent
      ;; Annoyances.
      disabled-command-function nil
      debugger-bury-or-kill 'kill
      so-long-action 'so-long-minor-mode
      ;; Time.
      display-time-format " %H:%M"
      display-time-default-load-average nil
      save-interprogram-paste-before-kill t
      ;; Mark ring.
      mark-ring-max 32
      global-mark-ring-max 32
      ;; Parentheses.
      show-paren-delay 0.1
      show-paren-context-when-offscreen t ; New in Emacs 29.
      ;; Editing.
      backward-delete-char-untabify-method 'hungry
      ;; Compilation.
      compilation-scroll-output t)
#+END_SRC

** Indentation

Set up an easy way to switch between tabs and spaces for indentation.

#+BEGIN_SRC emacs-lisp
(defvar wal/indent-vars '(python-indent-offset
                          js-indent-level
                          css-indent-offset
                          tab-width
                          js-encoding-default-indentation
                          electric-indent-inhibit
                          indent-tabs-mode))

(defun wal/reset-indent-defaults ()
  "Reset indent defaults.
Resets all variables that were initially set by
`wal/set-indent-defaults'."
  (interactive)
  (mapc #'wal/reset-to-standard wal/indent-vars))

(defun wal/disable-tabs (&optional no-hack)
  "Disable tabs.

Sets variable `indent-tabs-mode' to nil. Will hack local
variables unless NO-HACK is non-nil (which will be the case when
called interactively)."
  (interactive "p")
  (setq indent-tabs-mode nil)
  (unless no-hack
    (hack-local-variables)))

(defun wal/enable-tabs ()
  "Enable tabs.

Sets tab variable `indent-tabs-mode' to t."
  (interactive)
  (setq indent-tabs-mode t))

(cl-defun wal/maybe-enable-tabs (&key indent-with)
  "Maybe enable tabs.

Optionally set `indent-line-function' to INDENT-WITH.

This function will call `hack-local-variables'."
  (hack-local-variables)
  (when indent-with
    (setq-local indent-line-function indent-with))
  (if wal/prefer-tabs
      (wal/enable-tabs)
    (wal/disable-tabs)))

(defun wal/set-indent-defaults (&optional num)
  "Set indent defaults.
All offsets are set to `wal/indent-offset' or optionally to NUM."
  (interactive "nSet tab width to: ")
  (let ((offset (or num wal/indent-offset)))
    (setq-default python-indent-offset offset
                  js-indent-level offset
                  css-indent-offset offset
                  tab-width offset
                  json-encoding-default-indentation (make-string offset ? )
                  electric-indent-inhibit t
                  indent-tabs-mode wal/prefer-tabs)))

(add-hook 'emacs-startup-hook #'wal/set-indent-defaults)
#+END_SRC

*** Dir Local Indentation

Sometimes you have to play using other people's rules. You can run
=add-dir-local-variable= to do so. Check out the =.dir-locals.el= template
found in the =/templates= folder for an example using spaces.

** Persistent =*scratch*=

Let's keep the scratch contents. This was cribbed from [[https://www.john2x.com/emacs.html][john2x's
config]].

#+BEGIN_SRC emacs-lisp
;; Empty scratch message.
(setq initial-scratch-message "")

(defun wal/persist-scratch ()
  "Persist contents of *scratch* buffer.
The contents are stored in `wal/scratch-persist-file'."
  (with-current-buffer (get-buffer-create "*scratch*")
    (write-region (point-min) (point-max) wal/scratch-persist-file)))

(defun wal/rehydrate-scratch ()
  "Re-hydrate scratch buffer (if persisted).
This overrides the scratch buffer with the content stored in
`wal/scratch-persist-file'."
  (when (file-exists-p wal/scratch-persist-file)
    (with-current-buffer (get-buffer "*scratch*")
      (delete-region (point-min) (point-max))
      (insert-file-contents wal/scratch-persist-file))))

(add-hook 'emacs-startup-hook #'wal/rehydrate-scratch)
(add-hook 'kill-emacs-hook #'wal/persist-scratch)
#+END_SRC

** Minimize Annoyances

Make never leaving Emacs a priority.

#+BEGIN_SRC emacs-lisp
(setq use-dialog-box nil) ; Never use dialog boxes.
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-settings)

;;; wal-settings.el ends here
#+END_SRC

* Key Bindings
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-key-bindings.el" wal/emacs-config-package-path)
:END:

I use many[fn:8] custom keybindings.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-key-bindings.el --- Key bindings. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Key bindings package.

;;; Code:

(declare-function wal/colonel "wal-key-bindings.el")
(declare-function wal/general "wal-key-bindings.el")
(declare-function wal/general-sink "wal-key-bindings.el")
(declare-function wal/lieutenant "wal-key-bindings.el")
(declare-function wal/major "wal-key-bindings.el")
(declare-function wal/open-line "wal-func.el")
(declare-function wal/open-line-above "wal-func.el")
(declare-function wal/other-window "wal-func.el")

(defvar wal/ascii-whale)

(defgroup wal-key-bindings nil
  "Change key bindings settings."
  :group 'wal
  :tag "Key bindings")

;;;; Customization:

(defcustom wal/use-hyper-prefix t
  "Whether the hyper modifier should be used to prefix user keys."
  :type 'boolean
  :group 'wal-key-bindings)

;;;;;; American ranks:

(defcustom wal/general-key ","
  "The primary (or general) leader key."
  :type 'string
  :group 'wal-key-bindings)

(defcustom wal/colonel-key ";"
  "The secondary (or colonel) leader key."
  :type 'string
  :group 'wal-key-bindings)

(defcustom wal/major-key "."
  "The tertiary (or major) leader key."
  :type 'string
  :group 'wal-key-bindings)

(defcustom wal/major!-key "m"
  "The `major-mode'-specific key in `wal/major'."
  :type 'string
  :group 'wal-key-bindings)

(defcustom wal/captain-key "/"
  "The quaternary (or captain) leader key."
  :type 'string
  :group 'wal-key-bindings)

(defcustom wal/lieutenant-key "'"
  "The quinary (or lieutenant) leader key."
  :type 'string
  :group 'wal-key-bindings)
#+END_SRC

** Prefix Keys

*** Control

There are some non-standard control sequences. Anywhere:

+ =C->=/=C-<= expands/contracts region
+ =C-.= marks next like this allowing
  + =C-,= to delete last mark and
  + =C-/= to move it downward
+ =C-?= redoes (as =C-/= undoes).

User-reserved combinations are used for certain commands and
dispatches:

+ =C-c a= for =org-agenda=
+ =C-c b= for custom =beacon-blink=
+ =C-c c= does a =completion-at-point=
+ =C-c d= for =docker=
+ =C-c k= for =kmacro=
+ =C-c m= for =mu4e=
+ =C-c q= to do a =quick-calc= (inserted if called with =C-u=)
+ =C-c r= for =register=
+ =C-c s= to search with =consult-line=
+ =C-c t= for =vterm=.

When editing this config:

+ =C-c 9= to dispatch related commands.

*** Meta

There are a few non-standard meta sequences.

+ =M-o= does a custom =other-window=.

*** Hyper

Most hyper[fn:9] bindings are quick-access actions:

+ =H-8= calls =kubernetes-overview=
+ =H-i= switches =perspective=
+ =H-j= switches buffer using =consult=
+ =H-k= acts on the current point with =embark= (immediately if called
  with =C-u=)
+ =H-l= finds project file
+ =H-<mouse3>= adds another =multiple-cursor= at point
+ =H-m= shows version control status using =magit=
+ =H-n= searches project with =rg=
+ =H-p= switches projects
+ =H-y= expands snippets (in =yas-minor-mode=).

It's also used for some dispatches:

+ =H-o= for =ace-window=, and if called with =C-u=
+ =H-m= for =magit=
+ =H-n= for =rg=.

**** Caps to Hyper

I re-bound my =<CAPS>= (caps-lock) key to =Hyper_L= to use the hyper
bindings above. Therefore, all following keys should be right hand
keys.

If you use Xorg Display Server, the risky quite[fn:10] way would be to
edit your =/usr/share/X11/xkb/symbols/pc= file like so:

#+BEGIN_SRC
...
// key <CAPS> {    [ Caps_Lock     ]   };
key <CAPS> {    [ Hyper_L       ]   };
...
// modifier_map Lock   { Caps_Lock };
modifier_map Mod3   { Hyper_L, Hyper_R };
...
// modifier_map Mod4   { <HYPR> };
modifier_map Mod3   { <HYPR> };
#+END_SRC

A safer alternative might be to create an =.Xmodmap= file in your home
folder containing the following lines.

#+BEGIN_SRC conf :tangle no
! Assign Hyper_L to Caps_Lock
keycode 66 = Hyper_L
! Remove caps lock
remove lock = Caps_Lock
! Set hyper to mod3 from mod4
remove mod4 = Hyper_L
add mod3 = Hyper_L
#+END_SRC

This assumes that =Hyper_L= was assigned to modifier =Mod4= that's already
used by =Super_L= and modifier =Mod3= is an empty group. I haven't gotten
this safer alternative to work for me.

** Leader Keys

The are five =general= leader keys, each serving its unique purpose by
prefixing (groups of) actions by common context.

Some leader keys have so-called sinks for additional commands.

*** General

Leader key =general= (=,= by default) is responsible for Emacs actions
like loading a theme, finding a library, quitting, as well as opening
built-in programs like =eshell= and =eww=.

*** Colonel

Leader key =colonel= (=;= by default) provides a layer of useful editing
actions.

They are:

+ =c= to copy a line
+ =d= to duplicate lines
+ =m= to move a line
+ =q= to =query-replace=
+ =.= to mark all "like this"
+ =v= for =vundo= (visual undo)
+ =w= to kill a line
+ =x= to delete a line.

The sink for =colonel= provides alternative version of these calls.

They are:

+ =c= to copy a region
+ =d= to duplicate and comment
+ =h= to mark a region
+ =m= to move a region
+ =q= to =query-replace-regexp=
+ =.= to mark all ends in a region
+ =w= to kill a region
+ =x= to delete a region.

*** Major

Leader key =major= (=.= by default) deals with the (buffer-)local context.

It does this mostly through a =major-mode=-related =transient= bound to
the same key (=.= by default).

If the respective buffer-local =minor-mode= is active, the following
command maps and transients are bound:

+ =f= for =flycheck=
+ =l= for =lsp-mode=
+ =m= for =smerge=
+ =s= for =flyspell=
+ =v= for =verb=.

It also binds =hydra= commands:

+ =o= to resize the window
+ =t= to scale text
+ =v= to scroll the /other/ window.

*** Captain

Leader key =captain= (=/= by default) deals with the global context.

It gives access to minor-mode[fn:11] commands and =transient= maps that are
relevant globally (or for the current perspective). These are:

+ =c= for =org-roam=
+ =i= for =perspective=
+ =o= for =popper=
+ =p= for =projectile=
+ =w= for =winner=.

*** Lieutenant

Leader key =lieutenant= (='= by default) currently provides access to
command maps.

** Packages

*** general
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(cl-defmacro wal/create-leader-sink (name &key definer prefix)
  "Macro to create a leader sink `NAME-sink'.

NAME is the name of the macro. DEFINER is the definer to create
the sink for and PREFIX is its prefix."
  (declare (indent defun))
  (let* ((defname (symbol-name definer))
         (suf (substring prefix -1))
         (wk (upcase (concat (substring defname 4) "!"))))
    (progn
      (general-define-key :prefix prefix suf `(:ignore t :wk ,wk))
      `(defmacro ,name (&rest args)
         `(, ',definer ,@,`(mapcar (lambda (it)
                                     (if (stringp it)
                                         (concat ,suf it)
                                       it)) args))))))

(cl-defmacro wal/major! (fun &rest args)
  "Define key in `wal/major' definer for to call FUN.

All ARGS are passed to the definer."
  (declare (indent defun))
  `(wal/major :major-modes t ,@args
     ,wal/major!-key ',fun))

(cl-defmacro wal/colonel! (key fun mfun &rest args)
  "Bind FUN to KEY, MFUN in the sink.

All ARGS are passed to both definers."
  (declare (indent defun))
  `(progn
    (wal/colonel ,@args ,key ,fun)
    (wal/colonel-sink ,@args ,key ,mfun)))

(defun wal/prefix-user-key (user-key)
  "Prefix USER-KEY.

The default prefix is the hyper key unless Emacs is not running
in GUI mode or `wal/use-hyper-prefix' is nil."
  (let ((prefix (if (and wal/use-hyper-prefix
                         (or (daemonp) (display-graphic-p)))
                    "H-"
                  "C-c w ")))
    (concat prefix user-key)))

(defvar wal/leaders '(wal/general wal/colonel wal/major wal/captain wal/lieutenant))
(defvar wal/leader-with-sink '(wal/general wal/colonel))

(defun wal/general-create-definer (leader)
  "Create a definer for LEADER with a sink."
  (let* ((key-sym (intern (format "%s-key" leader)))
         (key (wal/prefix-user-key (symbol-value key-sym)))
         (sink (intern (format "%s-sink" leader)))
         (name (substring (symbol-name leader) 4)))
    (eval-after-load 'which-key `(which-key-add-key-based-replacements ,key ,name))
    (eval `(general-create-definer ,leader :prefix ,key))
    (when (memq leader wal/leader-with-sink)
      (eval `(wal/create-leader-sink ,sink :definer ,leader :prefix ,key)))))

(use-package general
  :config
  (mapc #'wal/general-create-definer wal/leaders)
  :demand)
#+END_SRC

*** hydra
:PROPERTIES:
:UNNUMBERED: t
:END:

Provides a context for related commands that can be (re-)executed in
quick succession.

These hydras are mapped to =lieutenant= using the following prefixes:

+ =d= for a minimal set of debugging keys using =dap-mode=
+ =o= to resize window
+ =t= to scale text
+ =v= to scroll other window
+ =w= to undo/redo window configurations using =winner=.

#+BEGIN_SRC emacs-lisp
(defun wal/ascii-whale-hydra-offset (&optional padding)
  "Get a string offset for the `wal/ascii-whale'.
Additional left PADDING can be passed."
  (let ((padd (or padding 0)))
    (make-string (+ padd (length wal/ascii-whale)) ? )))

(use-package hydra
  :demand)

(with-no-warnings
  ;; Scaling text in buffer.
  (defhydra wal/text-scale (:hint nil)
    "
%s`wal/ascii-whale Text size: _i_ncrease or _d_ecrease.
"
    ("i" text-scale-increase)
    ("d" text-scale-decrease)
    ("r" wal/text-scale-reset "reset" :color blue)
    ("q" nil "quit"))

  ;; Move window splitter or balance windows.
  (defhydra wal/resize-window (:hint nil)
    "
%s(wal/ascii-whale-hydra-offset 25)^_p_^
%s`wal/ascii-whale Move window splitter: _b_   _f_.
%s(wal/ascii-whale-hydra-offset 25)^_n_^
"
    ("b" wal/edge-left)
    ("f" wal/edge-right)
    ("n" wal/edge-down)
    ("p" wal/edge-up)
    ("o" wal/split-window-the-other-way "re-split" :color blue)
    ("l" balance-windows "balance" :color blue)
    ("q" nil "quit"))

  (defhydra wal/scroll-other-window (:hint nil)
    "
%s`wal/ascii-whale Scroll other window: u_p_/dow_n_.
"
    ("p" scroll-other-window-down)
    ("n" scroll-other-window)
    ("q" nil "quit")))

(wal/major
 "t" 'wal/text-scale/body
 "o" 'wal/resize-window/body
 "v" 'wal/scroll-other-window/body)
#+END_SRC

*** transient
:PROPERTIES:
:UNNUMBERED: t
:END:

Another nice way of grouping keys.

These following transients are bound in =lieutenant=:

+ =c= to edit this config if =wal/config-mode= is active

Some transients are bound directly, others are =wal/univ= variants (see
above).

#+BEGIN_SRC emacs-lisp
(use-package transient
  :custom
  (transient-hide-during-minibuffer-read t)
  (transient-show-popup 0.4)
  :demand)
#+END_SRC

** Additional (Un-)Bindings

Most bindings are declared in individual packages.

#+BEGIN_SRC emacs-lisp
;; Additional `general' bindings.
(wal/general
  "e" '(:ignore t :wk "Emacs")
  "eq" '(save-buffers-kill-terminal :wk "quit")
  "er" '(restart-emacs :wk "restart")
  "f" '(:ignore t :wk "find")
  "fc" '(wal/find-custom-file :wk "custom")
  "fi" '(wal/find-init :wk "init")
  "ff" '(wal/find-fish-config :wk "fish config")
  "fl" '(find-library :wk "library")
  "fw" '(wal/find-config :wk "wal")
  "fp" '(list-processes :wk "processes")
  "s" '(:ignore t :wk "set")
  "p" '(:ignore t :wk "package")
  "pf" '(package-refresh-contents :wk "refresh")
  "pi" '(package-install :wk "install")
  "pl" '(list-packages :wk "list")
  "pr" '(package-reinstall :wk "re-install")
  "pd" '(package-delete :wk "delete"))

(wal/general-sink
 "b" '(eww :wk "eww"))

(wal/colonel! "q" 'query-replace 'query-replace-regexp)

(wal/major "w" 'read-only-mode)

(wal/lieutenant "g" '(:keymap goto-map :wk "goto"))

(general-define-key
 :keymaps 'ctl-x-x-map
 "f" 'wal/find-file-delete-other-windows) ; Replaces `font-lock-update'.

;; Dealing with server buffers.
(general-define-key
 :predicate 'server-buffer-clients
 "C-c C-c" 'server-edit)

(general-define-key
 :predicate 'server-buffer-clients
 "C-c C-k" 'server-edit-abort)

;; Use H-u for C-u.
(when wal/use-hyper-prefix
  (let ((prefix (wal/prefix-user-key "u")))
    (general-define-key prefix 'universal-argument)
    (general-define-key
     :keymaps 'universal-argument-map
     prefix 'universal-argument-more)))

(global-set-key (kbd "C-?") #'undo-redo)
(global-set-key (kbd "M-o") #'wal/other-window)
(global-set-key (kbd "C-;") #'comment-line)
(global-set-key (kbd "C-c c") #'completion-at-point)

(global-unset-key (kbd "C-x C-c")) ;; Unbinds `save-buffers-kill-terminal'.
#+END_SRC

** Additional Mode Controls

Turning on/off certain major modes switching between =major-mode= and
=fundamental-mode=.

#+BEGIN_SRC emacs-lisp
(defvar wal/before-fundamental-mode nil
  "The major mode before fundamental was engaged.")

(defun wal/fundamental-mode ()
  "Switch from `major-mode' to `fundamental-mode' and back."
  (interactive)
  (let ((m-mode major-mode))
    (if wal/before-fundamental-mode
        (progn
          (funcall wal/before-fundamental-mode)
          (setq wal/before-fundamental-mode nil))
      (fundamental-mode)
      (make-local-variable 'wal/before-fundamental-mode)
      (setq wal/before-fundamental-mode m-mode))))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-key-bindings)

;;; wal-key-bindings.el ends here
#+END_SRC

* Utility
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-func.el" wal/emacs-config-package-path)
:END:

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-func.el --- Utilities. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provides functions and macros to simplify various configurations.

;;; Code:

(eval-when-compile
  (require 'marginalia nil t))

(declare-function marginalia-annotate-binding "ext:marginalia.el")
(declare-function use-package-report "ext:use-package-core.el")

(defvar use-package-compute-statistics)

(defgroup wal-func nil
  "Change values used in utility functions."
  :group 'wal
  :tag "Utility")

;;;; Customization:

(defcustom wal/delete-trailing-whitespace t
  "Whether to delete trailing whitespace."
  :type 'boolean
  :group 'wal-func)

(defcustom wal/gc-cons-threshold-in-mb 200
  "The default `gc-cons-threshold' expressed in MB."
  :type 'integer
  :group 'wal-func)
#+END_SRC

** Directories

Finding files should =mkdir -p= its parents.

#+BEGIN_SRC emacs-lisp
(defun wal/maybe-make-directory (dir)
  "Create DIR unless it exists."
  (unless (file-directory-p dir)
    (make-directory dir)))

;; Creating parent dirs.
(defun wal/create-non-existent-directory ()
  "Ask whether to create non-existent directory.
If a file is found in a not (yet) existing directory, ask if it
should get created."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Create non-existing directory `%s'? " parent-directory)))
               (make-directory parent-directory t))))

(add-to-list 'find-file-not-found-functions #'wal/create-non-existent-directory)
#+END_SRC

** Buffer Display

Utility functions to configure displaying buffers of a certain type.

#+BEGIN_SRC emacs-lisp
(defun wal/display-buffer-condition (buffer-or-mode)
  "Get a display buffer condition for BUFFER-OR-MODE."
  (pcase buffer-or-mode
    ((pred stringp) buffer-or-mode)
    ((pred symbolp) `(lambda (bufname _)
                       (with-current-buffer bufname
                         (equal major-mode ',buffer-or-mode))))
    (_ nil)))

(defun wal/display-buffer-in-pop-up (buffer &optional in-frame)
  "Display BUFFER in a pop-up.
The pop-up is a window unless IN-FRAME is t."
  (let ((condition (wal/display-buffer-condition buffer))
        (dispfun (if in-frame
                     'display-buffer-pop-up-frame
                   'display-buffer-pop-up-window)))
    (add-to-list 'display-buffer-alist
                 `(,condition
                   (,dispfun)))))

;; The next two functions make sense for `popper' buffers.

(cl-defun wal/display-buffer-in-side-window (buffer &key side loose no-other height)
  "Display BUFFER in SIDE window.

This window will be on SIDE (on the bottom by default), not
delete other windows, dedicated to the buffer (unless LOOSE),
available to `other-window' (unless NO-OTHER) 20 (or HEIGHT)
lines high and visible frames are considered reusable."
  (let ((condition (wal/display-buffer-condition buffer)))
    (add-to-list 'display-buffer-alist
                 `(,condition
                   (display-buffer-reuse-window display-buffer-in-side-window)
                   (side . ,(or side 'bottom))
                   (dedicated . ,(not loose))
                   (reusable-frames . visible)
                   (window-height . ,(or height 10))
                   (window-parameters . ((no-other-window . ,no-other)))))))

(defun wal/display-buffer-in-direction (buffer &optional direction)
  "Display BUFFER in direction.
The direction is right-most or DIRECTION."
  (let ((condition (wal/display-buffer-condition buffer)))
    (add-to-list 'display-buffer-alist
                 `(,condition
                   (display-buffer-reuse-mode-window display-buffer-in-direction)
                   (direction . ,(or direction 'rightmost))))))

(defun wal/display-buffer-ethereally (buffer)
  "Display BUFFER ethereally.

This means there is no display function used and the mode line is
removed."
  (let ((condition (wal/display-buffer-condition buffer)))
    (add-to-list 'display-buffer-alist
                 `(,condition
                   nil
                   (window-parameters (mode-line-format . none))))))

(defun wal/display-buffer-reuse-same-window (buffer)
  "Display BUFFER reusing same window."
  (let ((condition (wal/display-buffer-condition buffer)))
    (add-to-list 'display-buffer-alist
                 `(,condition
                   (display-buffer-reuse-window display-buffer-same-window)))))

;; Prefer short-hands.
(defalias 'wdb/pop-up 'wal/display-buffer-in-pop-up)
(defalias 'wdb/side 'wal/display-buffer-in-side-window)
(defalias 'wdb/direction 'wal/display-buffer-in-direction)
(defalias 'wdb/ghost 'wal/display-buffer-ethereally)
(defalias 'wdb/same 'wal/display-buffer-reuse-same-window)
#+END_SRC

** Editing

More convenient editing.

#+BEGIN_SRC emacs-lisp
(defun wal/advise-hack-local-variables (&rest _r)
  "Advise to conditionally add before save hook.

When `wal/delete-trailing-whitespace' is t, trailing whitespace
is deleted."
  (when wal/delete-trailing-whitespace
    (add-hook 'before-save-hook #'delete-trailing-whitespace nil t)))

(advice-add
 'hack-local-variables :after
 #'wal/advise-hack-local-variables)

(defun wal/kill-ring-save-whole-buffer ()
  "Call `kill-ring-save' on the entire buffer."
  (interactive)
  (kill-ring-save (point-min) (point-max)))
#+END_SRC

** Windows

I keep messing up, splitting vertically when I meant horizontally.
This is inspired by [[https://github.com/purcell/emacs.d/blob/master][purcell's config]].

#+BEGIN_SRC emacs-lisp
(defun wal/split-window-the-other-way ()
  "Split window the other way.
This means if horizontally split, split vertically; if vertically
split, split horizontally."
  (interactive)
  (let* ((other-buffer (and (next-window) (window-buffer (next-window))))
         (win (selected-window))
         (split-direction (cond ((or (windows-sharing-edge win 'above)
                                     (windows-sharing-edge win 'below))
                                 'vert)
                                ((or (windows-sharing-edge win 'right)
                                     (windows-sharing-edge win 'left))
                                 'hori)
                                (t nil))))
    (delete-other-windows)
    (pcase split-direction
      ('vert (split-window-horizontally))
      ('hori (split-window-vertically))
      (_ nil))
    (when other-buffer
      (set-window-buffer (next-window) other-buffer))))

(defun wal/edge (scale-above scale-below)
  "Move the window splitter using SCALE-ABOVE and SCALE-BELOW."
  (interactive)
  (let* ((win (selected-window))
         (direction (cond ((windows-sharing-edge win 'above) scale-above)
                          ((windows-sharing-edge win 'below) scale-below)
                          (t nil))))
    (pcase direction
      ('enlarge (wal/enlarge-window))
      ('shrink (wal/shrink-window))
      (_ (message "Selected window does not share a vertical edge with another window")))))

(defun wal/edge-horizontally (scale-left scale-right)
  "Move the window splitter using SCALE-LEFT and SCALE-RIGHT."
  (interactive)
  (let* ((win (selected-window))
         (direction (cond ((windows-sharing-edge win 'left) scale-left)
                          ((windows-sharing-edge win 'right) scale-right)
                          (t nil))))
    (pcase direction
      ('enlarge (wal/enlarge-window-horizontally))
      ('shrink (wal/shrink-window-horizontally))
      (_ (message "Selected window does not share a horizontal edge with another window")))))

(defun wal/edge-left ()
  "Move the splitter of the selected window left.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge-horizontally 'enlarge 'shrink))

(defun wal/edge-right ()
  "Move the splitter of the selected window right.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge-horizontally 'shrink 'enlarge))

(defun wal/edge-up ()
  "Move the splitter of the selected window up.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge 'enlarge 'shrink))

(defun wal/edge-down ()
  "Move the splitter of the selected window down.
This shrinks or enlarges the window depending on its position."
  (interactive)
  (wal/edge 'shrink 'enlarge))

(defun wal/shrink-window (&optional horizontally)
  "Shrink the selected window (HORIZONTALLY)."
  (interactive)
  (let* ((available (window-min-delta (selected-window) horizontally))
         (chunk (floor (* available 0.2))))
    (if horizontally
        (shrink-window-horizontally chunk)
      (shrink-window chunk))))

(defun wal/shrink-window-horizontally ()
  "Shrink the selected window horizontally."
  (interactive)
  (wal/shrink-window t))

(defun wal/enlarge-window (&optional horizontally)
  "Enlarge the selected window (HORIZONTALLY)."
  (interactive)
  (let* ((available (window-max-delta (selected-window) horizontally))
         (chunk (floor (* available 0.2))))
    (if horizontally
        (enlarge-window-horizontally chunk)
      (enlarge-window chunk))))

(defun wal/enlarge-window-horizontally ()
  "Enlarge the selected window horizontally."
  (interactive)
  (wal/enlarge-window t))

(defun wal/other-window ()
  "Switch to other window.

If the minibuffer is active, switch to that. If there's another
frame, switch to that. Otherwise switch to next buffer."
  (interactive)
  (cond
   ((active-minibuffer-window)
    (switch-to-minibuffer))
   ((not (equal (next-frame) (selected-frame)))
    (other-frame 1))
   ((one-window-p)
    (switch-to-buffer nil))
   (t
    (other-window 1))))
#+END_SRC

*** walled-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Minor mode to dedicate buffers to windows.

#+BEGIN_SRC emacs-lisp
(define-minor-mode walled-mode
  "Dedicate the window."
  :init-value nil
  :lighter " wld"
  (cond
   (noninteractive
    (setq walled-mode nil))
   (walled-mode
    (walled-mode--enable))
   (t
    (walled-mode--disable))))

(defun walled-mode--enable ()
  "Dedicate the window to the current buffer."
  (let ((window (selected-window))
        (bufname (current-buffer)))
    (set-window-dedicated-p window bufname)
    (message "Dedicating window to %s" bufname)))

(defun walled-mode--disable ()
  "Make window no longer dedicated to its buffer."
  (let* ((window (selected-window))
         (bufname (window-dedicated-p window)))
    (set-window-dedicated-p window nil)
    (message "Window no longer dedicated to %s" bufname)))
#+END_SRC

** Frames

Each window has a frame.

#+BEGIN_SRC emacs-lisp
(defun wal/posframe-hidehandler-when-invisible (info)
  "Check INFO whether the parent buffer is invisible."
  (when-let ((parent (cdr (plist-get info :posframe-parent-buffer))))
    (not (get-buffer-window parent t))))
#+END_SRC

** Garbage Collection

Better(?) garbage collection.

#+BEGIN_SRC emacs-lisp
(defun wal/bytes-per-mb (num)
  "Return the integer value of NUM megabytes in bytes.

This function may be used to set variables that expect bytes."
  (floor (* 1024 1024 num)))

(defun wal/minibuffer-setup-hook ()
  "Increase `gc-cons-threshold' to maximum on minibuffer setup."
  (setq gc-cons-threshold most-positive-fixnum))

(defun wal/minibuffer-exit-hook ()
  "Decrease `gc-cons-threshold' on minibuffer exit."
  (setq gc-cons-threshold (wal/bytes-per-mb wal/gc-cons-threshold-in-mb)))

(add-hook 'minibuffer-setup-hook #'wal/minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook #'wal/minibuffer-exit-hook)
(add-hook 'emacs-startup-hook #'wal/minibuffer-exit-hook)
#+END_SRC

** Files

Handling of files.

#+BEGIN_SRC emacs-lisp
(defun wal/find-file-delete-other-windows (filename &optional wildcards)
  "Find FILENAME and make its window the only window.

If WILDCARDS is non-nil, FILENAME can include wildcards. All
matching files are visited but only the last-visited displayed."
  (interactive
   (find-file-read-args "Find file (deleting other windows): "
                        (confirm-nonexistent-file-or-buffer)))
  (let ((value (find-file-noselect filename nil nil nil)))
    (if (listp value)
        (progn
          (setq value (nreverse value))
          (switch-to-buffer (car value))
          (mapc 'switch-to-buffer (cdr value))
          value)
      (switch-to-buffer value)
      (delete-other-windows))))

(defun wal/find-custom-file ()
  "Find the custom file."
  (interactive)
  (switch-to-buffer (find-file-noselect (file-truename custom-file))))

(defun wal/find-fish-config ()
  "Find the fish shell config file."
  (interactive)
  (let* ((files '("~/.config/fish/config.fish"
                  "~/.config/omf"))
         (init-file (cl-find-if
                     'file-exists-p
                     (mapcar 'expand-file-name files))))
    (if init-file
        (switch-to-buffer (find-file-noselect (file-truename init-file)))
      (user-error "Couldn't find fish config file"))))
#+END_SRC

** Command Line

Capture custom command line flags.

#+BEGIN_SRC emacs-lisp
(defvar wal/doctor nil)

(defconst wal/custom-flags
  '((doctor . "--doctor"))
  "Alist of custom flags that can be passed to Emacs.")

(defun wal/capture-flag (flag)
  "Check for custom FLAG and delete it from the command line arguments."
  (when-let* ((flag (cdr (assoc flag wal/custom-flags)))
              (found (member flag command-line-args)))
    (setq command-line-args (delete flag command-line-args))
    t))

;; Flag `--doctor' will set up `use-package' to collect statistics and
;; turn on `explain-pause-mode'.
(when (wal/capture-flag 'doctor)
  (setq wal/doctor t))
#+END_SRC

** Text Scaling

Allow resetting =text-scale=.

#+BEGIN_SRC emacs-lisp
(defun wal/text-scale-reset ()
  "Reset `text-scale' level to 0."
  (interactive)
  (text-scale-set 0))
#+END_SRC

** Lists

Manipulating lists.

#+BEGIN_SRC emacs-lisp
(defun wal/append (sym seq)
  "Set list SYM to it with SEQ appended.

Duplicate items are removed."
  (set sym (delq nil (delete-dups (append (symbol-value sym) seq)))))

(defun wal/replace-in-alist (target values)
  "Edit TARGET alist in-place using VALUES."
  (if (seq-every-p (lambda (it) (assoc (car it) target)) values)
      (seq-each (lambda (it) (map-put! target (car it) (cdr it))) values)
    (user-error "All keys bust be already present in list")))
#+END_SRC

** Commands

Make function calls even more versatile.

#+BEGIN_SRC emacs-lisp
(cl-defmacro wal/univ (a b)
  "Define a prefix-modified function for A.

It will call B instead if the default `universal-argument' is
present. It will again call A with `universal-argument' if the
function is called with two `C-u' or more.

Both functions will be called interactively."
  (declare (indent defun))
  (let ((a-name (symbol-name a))
        (b-name (symbol-name b)))
    `(defun ,(intern (concat "wal/univ-" a-name)) (&optional call-other)
       ,(concat (format "Call `%s' or `%s' depending on prefix argument."
                        a-name
                        b-name)
                "\n"
                "No argument means: call the prior. "
                "A single `C-u' means: call the latter. "
                "Two or more `C-u' means: call the prior with `universal-argument'.")
       (interactive "P")
       (if (> (prefix-numeric-value call-other) 4)
           (call-interactively ',a)
         (setq current-prefix-arg nil)
         (prefix-command-update)
         (if call-other
             (call-interactively ',b)
           (call-interactively ',a))))))
#+END_SRC

** Helpers

Some more helper functions.

#+BEGIN_SRC emacs-lisp
(defun wal/biased-random (limit &optional bias-low throws)
  "Return a biased random number using LIMIT.

The bias is the high end unless BIAS-LOW is passed. The number of
throws are 3 or THROWS."
  (let ((results (list))
        (throws (or throws 3)))
    (dotimes (i throws)
      (add-to-list 'results (random limit)))
    (if bias-low
        (seq-min results)
      (seq-max results))))

(defun wal/maybe-intern (symbol?)
  "Maybe `intern' SYMBOL? if it's not a symbol."
  (if (symbolp symbol?)
      symbol?
    (intern symbol?)))

(defun wal/truncate (text max-len)
  "Truncate TEXT if longer than MAX-LEN."
  (if (> (length text) max-len)
      (concat (substring text 0 (max (- max-len 3) 1)) "...")
    text))

(defun wal/univ-p ()
  "Check if the `current-prefix-arg' is the `universal-argument'.

This is mainly useful for non-interactive functions."
  (equal current-prefix-arg '(4)))

(defun wal/reset-to-standard (sym &optional locally)
  "Reset symbol SYM to its standard value.
If LOCALLY is t, the local variable is killed while its global
value is left untouched."
  (if locally
      (if (local-variable-p sym)
          (kill-local-variable sym)
        (user-error "'%s' has no local binding" sym))
    (set-default sym (eval (car (get sym 'standard-value))))))

(defmacro wal/try (package &rest body)
  "Exceute BODY if PACKAGE can be required."
  (declare (indent 1))
  `(when (require ',package nil :no-error) ,@body))
#+END_SRC

** Setup

Allow differentiating between initial and repeated setups.

#+BEGIN_SRC emacs-lisp
(defvar wal/setup-list '()
  "List of already performed setups.")

(cl-defmacro wal/define-init-setup (name docs &key initial always immediately)
  "Define an initial setup for NAME documented by DOCS.

The INITIAL setup is only run once. The ALWAYS one on every call.

In daemon-mode the function may be called IMMEDIATELY. An
appropriate hook is chosen for the original call."
  (declare (indent defun) (doc-string 2))
  (let ((func-name (intern (concat "wal/init-setup-" (symbol-name name)))))
    `(progn
       (defun ,func-name ()
         ,(format "Do base setup for %s. Do minimal setup on repeats.\n%s" name docs)
         (unless (memq ',name wal/setup-list)
           (progn
             (message "Initial setup of '%s'" ,(symbol-name name))
             ,@initial
             (add-to-list 'wal/setup-list ',name)))
         ,@always)
       (if (daemonp)
           (progn
             (when ,immediately
               (funcall ',func-name))
             (add-hook 'server-after-make-frame-hook #',func-name))
         (add-hook 'emacs-startup-hook #',func-name)))))
#+END_SRC

** Regions

Act on regions.

#+BEGIN_SRC emacs-lisp
(defun wal/duck-duck-go-region ()
  "Query duckduckgo with active region."
  (interactive)
  (if mark-active
      (let* ((beg (region-beginning))
             (end (region-end))
             (str (buffer-substring-no-properties beg end))
             (hex-str (url-hexify-string str)))
        (browse-url
         (concat "https://duckduckgo.com/html/?q=" hex-str)))
    (user-error "No active region")))
#+END_SRC

** Messages

Show messages without cluttering.

#+BEGIN_SRC emacs-lisp
(defconst wal/ascii-whale (propertize "}< ,.__)" 'face 'mode-line-emphasis)
  "A small, highlighted ASCII whale.")

(defun wal/message-in-a-bottle (bottle)
  "Randomly display a message from the given BOTTLE.

That bottle is just an array of strings."
  (let* ((message-log-max nil) ; Don't clutter.
         (rand (wal/biased-random (length bottle)))
         (mess (nth rand bottle))
         (prop-mess (propertize mess 'face 'italic)))
    (message (concat wal/ascii-whale " " prop-mess))))
#+END_SRC

** Expansion Packs

Some packages are opt-in (will not be ensured) and belong to one or
several so-called expansion packs[fn:12].

#+BEGIN_SRC emacs-lisp
(defvar wal/expansion-packs nil
  "Packs of expansion packages to be installed using `wal/install-expansion-pack'.

Individual languages build this list using macro
`wal/define-expansion-pack'.")

(cl-defun wal/install-packages (packages &key delete-windows on-done)
  "Install all PACKAGES unless already installed.
Concludes by calling `delete-other-windows' if DELETE-WINDOWS is
t, printing optional message ON-DONE."
  (let ((installed (mapcar (lambda (it)
                             (when (not (package-installed-p it))
                               (package-install it)))
                           packages)))
    (if (and on-done (= 0 (length (seq-filter #'identity installed))))
        (message "Packages already installed.")
      (when (and on-done (stringp on-done))
        (message on-done))))
  (when delete-windows
    (delete-other-windows)))

(cl-defmacro wal/define-expansion-pack (name docs &key packages extras)
  "Define an expansion pack of PACKAGES under NAME documented with DOCS."
  (declare (indent defun) (doc-string 2))
  `(add-to-list
    'wal/expansion-packs
    '(,name . (:packages ,packages :extras ,extras :docs ,docs))))

(defun wal/is-expansion-pack (pack)
  "Check if PACK is an expansion pack package."
  (let ((packages (seq-reduce (lambda (acc it)
                                (let* ((pl (cdr it))
                                       (p (plist-get pl :packages))
                                       (e (plist-get pl :extras)))
                                  (append acc p e)))
                              wal/expansion-packs
                              '())))
    (memq pack packages)))

(defun wal/install-expansion-pack-extra (pack)
  "Install an or all extras of an expansion for PACK."
  (let* ((extras (plist-get (cdr pack) :extras))
         (selection (completing-read "Select extra to install: "
                                     (append extras '(all))))
         (sym (wal/maybe-intern selection)))
    (pcase sym
      ('all
       (wal/install-packages extras :on-done "Installed all extras."))
      (_
       (wal/install-packages
        (list sym) :on-done (format "Installed extra '%s'." sym))))))

(defun wal/install-expansion-pack (pack)
  "Install the given expansion PACK."
  (interactive
   (list (completing-read "Select pack to install: "
                          (mapcar (lambda (pack) (car pack)) wal/expansion-packs))))
  (let* ((sym (wal/maybe-intern pack))
         (item (assoc sym wal/expansion-packs))
         (core-packages (plist-get (cdr item) :packages))
         (extras (plist-get (cdr item) :extras)))
    (if item
        (progn
          (wal/install-packages core-packages :on-done (format "Installed expansion pack '%s'." pack))
          (when (and extras (yes-or-no-p "Want to install an extras?"))
            (wal/install-expansion-pack-extra item)))
      (user-error "Unknown pack '%s', check `wal/expansion-packs'" sym))))

(defun wal/expansion--stringify (package-list)
  "Stringify PACKAGE-LIST."
  (if package-list (string-join (mapcar (lambda (it) (format "%s" it)) package-list) ", ") ""))

;; Make completion look nice.
(with-eval-after-load 'marginalia
  (defun wal/annotate-expansion-pack (candidate)
    "Annotate CANDIDATE expansion pack."
    (let* ((item (assoc (intern candidate) wal/expansion-packs))
           (docs (plist-get (cdr item) :docs))
           (packages (wal/expansion--stringify (plist-get (cdr item) :packages)))
           (extras (wal/expansion--stringify (plist-get (cdr item) :extras))))
      (marginalia--fields
       (docs :face 'marginalia-documentation :truncate 0.6)
       (packages :face 'marginalia-value :truncate 0.8)
       (extras :face 'marginalia-value :truncate 0.4))))

  (add-to-list 'marginalia-annotator-registry '(expansion-pack wal/annotate-expansion-pack builtin none))
  (add-to-list 'marginalia-command-categories '(wal/install-expansion-pack . expansion-pack)))
#+END_SRC

** Hooks

#+BEGIN_SRC emacs-lisp
(cl-defmacro wal/lang-hook (name docs &body body &key messages lsp tabs &allow-other-keys)
  "Hook into NAME, describe with DOCS.

MESSAGES is a list of strings.

LSP is either t or nil.

TABS is either nil, t or a symbol. Unless the symbol is `always',
tabs are enabled using `wal/maybe-enable-tabs', passing it to the
function as an indentation function.

The rest of the BODY will be spliced into the lambda."
  (declare (indent defun) (doc-string 2))
  (let ((target (intern (concat (symbol-name name) "-hook")))
        (safe-body (cl-loop for (key val) on body by 'cddr
                            unless (memq key '(:messages :lsp :tabs))
                            collect key
                            and collect val)))
    `(add-hook
      ',target
      (lambda ()
        ,(when messages
           `(wal/message-in-a-bottle ,messages))
        ,(cond ((eq 'always tabs)
                `(wal/enable-tabs))
               ((eq t tabs)
                `(wal/maybe-enable-tabs))
               ((not tabs)
                '(wal/disable-tabs))
               (t `(wal/maybe-enable-tabs :indent-with ,tabs)))
        ,@safe-body
        ,(when lsp
           '(wal/lsp))))))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-func)

;;; wal-func.el ends here
#+END_SRC

* Look
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-look.el" wal/emacs-config-package-path)
:END:

Make frame transparent and set themes. [[https://peach-melpa.org/][PeachMelpa]] has more themes.

#+BEGIN_SRC emacs-lisp
;;; wal-look.el --- Look.

;;; Commentary:
;;
;; Provide packages for the look of the config.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(defvar wal/experimental)

(defgroup wal-look nil
  "Change the look."
  :group 'wal
  :tag "Look")

;;;; Customization:

(defcustom wal/transparency 90
  "The default frame transparency."
  :type 'integer
  :group 'wal-look)

(defcustom wal/theme nil
  "The theme."
  :type '(choice symbol (const nil))
  :group 'wal-look)

(defun wal/transparency (&optional value)
  "Set the transparency of the frame to VALUE.
1 being (almost) completely transparent, 100 being opaque.

This also updates variable `wal/transparency' for the duration of
the session."
  (interactive "nSet transparency (1-100): ")
  (let ((transparency (min (max (or value wal/transparency) 1) 100)))
    (setq wal/transparency transparency)
    (if wal/experimental
        (modify-all-frames-parameters `((alpha-background . ,transparency)))
      (modify-all-frames-parameters `((alpha . ,transparency))))))

(defvar wal/active-theme nil)

(defun wal/load-active-theme ()
  "Load the currently active theme."
  (interactive)
  (when wal/active-theme
    (when (custom-theme-p wal/active-theme)
      (enable-theme wal/active-theme))
    (load-theme wal/active-theme t)))

;; Some themes require configuration, so we only load after initialization.
(wal/define-init-setup visuals
  "Set up visual frills like theme and transparency."
  :initial
  ((if wal/experimental
       (add-to-list 'default-frame-alist `(alpha-background . ,wal/transparency))
     (add-to-list 'default-frame-alist `(alpha . ,wal/transparency)))
   (when wal/theme
     (setq wal/active-theme wal/theme)
     (wal/load-active-theme)))
  :always
  ((wal/transparency)
   (wal/load-active-theme))
  :immediately t)

;; Mix of old and new.
(setq frame-title-format '(multiple-frames "%b" ("%b@" system-name)))

(provide 'wal-look)

;;; wal-look.el ends here
#+END_SRC

* Fonts
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-fonts.el" wal/emacs-config-package-path)
:END:

Set fonts (with preference). To get support for ligatures, install the
symbol font from [[https://github.com/tonsky/FiraCode/files/412440/FiraCode-Regular-Symbol.zip][here]].

#+BEGIN_SRC emacs-lisp
;;; wal-fonts.el --- Fonts.

;;; Commentary:
;;
;; Provide font setup and configuration.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wal/general "wal-key-bindings.el")

(defgroup wal-fonts nil
  "Change fonts and font sizes."
  :group 'wal
  :tag "Fonts")

;;;; Customization:

(defcustom wal/fixed-fonts
  '("JetBrains Mono"
    "Iosevka"
    "Fira Code"
    "Hasklig"
    "Input Mono"
    "mononoki"
    "Source Code Pro"
    "DejaVu Sans Mono"
    "Monoid" ; The calt version doesn't work properly.
    "Liberation Mono")
  "Fixed fonts ordered by preference."
  :type '(repeat string)
  :group 'wal-fonts)

(defcustom wal/variable-fonts
  '("Roboto"
    "Ubuntu"
    "Liberation Serif"
    "DeJa Vu Sans"
    "Lato"
    "Quicksand"
    "San Francisco"
    "Arial")
  "Variable fonts ordered by preference."
  :type '(repeat string)
  :group 'wal-fonts)

(defcustom wal/preferred-fonts nil
  "List of (fixed and variable width) font names that should be preferred."
  :type '(choice (repeat string) (const nil))
  :group 'wal-fonts)

(defcustom wal/fixed-font-height 120
  "The font height for fixed fonts.
The default value is 98."
  :type 'integer
  :group 'wal-fonts)

(defcustom wal/variable-font-height 140
  "The font height for variable fonts.
This has no default value."
  :type 'integer
  :group 'wal-fonts)

(defvar wal/fonts-updated-hook nil
  "Functions to run when fonts were updated.")

(defun wal/font-update (attribute value faces)
  "Set ATTRIBUTE to VALUE for FACES."
  (mapc (lambda (it)
    (when (internal-lisp-face-p it)
      (set-face-attribute it nil attribute value)))
    faces)
  (run-hooks 'wal/fonts-updated-hook))

(defun wal/select-fixed-font (font)
  "Select fixed (available) FONT."
  (interactive
   (list (completing-read "Select font: " (wal/available-fonts wal/fixed-fonts))))
  (wal/font-update :font font '(default fixed-pitch)))

(defun wal/set-fixed-font-height (&optional height)
  "Set the HEIGHT for fixed fonts."
  (interactive "nSet fixed font height: ")
  (let ((sensible-height (max (min height 200) 80)))
    (wal/font-update :height sensible-height '(default fixed-pitch))
    (setq wal/fixed-font-height sensible-height)))

(defun wal/select-variable-font (font)
  "Select variable (available) FONT."
  (interactive
   (list (completing-read "Select font: " (wal/available-fonts wal/variable-fonts))))
  (wal/font-update :font font '(variable-pitch)))

(defun wal/set-variable-font-height (&optional height)
  "Set the HEIGHT for variable fonts."
  (interactive "nSet variable font height: ")
  (let ((sensible-height (max (min height 200) 80)))
    (wal/font-update :height sensible-height '(variable-pitch))
    (setq wal/variable-font-height sensible-height)))

(defun wal/available-fonts (fonts)
  "Filter FONTS down to available fonts."
  (seq-filter (lambda (it) (find-font (font-spec :name it))) fonts))

(defun wal/preferred-fonts (fonts)
  "Filter FONTS down to preferred fonts."
  (seq-filter (lambda (it) (member it wal/preferred-fonts)) fonts))

(defun wal/fonts-candidate (fonts &optional prefer)
  "Return the first available font from a list of FONTS.
If PREFER is true, variable `wal/preferred-fonts' is not nil and
preferred fonts are available, return the first of those
instead."
  (let* ((available-fonts (wal/available-fonts fonts))
         (preferred (and prefer (wal/preferred-fonts available-fonts))))
    (if preferred
        (car preferred)
      (car available-fonts))))

(wal/define-init-setup fonts
  "Set up fonts for GUI Emacs.

This sets `default' and `fixed-pitch' fonts to the first
available candidate from `wal/fixed-fonts'. Does the same for
`variable-pitch' using `wal/variable-fonts'."
  :initial
  ((when (or (daemonp) (display-graphic-p))
     (mapc (lambda (it)
             (when (internal-lisp-face-p it)
               (set-face-attribute it nil
                                   :font (wal/fonts-candidate wal/fixed-fonts t)
                                   :height wal/fixed-font-height)))
           '(default fixed-pitch))
     (mapc (lambda (it)
             (when (internal-lisp-face-p it)
               (set-face-attribute it nil :inherit 'mode-line)))
           '(mode-line-active mode-line-inactive))
     ;; Variable pitch face.
     (set-face-attribute 'variable-pitch nil
                         :font (wal/fonts-candidate wal/variable-fonts t)
                         :height wal/variable-font-height)))
  :always
  ((run-hooks 'wal/fonts-updated-hook)))

;; Slanted and enchanted.
(defun wal/font-lock ()
  "Set comment face to italic and keyword face to bold."
  (set-face-attribute 'font-lock-comment-face nil :slant 'italic :weight 'normal)
  (set-face-attribute 'font-lock-keyword-face nil :weight 'bold))

(wal/general
 "sf" '(wal/set-fixed-font-height :wk "fixed height")
 "sv" '(wal/set-variable-font-height :wk "variable height")
 "sF" '(wal/select-fixed-font :wk "fixed family")
 "sV" '(wal/select-variable-font :wk "variable family"))

(add-hook 'font-lock-mode-hook #'wal/font-lock)

(provide 'wal-fonts)

;;; wal-fonts.el ends here
#+END_SRC

* Emacs
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-emacs.el" wal/emacs-config-package-path)
:END:

Everything that has to do with Emacs-y stuff.

This is a combination of configurations for built-in packages[fn:13]
and some external ones.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-emacs.el --- Emacs. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide Emacs settings/configurations.

;;; Code:

(eval-when-compile
  (require 'transient))

(declare-function wal/captain "wal-key-bindings.el")
(declare-function wdb/side "wal-func.el")
(declare-function wdb/direction "wal-func.el")
(declare-function comint-check-proc "ext:comint.el")

(defvar wal/experimental)

(wdb/direction 'help-mode)
(wdb/direction 'shortdoc-mode)
(wdb/side 'debug-mode)
#+END_SRC

** Improved Editing

Sometimes I need to see whitespace chars.

*** text-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

No double spaces in sentences.

#+BEGIN_SRC emacs-lisp
(defun wal/text-mode ()
  "Hook into `text-mode'."
  ;; Activate `flyspell-mode' when editing commit messages.
  (when (string-match "COMMIT_EDITMSG" (buffer-name))
    (flyspell-mode)))

(use-package text-mode
  :custom
  (sentence-end-double-space nil)
  :hook (text-mode . wal/text-mode)
  :ensure nil)
#+END_SRC

*** abbrev
:PROPERTIES:
:UNNUMBERED: t
:END:

Automatic quick expansion.

#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :config
  (setq save-abbrevs nil)
  (define-abbrev-table 'elixir-mode-abbrev-table '(("p" "|>")))
  :hook ((elixir-mode) . abbrev-mode)
  :ensure nil
  :delight " abb")
#+END_SRC

*** follow-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Follow me around.

#+begin_src emacs-lisp
(use-package follow-mode
  :custom
  (follow-mode-line-text " flw")
  :ensure nil)
#+end_src

*** diff-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Effing diffing.

#+BEGIN_SRC emacs-lisp
(use-package diff-mode
  :config
  (define-key diff-mode-shared-map (kbd "o") nil) ; Removes `diff-goto-source'.
  :ensure nil)
#+END_SRC

*** tabulated-list
:PROPERTIES:
:UNNUMBERED: t
:END:

According to my tabulations, your columns are too small.

#+BEGIN_SRC emacs-lisp
(use-package tabulated-list
  :bind
  (:map tabulated-list-mode-map
   ("M-p" . tabulated-list-previous-column)
   ("M-n" . tabulated-list-next-column)
   ("M-f" . tabulated-list-widen-current-column)
   ("M-b" . tabulated-list-narrow-current-column))
  :ensure nil)
#+END_SRC

*** hideshow
:PROPERTIES:
:UNNUMBERED: t
:END:

Hide blocks.

#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :general
  (wal/major :keymaps 'hs-minor-mode-map
    "h" '(hs-toggle-hiding :wk "toggle hiding"))
  :ensure nil)
#+END_SRC

*** kmacro
:PROPERTIES:
:UNNUMBERED: t
:END:

Some people need macros, okay?

#+BEGIN_SRC emacs-lisp
(use-package kmacro
  :config
  (transient-define-prefix wal/kmacro ()
    "Access `kmacro' commands."
    [["Macro"
      ("s" "start (or insert)" kmacro-start-macro-or-insert-counter)
      ("m" "end (or call)" kmacro-end-or-call-macro)]
     ["Narrow"
      ("c" "complete" consult-kmacro
       :inapt-if-not (lambda () (featurep 'consult)))]])
  :bind
  ("C-c k" . wal/kmacro)
  :general
  (wal/lieutenant "k" '(:keymap kmacro-keymap :wk "kmacro"))
  :ensure nil)
#+END_SRC

*** register
:PROPERTIES:
:UNNUMBERED: t
:END:

No offender.

#+BEGIN_SRC emacs-lisp
(use-package register
  :config
  (transient-define-prefix wal/register ()
    "Call register commands."
    [["Store"
      ("s" "store with consult" consult-register-store
       :inapt-if-not (lambda () (featurep 'consult)))
      ("p" "point" point-to-register)
      ("w" "window config" window-configuration-to-register)
      ("n" "number" number-to-register)
      ("c" "region" copy-to-register
       :inapt-if-not (lambda () mark-active))]
     ["Load"
      ("l" "with consult" consult-register-load
       :inapt-if-not (lambda () (featurep 'consult)))
      ("i" "insert region" insert-register)
      ("j" "jump to point" jump-to-register)
      ("+" "increment number" increment-register)]
     ["Other"
      ("r" "complete" consult-register
       :inapt-if-not (lambda () (featurep 'consult)))
      ("L" "list" list-registers)]])
  :bind
  ("C-c r" . wal/register)
  :ensure nil)
#+END_SRC

** Dealing With Emacs

Allow restoring window configurations when Emacs decided they should
be gone.

*** winner
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package winner
  :config
  (defhydra wal/winner (:hint nil)
    "
%s`wal/ascii-whale Window layout: _u_ndo or _r_edo.
"
    ("u" winner-undo)
    ("r" winner-redo)
    ("q" nil "quit"))
  (winner-mode +1)
  :custom
  (winner-dont-bind-my-keys t)
  :general
  (wal/captain "w" '(wal/winner/body :wk "winner"))
  :defer 1
  :ensure nil)
#+END_SRC

*** async
:PROPERTIES:
:UNNUMBERED: t
:END:

Execute IO actions asynchronously.

#+BEGIN_SRC emacs-lisp
(use-package async
  :config
  (dired-async-mode 1)
  :demand
  :after dired
  :diminish 'dired-async-mode)
#+END_SRC

*** shell
:PROPERTIES:
:UNNUMBERED: t
:END:

I'd like to kill shells without a process quickly.

#+BEGIN_SRC emacs-lisp
(defun wal/dead-shell-p ()
  "Check if the current buffer is a shell or comint buffer with no process."
  (let ((buf (current-buffer)))
    (with-current-buffer buf
      (and (derived-mode-p 'comint-mode)
           (not (comint-check-proc buf))))))

(use-package shell
  :general
  (general-define-key
   :keymaps '(shell-mode-map comint-mode-map)
   :predicate '(wal/dead-shell-p)
   "k" 'kill-buffer-and-window)
  :ensure nil)
#+END_SRC

** Help

*** helpful
:PROPERTIES:
:UNNUMBERED: t
:END:

Let's try to be even more =helpful=.

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :config
  (wdb/direction 'helpful-mode)
  (when wal/experimental
    (defvar read-symbol-positions-list nil))
  :bind
  (([remap describe-command] . helpful-command)
   ([remap describe-function] . helpful-function)
   ([remap describe-key] . helpful-key)
   ([remap describe-variable] . helpful-variable)
   ([remap describe-symbol] . helpful-symbol)
   :map help-map
   ("M" . helpful-macro)
   :map helpful-mode-map
   ("k" . kill-buffer-and-window))
   :demand
   :after elisp-mode)
#+END_SRC

** Look-Up

*** bookmark
:PROPERTIES:
:UNNUMBERED: t
:END:

Leave a bookmark why don't you.

#+BEGIN_SRC emacs-lisp
(use-package bookmark
  :config
  (wdb/side "\\*Bookmark Annotation\\*" :side 'left)
  :custom
  (bookmark-use-annotations t)
  (bookmark-menu-confirm-deletion t)
  :bind
  (:map bookmark-map
   ("l" . bookmark-bmenu-list)
   ("L" . bookmark-load))
  :general
  (wal/lieutenant "m" '(:keymap bookmark-map :wk "bookmark"))
  :ensure nil)
#+END_SRC

*** calc
:PROPERTIES:
:UNNUMBERED: t
:END:

Quick calculations.

#+BEGIN_SRC emacs-lisp
(use-package calc
  :bind
  ("C-c q" . quick-calc)
  :ensure nil)
#+END_SRC

*** dictionary
:PROPERTIES:
:UNNUMBERED: t
:END:

Look up words in a word book.

#+BEGIN_SRC emacs-lisp
(use-package dictionary
  :config
  (wdb/direction "^\\*Dictionary")
  :custom
  (dictionary-server "dict.org")
  :general
  (wal/major "D"
    '(dictionary-lookup-definition :wk "lookup definition"))
  :ensure nil)
#+END_SRC

** Additional Info Display

*** eldoc
:PROPERTIES:
:UNNUMBERED: t
:END:

Contextual information. Package =lsp-mode= use =eldoc= extensively.

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :custom
  (eldoc-idle-delay 2.0)
  (eldoc-echo-area-use-multiline-p nil)
  (eldoc-echo-area-prefer-doc-buffer t)
  (eldoc-echo-area-display-truncation-message nil)
  :ensure nil
  :delight " eld")
#+END_SRC

*** hl-line
:PROPERTIES:
:UNNUMBERED: t
:END:

Highlighting the current line.

#+BEGIN_SRC emacs-lisp
(use-package hl-line
  :hook
  ((tablist-minor-mode
    tabulated-list-mode
    dired-mode
    dashboard-mode) . hl-line-mode)
  :ensure nil)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-emacs)

;;; wal-emacs.el ends here
#+END_SRC

* Editing
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-edit.el" wal/emacs-config-package-path)
:END:

It's fun to edit things /quickly/.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-edit.el --- Editing. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide editing packages.

;;; Code:

(declare-function yas-expand "ext:yasnippet.el")

(defvar wal/use-hyper-prefix)
#+END_SRC

** Packages

*** multiple-cursors
:PROPERTIES:
:UNNUMBERED: t
:END:

Don't you want to edit your buffer in multiple places at once?

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :init
  ;; Since the map is `nil', using `:bind' would fail.
  (setq mc/keymap (make-sparse-keymap))
  :custom
  (mc/always-run-for-all t)
  :bind
  (("C-." . mc/mark-next-like-this)
   :map mc/keymap
   ;; Keep the first two bindings from the default map.
   ("C-g" . mc/keyboard-quit)
   ("C-'" . mc-hide-unmatched-lines-mode)
   ("C-," . mc/unmark-next-like-this)
   ("C-/" . mc/skip-to-next-like-this))
  :wal-bind
  ("<mouse-3>" . mc/add-cursor-on-click)
  :general
  (wal/colonel! "." 'mc/mark-all-like-this  'mc/edit-ends-of-lines))
#+END_SRC

*** expand-region
:PROPERTIES:
:UNNUMBERED: t
:END:

One thing that can be a bit tricky is selecting regions, not anymore.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind
  (("C->" . er/expand-region)
   ("C-<" . er/contract-region)))
#+END_SRC

*** yasnippet
:PROPERTIES:
:UNNUMBERED: t
:END:

Don't reduce the boilerplate, reduce your involvement in it with
snippets.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :config
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (transient-define-prefix wal/yas ()
    "Call `yasnippet' commands."
    [["Snippets"
      ("i" "insert" yas-insert-snippet)
      ("v" "visit" yas-visit-snippet-file)
      ("n" "new" yas-new-snippet)]])
  (yas-reload-all)
  :wal-bind
  (:map yas-minor-mode-map
   ("y" . yas-expand))
  :general
  (wal/major :keymaps 'yas-minor-mode-map "y" '(wal/yas :wk "yasnippet"))
  :hook ((prog-mode org-mode) . yas-minor-mode)
  :delight " yas")

(use-package yasnippet-snippets
  :demand
  :after yasnippet)
#+END_SRC

*** drag-stuff
:PROPERTIES:
:UNNUMBERED: t
:END:

Drag lines and regions around.

#+BEGIN_SRC emacs-lisp
(use-package drag-stuff
  :config
  (when wal/use-hyper-prefix
    (setq drag-stuff-modifier 'hyper))
  (when (fboundp 'drag-stuff-define-keys)
    (drag-stuff-define-keys))
  :hook (prog-mode . drag-stuff-mode)
  :delight " drg")
#+END_SRC

*** elec-pair
:PROPERTIES:
:UNNUMBERED: t
:END:

Less intrusive pairing mode than =smartparens=.

#+BEGIN_SRC emacs-lisp
(defun wal/advise-electric-pair-default-inhibit (&rest _r)
  "Advise to inhibit if `multiple-cursors-mode' is t."
  (when (boundp 'multiple-cursors-mode)
    multiple-cursors-mode))

(use-package elec-pair
  :init
  (advice-add
   'electric-pair-default-inhibit :before-until
   #'wal/advise-electric-pair-default-inhibit)
  :hook (prog-mode . electric-pair-local-mode)
  :ensure nil)
#+END_SRC

*** crux
:PROPERTIES:
:UNNUMBERED: t
:END:

I guess I can't live without this package.

#+BEGIN_SRC emacs-lisp
(use-package crux
  :bind
  ("C-k" . crux-smart-kill-line)
  ("M-k" . crux-kill-line-backwards)
  ("C-o" . crux-smart-open-line)
  ("C-M-o" . crux-smart-open-line-above)
  :general
  (wal/colonel! "d"
    'crux-duplicate-current-line-or-region
    'crux-duplicate-and-comment-current-line-or-region))
#+END_SRC

*** vundo
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package vundo
  :wal-ways nil
  :custom
  (vundo-glyph-alist vundo-unicode-symbols)
  (vundo---window-max-height 5)
  :general
  (wal/colonel "v" '(vundo :wk "visual undo tree")))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-edit)

;;; wal-edit.el ends here
#+END_SRC

* Visuals
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-visuals.el" wal/emacs-config-package-path)
:END:

I like nice-looking things.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-visuals.el --- Visuals. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide visual packages.

;;; Code:

(declare-function dashboard-insert-startupify-lists "ext:dashboard.el")
(declare-function ligature-set-ligatures "ext:ligature.el")
(declare-function wal/append "wal-func.el")
(declare-function wal/biased-random "wal-func.el")
(declare-function wal/maybe-intern "wal-func.el")

(defvar beacon-dont-blink-commands)
(defvar beacon-dont-blink-major-modes)
(defvar dashboard-buffer-name)
(defvar dashboard-footer-messages)
(defvar dimmer-prevent-dimming-predicates)
(defvar wal/experimental)
(defvar which-key-popup-type)

(defgroup wal-visuals nil
  "Change settings used for visual packages."
  :group 'wal
  :tag "Visuals")

;;;; Customization:

(defcustom wal/dashboard-footer-messages
  '("breaching your favorite stupid framework"
    "I propel myself forward on nothing but flukes"
    "devout and up the spout"
    "krill, filter feeders and hit sulphur bottom"
    "the founder of retiring gentlemen"
    "the loud keyboard shall vanquish the muscular mouse"
    "answering all C-calls in sweeping, overflowing song"
    "infinite whale loop"
    "from echo location to perimeter expansion"
    "a mystic of profounder divings"
    "superior, clear and fine code; but there's little of it"
    "formed by intertwisting, slanting folds"
    "a register for distant jets"
    "the most majestic in affect, the most valuable in commiseration"
    "unshared, sourceless immensities")
  "The dashboard footer messages.

A collection of status messages."
  :type '(repeat string)
  :group 'wal-visuals)

(defcustom wal/recentf-exclude '("bookmarks\\'" "zettelkasten")
  "Files the dashboard should not consider recent files."
  :type '(repeat regexp)
  :group 'wal-visuals)

(defcustom wal/startup-banner
  (let ((ext (if (or (daemonp) (display-graphic-p))
                 ".png"
               ".txt")))
    (expand-file-name
     (concat "assets/logo" ext)
     wal/emacs-config-default-path))
  "The start-up banner (transformed Emacs logo)."
  :type 'file
  :group 'wal-visuals)

(defcustom wal/footer-icon
  (if (or (daemonp) (display-graphic-p))
      ":whale:"
    wal/ascii-whale)
  "The path to the footer icon."
  :type 'string
  :group 'wal-visuals)

(defcustom wal/beacon-dont-blink-commands
  '(tab-to-tab-stop
    mouse-drag-region
    mouse-set-region
    mouse-set-point)
  "List of additional commands that should not trigger a blink."
  :type '(repeat symbol)
  :group 'wal-visuals)

(defcustom wal/major-delight t
  "Whether some major modes are delighted beyond reason."
  :type 'boolean
  :group 'wal-visuals)

(defcustom wal/common-ligatures
  '(
    "==" "!=" ">=" "<="        ; Comparison.
    "+=" "-=" "/=" "%=" "*="   ; Assignment.
    "||" "&&"                  ; Logical.
    "/*" "*/" "//" "/**" "**/" ; Comments.
    "++" "--"                  ; Increment/decrement.
    ">>=" "<<=" "&=" "|=" "^=" ; Bitwise assignments.
    "<<" ">>"                  ; Bitwise shifts.
    "..."                      ; Spread.
    )
  "A list of ligatures available in all programming modes."
  :type '(repeat string)
  :group 'wal-visuals)

(defcustom wal/zone-when-idle nil
  "Determine whether to zone out when idling."
  :type 'boolean
  :group 'wal-visuals)

(defcustom wal/zone-timer (* 5 60)
  "The time in seconds when we will zone out."
  :type 'integer
  :group 'wal-visuals)
#+END_SRC

** Dashboard

*** dashboard
:PROPERTIES:
:UNNUMBERED: t
:END:

Let's have a dash of board.

#+BEGIN_SRC emacs-lisp
(defun wal/advise-dashboard-insert-startupify-lists (fun &rest r)
  "Advise FUN to ignore certain directories, applying R."
  (let ((recentf-exclude wal/recentf-exclude))
    (apply fun r)))

(defun wal/advise-dashboard-random-footer (&rest _r)
  "Advise to use biased random footer message."
  (nth (wal/biased-random (length dashboard-footer-messages)) dashboard-footer-messages))

(defun wal/advise-dashboard-setup-startup-hook ()
  "Setup the dashboard in a daemon-friendly way."
  (when (daemonp)
    (add-hook
     'server-after-make-frame-hook
     #'dashboard-insert-startupify-lists)))

(use-package dashboard
  :wal-ways nil
  :init
  (advice-add
   'dashboard-insert-startupify-lists :around
   #'wal/advise-dashboard-insert-startupify-lists)
  (advice-add
   'dashboard-random-footer :override
   #'wal/advise-dashboard-random-footer)
  (advice-add
   'dashboard-setup-startup-hook :before-until
   #'wal/advise-dashboard-setup-startup-hook)
  :config
  (setq dashboard-banner-logo-title (wal/describe-config-version))
  :custom
  (dashboard-startup-banner wal/startup-banner)
  (dashboard-projects-backend (if wal/use-projectile
                                  'projectile
                                'project-el))
  (dashboard-items '((recents . 5)
                     (projects . 3)
                     (bookmarks . 3)))
  (dashboard-center-content t)
  (dashboard-set-file-icons t)
  (dashboard-set-navigator t)
  (dashboard-footer-icon wal/footer-icon)
  (dashboard-footer-messages wal/dashboard-footer-messages)
  (dashboard-week-agenda nil)
  (dashboard-agenda-time-string-format "%d/%m/%y")
  (dashboard-agenda-release-buffers t)
  :general
  (wal/captain "d" '(dashboard-refresh-buffer :wk "dashboard"))
  :hook (after-init . dashboard-setup-startup-hook))
#+END_SRC

** Themes

*** doom-themes
:PROPERTIES:
:UNNUMBERED: t
:END:

The nicest theme packages out there. It supports many, many packages'
=face= variants.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :wal-ways nil
  :config
  (doom-themes-org-config))
#+END_SRC

*** kaolin-themes
:PROPERTIES:
:UNNUMBERED: t
:END:

Another collection of beautiful themes, but it doesn't color every
=face=.

#+BEGIN_SRC emacs-lisp
(use-package kaolin-themes
  :wal-ways nil
  :config
  (kaolin-treemacs-theme)
  :custom
  (kaolin-themes-italic-comments t)
  (kaolin-themes-git-gutter-solid t)
  (kaolin-themes-modeline-border nil)
  (kaolin-themes-distinct-fringe t))
#+END_SRC

*** modus-themes
:PROPERTIES:
:UNNUMBERED: t
:END:

Another themes collection with super configurable[fn:14] themes.

#+BEGIN_SRC emacs-lisp
(use-package modus-themes
  :custom
  (modus-themes-slanted-constructs t)
  (modus-themes-bold-constructs t)
  (modus-themes-mode-line '(borderless))
  (modus-themes-org-blocks 'tinted-background)
  :ensure nil)
#+END_SRC

*** base16-themes
:PROPERTIES:
:UNNUMBERED: t
:END:

Check out the [[https://base16-project.github.io/base16-gallery/][gallery]].

#+BEGIN_SRC emacs-lisp
(use-package base16-theme
  :wal-ways nil
  :custom
  (base16-theme-distinct-fringe-background nil))
#+END_SRC

** Highlighting

*** diff-hl
:PROPERTIES:
:UNNUMBERED:
:END:

Show diffs in the fringe (also in =dired= buffers).

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :config
  (global-diff-hl-mode)
  :hook
  ((magit-post-refresh . diff-hl-magit-post-refresh)
   (dired-mode . diff-hl-dired-mode))
  :defer 1)
#+END_SRC

*** highlight-numbers
:PROPERTIES:
:UNNUMBERED: t
:END:

Make numbers stand out.

#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers
  :wal-ways nil
  :hook (prog-mode . highlight-numbers-mode))
#+END_SRC

*** hl-todo
:PROPERTIES:
:UNNUMBERED: t
:END:

Highlight =TODO=, =FIXME= etc. in =prog= modes.

#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :wal-ways nil
  :custom
  (hl-todo-highlight-punctuation ":")
  (hl-todo-require-punctuation t)
  :hook ((prog-mode yaml-mode) . hl-todo-mode))
#+END_SRC

*** rainbow-delimiters
:PROPERTIES:
:UNNUMBERED: t
:END:

Make delimiters stand out.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :wal-ways nil
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

*** rainbow-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Show colors colorfully.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :wal-ways nil
  :delight " rbm")
#+END_SRC

** Where Am I?

*** which-key
:PROPERTIES:
:UNNUMBERED: t
:END:

Show the next possible key presses towards a command.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :wal-ways nil
  :config
  (which-key-mode +1)
  :custom
  (which-key-lighter " wk?")
  (which-key-sort-uppercase-first nil)
  (which-key-preserve-window-configuration t)
  (which-key-show-docstrings t)
  :defer 1)
#+END_SRC

*** beacon
:PROPERTIES:
:UNNUMBERED: t
:END:

Help me find my cursor!

#+BEGIN_SRC emacs-lisp
(defun wal/lighthouse ()
  "Do a heavy `beacon-blink'.

This just means increasing duration, delay, size and brightness."
  (interactive)
  (let ((beacon-blink-duration 0.8)
        (beacon-blink-delay 0.4)
        (beacon-size 60)
        (beacon-color 0.2))
    (beacon-blink)))

(use-package beacon
  :wal-ways nil
  :config
  (wal/append 'beacon-dont-blink-commands
              wal/beacon-dont-blink-commands)
  (add-to-list 'beacon-dont-blink-major-modes 'vterm-mode)
  :custom
  (beacon-blink-when-focused t)
  (beacon-blink-when-window-scrolls nil)
  :bind
  ("C-c b" . wal/lighthouse))
#+END_SRC

*** dimmer
:PROPERTIES:
:UNNUMBERED: t
:END:

Dim inactive frames.

#+BEGIN_SRC emacs-lisp
;; Solution from buzztaiki https://github.com/gonewest818/dimmer.el/issues/49
(defun wal/advise-dimmer-config-change-handler ()
  "Advise to only force process if no predicate is truthy."
  (let ((ignore (cl-some (lambda (f) (and (fboundp f) (funcall f)))
                         dimmer-prevent-dimming-predicates)))
    (unless ignore
      (when (fboundp 'dimmer-process-all)
        (dimmer-process-all t)))))

(defun wal/lsp-ui-doc-frame-p ()
  "Check if buffer is a lsp-ui-doc frame buffer."
  (string-match-p "\\` \\*lsp-ui-doc" (buffer-name)))

(defun wal/dimmer-configure-lsp-doc ()
  "Convenience settings for lsp-doc users."
  (add-to-list
   'dimmer-prevent-dimming-predicates
   #'wal/lsp-ui-doc-frame-p))

(defun wal/corfu-frame-p ()
  "Check if the buffer is a corfu frame buffer."
  (string-match-p "\\` \\*corfu" (buffer-name)))

(defun wal/dimmer-configure-corfu ()
  "Convenience settings for corfu users."
  (add-to-list
   'dimmer-prevent-dimming-predicates
   #'wal/corfu-frame-p))

(use-package dimmer
  :wal-ways nil
  :config
  (advice-add
   'dimmer-config-change-handler :override
   #'wal/advise-dimmer-config-change-handler)
  (dimmer-configure-hydra)
  (dimmer-configure-magit)
  (dimmer-configure-org)
  (dimmer-configure-which-key)
  (wal/dimmer-configure-lsp-doc)
  (wal/dimmer-configure-corfu)
  (dimmer-mode t)
  :custom
  (dimmer-fraction 0.3)
  :defer 2
  :delight " dmm")
#+END_SRC

*** goggles
:PROPERTIES:
:UNNUMBERED: t
:END:

Pulse on region edits.

#+BEGIN_SRC emacs-lisp
(use-package goggles
  :wal-ways nil
  :hook ((prog-mode text-mode) . goggles-mode)
  :delight " ggl")
#+END_SRC

** Modeline

Minor modes are white-listed, hidden, delighted and diminished.
Meaning that, if not white-listed, they are not shown, if they are
shown, they are delighted unless they were diminished.

*** wal-line
:PROPERTIES:
:UNNUMBERED: t
:END:

My own mode line.

#+BEGIN_SRC emacs-lisp
(use-package wal-line
  :wal-ways nil
  :config
  (wal-line-mode +1)
  :defer 1
  :quelpa (wal-line :fetcher github :repo "Walheimat/wal-line"))
#+END_SRC

*** delight
:PROPERTIES:
:UNNUMBERED: t
:END:

Refine a couple of major and minor mode names.

#+BEGIN_SRC emacs-lisp
(use-package delight
  :config
  (delight 'dired-mode "Dired" :major)
  (delight 'emacs-lisp-mode "Elisp" :major)
  (delight 'lisp-interaction-mode "Elisp?" :major)
  (delight 'wdired-mode "DirEd" :major)
  (delight 'c++-mode "CPP" :major)
  (delight 'compilation-shell-minor-mode " csh" "compile")
  (delight 'auto-fill-function " aff" t)
  (delight 'with-editor-mode " w/e" "with-editor")
  ;; Only confuse/delight if allowed.
  (when wal/major-delight
    (delight 'elixir-mode "Homebrew" :major)
    (delight 'c++-mode "*&" :major)
    (delight 'python-mode "Snake" :major)
    (delight 'js2-mode "NaNsense" :major)
    (delight 'inferior-python-mode "Bite" :major)))

(use-package diminish)
#+END_SRC

*** minions
:PROPERTIES:
:UNNUMBERED: t
:END:

Sometimes the list of minor modes overcrowds the modeline.

#+BEGIN_SRC emacs-lisp
(use-package minions
  :wal-ways nil
  :config
  (minions-mode +1)
  :custom
  (minions-prominent-modes '(smerge-mode
                             git-timemachine-mode
                             vterm-copy-mode
                             with-editor-mode
                             typo-mode
                             auto-fill-function
                             flyspell-mode
                             org-tree-slide-mode
                             wal/config-mode
                             verb-mode
                             verb-response-body-mode))
  :defer 3)
#+END_SRC

*** mode-line-bell
:PROPERTIES:
:UNNUMBERED: t
:END:

Make the bell visual.

#+BEGIN_SRC emacs-lisp
(use-package mode-line-bell
  :config
  (mode-line-bell-mode)
  :custom
  (mode-line-bell-flash-time 0.1)
  :defer 3)
#+END_SRC

** Ligatures

Package =ligature= is not yet on MELPA so you'll have to put it in the
load path.

*** ligature
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(defun wal/advise-ligature-set-ligatures (fun &rest args)
  "Advise FUN to append common ligatures.
ARGS is a list containing modes and additional ligatures."
  (let ((modes (nth 0 args))
        (ligatures (append (nth 1 args) wal/common-ligatures)))
    (apply fun `(,modes ,ligatures))))

(use-package ligature
  :wal-ways nil
  :config
  (advice-add
   'ligature-set-ligatures :around
   #'wal/advise-ligature-set-ligatures)
  (ligature-set-ligatures 'clojure-mode '(";;" "->" "->>"))
  (ligature-set-ligatures 'c++-mode '("::" "->"))
  (ligature-set-ligatures 'dart-mode '("=>" "///" ".?" "??"
                                       "??=" ".."))
  (ligature-set-ligatures 'elixir-mode '("|>" "->" "<-" "=>"
                                        "::" "<>" "#{" "\\\\"
                                         "===" "!==" ".."))
  (ligature-set-ligatures 'html-mode '("<!--" "-->"))
  (ligature-set-ligatures 'java-mode '("::" "->"))
  (ligature-set-ligatures 'js2-mode '("=>" "!==" "===" "!!"))
  (ligature-set-ligatures 'lisp-data-mode '(";;"))
  (ligature-set-ligatures 'php-mode '("::" "=>" "->" "??"
                                      "__" "<>" "!==" "<=>"
                                      "==="))
  (ligature-set-ligatures 'prolog-mode '(":-"))
  (ligature-set-ligatures 'python-mode '("->" "__"))
  (ligature-set-ligatures 'rust-mode '("///" "->" "=>" "::"
                                       ".." "#["))
  :hook (prog-mode . ligature-mode)
  :quelpa (ligature :fetcher github :repo "mickeynp/ligature.el"))
#+END_SRC

** Icons

*** all-the-icons
:PROPERTIES:
:UNNUMBERED: t
:END:

You need to install the icons yourself[fn:15].

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :wal-ways nil
  :commands (all-the-icons-octicon))
#+END_SRC

*** emojify
:PROPERTIES:
:UNNUMBERED: t
:END:

Display emojis[fn:16].

#+BEGIN_SRC emacs-lisp
(use-package emojify
  :wal-ways nil
  :hook (dashboard-mode . emojify-mode))
#+END_SRC

** Screen-Saver

*** zone
:PROPERTIES:
:UNNUMBERED: t
:END:

Since this eats up a lot of CPU, the timer is disabled by default but
zoning can always be triggered using =C-z=.

#+BEGIN_SRC emacs-lisp
(use-package zone
  :config
  (setq zone-programs [
                       zone-pgm-drip
                       zone-pgm-jitter
                       zone-pgm-dissolve
                       zone-pgm-rat-race
                       zone-pgm-whack-chars
                       ])
  (when (and (fboundp 'zone-when-idle) wal/zone-when-idle)
    (zone-when-idle wal/zone-timer))
  :bind
  ("C-z" . zone) ; Replaces `suspend-frame'.
  :ensure nil)
#+END_SRC

** Other

*** mixed-pitch
:PROPERTIES:
:UNNUMBERED: t
:END:

Allow using variable and fixed fonts in the same buffer.

#+BEGIN_SRC emacs-lisp
(use-package mixed-pitch
  :wal-ways nil
  :config
  (add-to-list 'mixed-pitch-fixed-pitch-faces 'markdown-pre)
  :custom
  (mixed-pitch-variable-pitch-cursor nil)
  :delight " mpm")
#+END_SRC

*** visual-fill-column
:PROPERTIES:
:UNNUMBERED: t
:END:

Allow padding and centering text.

#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :wal-ways nil)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-visuals)

;;; wal-visuals.el ends here
#+END_SRC

* Windows
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-windows.el" wal/emacs-config-package-path)
:END:

Everything that has to do with windows.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-windows.el --- Windows. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide window packages.

;;; Code:

(declare-function aw-delete-window "ext:ace-window.el")
(declare-function popper-popup-p "ext:popper.el")

(defvar aw-dispatch-alist)
(defvar popper-group-function)

(defgroup wal-windows nil
 "Change window settings."
 :group 'wal
 :tag "Windows")

;;;; Customization:

(defcustom wal/popper-reference-buffers
  '(docker-container-mode
    "\\*Bookmark Annotation\\*"
    "\\*org-roam\\*"
    ;; Compilation and REPL(-like).
    "\\*poetry-shell\\*"
    "^\\*docker-compose"
    "^\\* docker-compose \\(up\\|run\\|build\\)"
    dap-ui-repl-mode
    cider-repl-mode
    inferior-python-mode
    python-pytest-mode
    ;; Debug(-like).
    debugger-mode
    "\\*\\(.+\\)out\\*"
    "^\\* docker container"
    ;; Help(-like).
    helpful-mode
    help-mode
    dictionary-mode
    shortdoc-mode)
  "Replaces `popper-reference-buffers'."
  :type '(restricted-sexp
          :match-alternatives
          (stringp symbolp functionp consp))
  :group 'wal-windows)

(defcustom wal/popper-mode-line
  '(:eval (concat
           " "
           (all-the-icons-faicon "fort-awesome"
                                 :face 'all-the-icons-dsilver
                                 :height 0.9
                                 :v-adjust 0.0)
           " "))
  "Replaces `popper-mode-line'."
  :type 'sexp
  :group 'wal-windows)
#+END_SRC

** Packages

*** ace-window
:PROPERTIES:
:UNNUMBERED: t
:END:

Ace interacting with (multiple) windows.

#+BEGIN_SRC emacs-lisp
(defun wal/aw-delete-window-kill-buffer (window)
  "Call `aw-delete-window' on WINDOW requesting buffer kill."
  (aw-delete-window window t))

(defun wal/advise-aw--switch-buffer-consult (&rest _r)
  "Advise `aw--switch-buffer' to use `consult-buffer'."
  (call-interactively 'consult-buffer))

(use-package ace-window
  :config
  (setq aw-dispatch-alist '((?h aw-split-window-horz "horizontal split")
                            (?v aw-split-window-vert "vertical split")
                            (?f aw-split-window-fair "fair split")
                            (?d aw-delete-window "delete")
                            (?k wal/aw-delete-window-kill-buffer "kill")
                            (?o delete-other-windows "delete other")
                            (?c aw-copy-window "copy")
                            (?s aw-swap-window "swap")
                            (?b aw-switch-buffer-in-window "buffer")
                            ;; If this has a description, it doesn't work.
                            (?? aw-show-dispatch-help)))
  (advice-add
   'aw--switch-buffer :override
   #'wal/advise-aw--switch-buffer-consult)
  :custom
  (aw-dispatch-always t)
  (aw-keys '(?j ?k ?l ?\; ?u ?i ?o ?p))
  (aw-fair-aspect-ratio 3)
  :wal-bind
  ("o" . ace-window)
  :delight " ace")
#+END_SRC

*** popper
:PROPERTIES:
:UNNUMBERED: t
:END:

Treat certain buffers and their windows as pop-ups.

#+BEGIN_SRC emacs-lisp
(defun wal/popper-echo-transform (buffer-name)
  "Transform BUFFER-NAME by truncating certain prefixes."
  (let ((helpful-re "\\*helpful \\w+\:")
        (dc-re "\\* docker-compose \\(up\\|run\\|build\\)\\( --rm\\)?"))
    (cond
     ((string-match helpful-re buffer-name)
      (concat
       (substring (replace-regexp-in-string helpful-re "" buffer-name) 0 -1)
       "/help"))
     ((string-match dc-re buffer-name)
      (concat
       (substring (replace-regexp-in-string dc-re "" buffer-name) 0 -2)
       "/dc"))
     (t buffer-name))))

(use-package popper
  :wal-ways nil
  :config
  (popper-mode +1)
  (popper-echo-mode +1)
  :custom
  (popper-group-function 'popper-group-by-perspective)
  (popper-reference-buffers wal/popper-reference-buffers)
  (popper-display-control 'user)
  (popper-mode-line wal/popper-mode-line)
  (popper-echo-dispatch-persist nil)
  (popper-echo-dispatch-keys '(?a ?s ?d ?f ?g ?q ?w ?e ?r ?t))
  (popper-echo-lines 1)
  (popper-echo-transform-function #'wal/popper-echo-transform)
  :general
  (wal/captain :keymaps 'popper-mode-map "o" 'popper-toggle-latest)
  :demand
  :after winner)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-windows)

;;; wal-windows.el ends here
#+END_SRC

* Movement
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-movement.el" wal/emacs-config-package-path)
:END:

Moving around should be fun.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-movement.el --- Movement. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide movement packages.

;;; Code:

(eval-when-compile
  (require 'avy))

(declare-function avy--line "ext:avy.el")
(declare-function avy-jump "ext:avy.el")
(declare-function org-at-heading-p "ext:org.el")
(declare-function wal/univ-p "wal-func.el")

(defvar avy-goto-word-0)
(defvar avy-goto-word-0-regexp)
#+END_SRC

** Packages

*** avy
:PROPERTIES:
:UNNUMBERED: t
:END:

Who needs a mouse.

#+BEGIN_SRC emacs-lisp
(defun wal/avy-goto-word (&optional line-first)
  "Jump to currently visible word in the current line.

If called with `universal-argument', go to LINE-FIRST."
  (interactive "P")
  (when line-first
    (avy-goto-line))
  (avy-with avy-goto-word-0
    (avy-jump avy-goto-word-0-regexp
              :beg (line-beginning-position)
              :end (line-end-position))))

(defun wal/avy-mark-region ()
  "Select two lines and mark the region between them."
  (interactive)
  (avy-with wal/avy-mark-region
    (let* ((initial-window (selected-window))
           (beg (avy--line))
           (end (avy--line)))
      (when (> beg end)
        (cl-rotatef beg end))
      (set-mark beg)
      (goto-char end)
      (forward-visible-line 1)
      (point))))

(defun wal/avy-action-zip-to-char (pt)
  "Zip (just mark) from current point up to PT."
  (set-mark (point))
  (goto-char pt))

(defun wal/advise-avy-goto-end-of-line (&rest _r)
  "Advise `avy-goto-end-of-line' to go to beginning for `org' headings.

When called with `universal-argument', this also goes to the
beginning."
  (when (or (wal/univ-p)
            (and (eq major-mode 'org-mode) (org-at-heading-p)))
    (goto-char (line-beginning-position))))

(use-package avy
  :config
  (add-to-list 'avy-dispatch-alist '(?q . wal/avy-action-zip-to-char))
  (advice-add
   'avy-goto-end-of-line :after
   #'wal/advise-avy-goto-end-of-line)
  :custom
  (avy-background t)
  :bind
  (:map goto-map
    ("c" . avy-goto-char) ; Replaces `goto-char'.
    ("l" . avy-goto-end-of-line)
    ("w" . wal/avy-goto-word)
    ("a" . avy-goto-word-0))
  :general
  ;; Lines.
  (wal/colonel! "c" 'avy-copy-line 'avy-copy-region)
  (wal/colonel! "x" 'avy-kill-whole-line 'avy-kill-region)
  (wal/colonel! "m" 'avy-move-line 'avy-move-region)
  (wal/colonel! "w"
    'avy-kill-ring-save-whole-line
    'avy-kill-ring-save-region)
  (wal/colonel-sink "h" 'wal/avy-mark-region)
  :commands (avy-with))
#+END_SRC

*** mwim
:PROPERTIES:
:UNNUMBERED: t
:END:

Move where I want. Useful for comments.

#+BEGIN_SRC emacs-lisp
(use-package mwim
  :bind
  (("C-a" . mwim-beginning)
   ("C-e" . mwim-end)))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-movement)

;;; wal-movement.el ends here
#+END_SRC

* Finding Things
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-find.el" wal/emacs-config-package-path)
:END:

I mostly search.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-find.el --- Finding things. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide packages to find things.

;;; Code:

(declare-function wdb/pop-up "wal-func.el")
(declare-function wal/univ "wal-func.el")

(defvar wal/active-theme)

(defgroup wal-find nil
  "Change settings of search packages."
  :group 'wal
  :tag "Finding things")

;;;; Customization:

(defcustom wal/ctrlf-cancel-commands
  '(ace-window
    other-window)
  "Commands that are remapped to `ctrlf-cancel'.

Commands that unfocus the ctrlf minibuffer should quit it."
  :type '(repeat symbol)
  :group 'wal-find)
#+END_SRC

** Packages

*** rg
:PROPERTIES:
:UNNUMBERED: t
:END:

You can get the =ripgrep= binary from [[https://github.com/BurntSushi/ripgrep][here]].

#+BEGIN_SRC emacs-lisp
(use-package rg
  :init
  (wal/univ rg-project rg-menu)
  :config
  (wdb/pop-up "\\*rg\\*\\'")
  :wal-bind
  ("n" . wal/univ-rg-project)
  :commands (wal/univ-rg-project))
#+END_SRC

*** ctrlf
:PROPERTIES:
:UNNUMBERED: t
:END:

Replace =isearch=. Important command is =C-o s= to change search style.

#+BEGIN_SRC emacs-lisp
(use-package ctrlf
  :config
  (eval
   `(bind-keys :map ctrlf-minibuffer-mode-map
      ,@(mapcar (lambda (it) (cons `[remap ,it] 'ctrlf-cancel)) wal/ctrlf-cancel-commands)))
  (when (fboundp 'ctrlf-mode)
    (ctrlf-mode +1))
  :custom
  (ctrlf-auto-recenter t)
  (ctrlf-show-match-count-at-eol nil)
  (ctrlf-default-search-style 'fuzzy)
  (ctrlf-alternate-search-style 'regexp)
  :defer 2)
#+END_SRC

*** dumb-jump
:PROPERTIES:
:UNNUMBERED: t
:END:

Look up definitions when no LSP is already doing it. Jumping is done
using =xref-find-definitions= (=M-.=).

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :init
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
  :config
  (setq dumb-jump-selector 'completing-read)
  :custom
  (dumb-jump-force-searcher 'ag))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-find)

;;; wal-find.el ends here
#+END_SRC

* Completion
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-complete.el" wal/emacs-config-package-path)
:END:

Complete commands and code.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-complete.el --- Completion. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide Emacs completion packages.

;;; Code:

(eval-when-compile
  (require 'transient))

(declare-function wdb/ghost "wal-func.el")
(declare-function wal/append "wal-func.el")
(declare-function projectile-project-root "ext:projectile.el")

(defvar savehist-additional-variables)
(defvar xref-show-xrefs-function)
(defvar xref-show-definitions-function)
(defvar wal/active-theme)
(defvar wal/use-projectile)

(defgroup wal-complete nil
  "Change settings used for completion packages."
  :group 'wal
  :tag "Completion")

;;;; Customization:

(defcustom wal/consult-buffer-filter
  '("\\*Buffer List\\*"
    "\\*Calendar\\*"
    "\\*Call Hierarchy\\*"
    "\\*cider"
    "\\*compilation"
    "\\*dap"
    "\\*dashboard"
    "\\*docker"
    "\\* docker"
    "\\*Flutter"
    "\\*Flycheck"
    "\\*Help"
    "\\*helpful"
    "\\*HTTP"
    "\\*info\\*"
    "\\*lsp"
    "\\*Messages\\*"
    "\\*Packages\\*"
    "\\*poetry"
    "\\*rg"
    "\\*scratch"
    "\\*vterm"
    "\\*xref"
    "out\\*$"
    "^magit")
  "Additional buffers to filter."
  :type '(repeat string)
  :group 'wal-complete)
#+END_SRC

** Inline Completion

*** corfu
:PROPERTIES:
:UNNUMBERED: t
:END:

Alternative.

#+BEGIN_SRC emacs-lisp
(use-package corfu
  :custom
  (corfu-auto t)
  (corfu-cycle t)
  :hook (prog-mode . corfu-mode))
#+END_SRC

*** corfu-quick
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package corfu-quick
  :bind
  (:map corfu-map
   ("M-q" . corfu-quick-complete)
   ("C-q" . corfu-quick-insert))
  :after corfu
  :ensure nil)
#+END_SRC

*** corfu-history
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package corfu-history
  :config
  (add-to-list 'savehist-additional-variables 'corfu-history)
  (corfu-history-mode)
  :custom
  (corfu-history-length 200)
  :demand
  :after corfu
  :ensure nil)
#+END_SRC

*** corfu-doc
:PROPERTIES:
:UNNUMBERED: t
:END:

Show docs while selecting.

#+BEGIN_SRC emacs-lisp
(use-package corfu-doc
  :bind
  (:map corfu-map
   ("M-p" . corfu-doc-scroll-down)
   ("M-n" . corfu-doc-scroll-up)
   ("M-d" . corfu-doc-toggle))
  :demand
  :after corfu)
#+END_SRC

** Minibuffer Completion

*** vertico
:PROPERTIES:
:UNNUMBERED: t
:END:

Provide global option narrowing using the =vertico= family of products.

#+BEGIN_SRC emacs-lisp
(use-package vertico
  :config
  (setq enable-recursive-minibuffers t
        read-extended-command-predicate #'command-completion-default-include-p)
  (vertico-mode)
  :custom
  (vertico-cycle t)
  (vertico-sort-function #'vertico-sort-history-alpha)
  :defer 1)
#+END_SRC

*** vertico-directory
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(defvar-local wal/command nil
  "Command that started completion session.")

(defun wal/record-this-command ()
  "Record the command which opened the minibuffer."
  (setq-local wal/command this-command))

(defun wal/advise-vertico--metadata-get (fun &rest r)
  "Advise FUN using R to exit if we came from `dired-goto-file'."
  (if (and (eq (car r) 'category) (eq wal/command 'dired-goto-file))
      nil
    (apply fun r)))

(use-package vertico-directory
  :config
  (advice-add
   'vertico--metadata-get :around
   #'wal/advise-vertico--metadata-get)
  :bind
  (:map vertico-map
   ("RET" . vertico-directory-enter)
   ("DEL" . vertico-directory-delete-char)
   ("M-DEL" . vertico-directory-delete-word))
  :hook
  ((rfn-eshadow-update-overlay . vertico-directory-tidy)
   (minibuffer-setup . wal/record-this-command))
  :demand
  :after vertico
  :ensure nil)
#+END_SRC

*** vertico-quick
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package vertico-quick
  :bind
  (:map vertico-map
   ("M-q" . vertico-quick-exit)
   ("C-q" . vertico-quick-insert))
  :demand
  :after vertico
  :ensure nil)
#+END_SRC

*** orderless
:PROPERTIES:
:UNNUMBERED: t
:END:

Fuzzy matches.

#+BEGIN_SRC emacs-lisp
(use-package orderless
  :config
  (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles . (partial-completion)))))
  :demand
  :after vertico)
#+END_SRC

*** marginalia
:PROPERTIES:
:UNNUMBERED: t
:END:

Contextual information during completion, partial completion and
completion actions.

#+BEGIN_SRC emacs-lisp
(use-package marginalia
  :config
  (marginalia-mode)
  (wal/append
    'marginalia-command-categories
    '((projectile-switch-to-buffer . buffer)
      (projectile-find-file . project-file)
      (projectile-find-file-other-window . project-file)
      (projectile-find-dir . project-file)
      (projectile-find-file-in-directory . project-file)
      (projectile-recentf . project-file)
      (projectile-switch-project . project-file)
      (persp-switch-to-buffer . buffer)
      (persp-kill-buffer* . buffer)))
  :bind
  (:map minibuffer-local-map
   ("M-a" . marginalia-cycle))
  :demand
  :after vertico)
#+END_SRC

*** embark
:PROPERTIES:
:UNNUMBERED: t
:END:

Do something else with minibuffer candidate.

#+BEGIN_SRC emacs-lisp
(use-package embark
  :init
  (wal/univ embark-act embark-dwim)
  :config
  (wdb/ghost "\\`\\*Embark Collect \\(Live\\|Completions\\)\\*")
  (when wal/use-projectile
    (define-key embark-file-map
                (kbd "f")
                (wal/maybe-use-projectile find-file))
    (define-key embark-file-map
                (kbd "o")
                (wal/maybe-use-projectile find-file-other-window)))
  (define-key embark-region-map
              (kbd "g")
              #'wal/duck-duck-go-region)
  :custom
  (embark-mixed-indicator-delay 2.0)
  (embark-cycle-key (kbd "C-,"))
  :wal-bind
  ("k" . wal/univ-embark-act)
  :after vertico
  :commands (wal/univ-embark-act))

(use-package embark-consult
  :hook (embark-collect-mode . consult-preview-at-point-mode)
  :demand
  :after (embark consult))
#+END_SRC

*** consult
:PROPERTIES:
:UNNUMBERED: t
:END:

Heavy lifting with =consult=.

#+BEGIN_SRC emacs-lisp
(defun wal/consult-ripgrep-ignored (&optional dir initial)
  "Search for regexp with rg in DIR with INITIAL input.
Do not ignore hidden files."
  (interactive "P")
  (let ((consult-ripgrep-args
         (concat (substring consult-ripgrep-args 0 -1) "--no-ignore .")))
    (when (and (fboundp 'consult--grep)
               (fboundp 'consult--ripgrep-builder))
      (consult--grep "Ripgrep (ignored)" #'consult--ripgrep-builder dir initial))))


(defun wal/advise-consult-theme (theme)
  "Advise to set `wal/active-theme' to THEME."
  (setq wal/active-theme theme))

(use-package consult
  :init
  (wal/univ consult-buffer wal/consult)
  :config
  ;; Integrate into `projectile' and `xref'.
  (when wal/use-projectile
    (setq consult-project-function #'projectile-project-root))
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)
  ;; Customize filter, previews and advise theme changes.
  (wal/append 'consult-buffer-filter
              wal/consult-buffer-filter)
  (consult-customize
   consult--source-recent-file
   consult--source-project-recent-file
   consult--source-bookmark
   :preview-key (kbd "M-,"))
  (advice-add 'consult-theme :after #'wal/advise-consult-theme)
  ;; Bind commands in `transient'.
  (transient-define-prefix wal/consult ()
    "Call `consult' functions."
    [["Find"
      ("b" "bookmark" consult-bookmark)
      ("f" "recent" consult-recent-file)
      ("x" "externally" consult-file-externally)
      ("a" "apropos" consult-apropos)]
     ["Locate"
      ("g" "ripgrep" consult-ripgrep)
      ("G" "ripgrep everything" wal/consult-ripgrep-ignored)
      ("l" "locate" consult-locate
       :inapt-if-not (lambda () (executable-find "locate")))]
     ["Do"
      ("y" "yank" consult-yank-from-kill-ring)
      ("u" "focus" consult-focus-lines)
      ("k" "keep" consult-keep-lines)]
     ["Narrow"
      ("e" "errors (flycheck)" consult-flycheck
       :inapt-if-not (lambda () flycheck-mode))]])
  :bind
  (("C-c s" . consult-line)
   :map goto-map
   ("g" . consult-goto-line)
   ("h" . consult-org-heading)
   ("m" . consult-mark)
   ("M" . consult-global-mark))
  :wal-bind
  ("j" . wal/univ-consult-buffer)
  :general
  (wal/general
    "st" '(consult-theme :wk "consult theme")
    "fr" '(consult-recent-file :wk "recent"))
  (wal/major
    "+" 'consult-mode-command
    "-" 'consult-minor-mode-menu)
  :commands
  (wal/univ-consult-buffer
   wal/consult))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-complete)

;;; wal-complete.el ends here
#+END_SRC

* Workspace
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-workspace.el" wal/emacs-config-package-path)
:END:

Keep order.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-workspace.el --- Workspace. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide workspace packages.

;;; Code:

(declare-function consult-customize "ext:consult.el")
(declare-function consult--buffer-state "ext:consult.el")
(declare-function consult--regexp-filter "ext:consult.el")
(declare-function persp-current-buffers "ext:perspective.el")
(declare-function persp-current-buffer-names "ext:perspective.el")
(declare-function persp-current-name "ext:perspective.el")
(declare-function persp-names "ext:perspective.el")
(declare-function persp-mode-line "ext:perspective.el")
(declare-function persp-scratch-buffer "ext:perspective.el")
(declare-function persp-switch "ext:perspective.el")
(declare-function persp-switch-to-buffer "ext:perspective.el")
(declare-function projectile-project-p "ext:projectile.el")
(declare-function projectile-read-command "ext:projectile.el")
(declare-function wal/append "wal-func.el")
(declare-function wal/captain "wal-key-bindings.el")
(declare-function wal/univ-p "wal-func.el")

(defvar consult-buffer-filter)
(defvar consult-buffer-sources)
(defvar consult--source-buffer)
(defvar persp-modestring-short)
(defvar projectile-globally-ignored-directories)
(defvar projectile-globally-ignored-files)
(defvar projectile-globally-ignored-file-suffixes)

(defgroup wal-workspace nil
  "Change settings used for workspace packages."
  :group 'wal
  :tag "Workspace")

;;;; Customization:

(defcustom wal/use-projectile t
  "Whether to use `projectile' over `project'."
  :type 'boolean
  :group 'wal-workspace)

(defcustom wal/default-perspective "walheimat"
  "The name of my default perspective."
  :type 'string
  :group 'wal-workspace)

(defcustom wal/perspective-truncate-after 20
  "Name truncation threshold.

If the combined length of names pass it, names of inactive
perspectives are truncated."
  :type 'integer
  :group 'wal-workspace)

(defcustom wal/perspective-shorten-after 20
  "Shorten threshold.

If the mode-line string passes it, only the active perspective is
shown."
  :type 'integer
  :group 'wal-workspace)

(defcustom wal/perspective-truncated-length 3
  "The length of a perspective name when truncated."
  :type 'integer
  :group 'wal-workspace)

(defcustom wal/projectile-ignored
  '(("node_modules" "build" "_build" "android")
    ("yarn.lock" "package.lock" "bundle.js")
    (".min.js" ".js.map"))
  "Additional directories, files and file suffixes to ignore."
  :type '(list)
  :group 'wal-workspace)

(defcustom wal/project-vc-ignores
  '("node_modules/"
    "build/"
    "android/"
    "*.lock"
    "bundle.js"
    "*.min.js"
    "*.js.map")
  "Additional directories to ignore."
  :type '(repeat string)
  :group 'wal-workspace)
#+END_SRC

** Packages

*** perspective
:PROPERTIES:
:UNNUMBERED: t
:END:

Group buffers in workspaces.

#+BEGIN_SRC emacs-lisp
;; Utility for hooks.

(defun wal/persp-maybe-shorten ()
  "Maybe shorten mode-line string when many perspectives are open."
  (let ((truncated-length (length (string-join (persp-mode-line)))))
    (setq persp-modestring-short
        (> truncated-length wal/perspective-shorten-after))))

;; Additional functions.

(defun wal/switch-to-scratch-buffer ()
  "Switch to a perspective's scratch buffer."
  (interactive)
  (switch-to-buffer (get-buffer-create (persp-scratch-buffer))))

;; Advice.

(defun wal/advise-persp-kill (fun &rest r)
  "Advises FUN to kill processes without querying, applying R.

This only removes `process-kill-buffer-query-function'."
  (let ((kill-buffer-query-functions (delq 'process-kill-buffer-query-function
                                           kill-buffer-query-functions)))
    (apply fun r)))

(defun wal/advise-persp-format-name (&rest args)
  "Truncate non-active perspective name (in ARGS)."
  (let* ((name (car args))
         (curr-name (persp-current-name))
         (names (persp-names))
         (names-len (length names))
         (divider-len (if (> 1 names-len)
                          (+ 1 names-len)
                        2))
         (combined-length (+ divider-len
                             (seq-reduce
                              (lambda (acc item)
                                (+ acc (length item)))
                              names
                              0))))
    (if (and (> combined-length wal/perspective-truncate-after)
             (not (string-match-p name curr-name)))
        (substring name 0 (min (length name) wal/perspective-truncated-length))
      name)))

(defun wal/advise-persp-mode-line-click (event)
  "Guess perspective from click EVENT and switch."
  (let ((clicked (format "%s" (car (posn-string (event-start event))))))
    (if (eq (length clicked) wal/perspective-truncated-length)
        (when-let* ((r (concat "^" clicked))
                    (names (persp-names))
                    (p (cl-find-if (lambda (it) (string-match r it)) names)))
          (persp-switch p))
      (persp-switch clicked))))

(defun wal/advise-persp-list-buffers-refresh (fun &rest _r)
  "Advise FUN `list-buffers--refresh' to only consider perspective buffers.

No filter is applied if called with `universal-argument'."
  (if (wal/univ-p)
      (apply fun nil)
    (apply fun (list (seq-filter 'buffer-live-p (persp-current-buffers))))))

;; Integration with `consult'.

(defun wal/consult-filtered-persp-buffers ()
  "Get current perspective's filtered buffers.

The results are filtered using `consult-buffer-filter'"
  (let ((filters (consult--regexp-filter consult-buffer-filter)))
    (seq-filter
     (lambda (it) (and (buffer-live-p it)
                       (not (string-match-p filters (buffer-name it)))))
     (persp-current-buffers))))

(defun wal/consult-persp-buffer-names ()
  "Get current perspective's buffer names.

The current buffer and Dired buffers are filtered."
  (let* ((persp-buffers (wal/consult-filtered-persp-buffers))
         (current (current-buffer))
         (desired (seq-filter
                   (lambda (it) (and (not (eq it current))
                                (with-current-buffer it
                                  (not (derived-mode-p 'dired-mode)))))
                   persp-buffers)))
    (mapcar #'buffer-name desired)))

(defun wal/consult-persp-dired-buffer-names ()
  "Get current persepective's Dired buffer names."
  (let* ((persp-buffers (wal/consult-filtered-persp-buffers))
         (desired (seq-filter
                   (lambda (it)
                     (with-current-buffer it
                       (derived-mode-p 'dired-mode)))
                   persp-buffers)))
    (mapcar #'buffer-name desired)))

(use-package perspective
  :config
  (advice-add 'persp-kill :around #'wal/advise-persp-kill)
  (advice-add 'persp-format-name :filter-return #'wal/advise-persp-format-name)
  (advice-add 'persp-mode-line-click :override #'wal/advise-persp-mode-line-click)
  (advice-add 'list-buffers--refresh :around #'wal/advise-persp-list-buffers-refresh)
  (with-eval-after-load 'consult
    (consult-customize
     consult--source-buffer
     :name "Perspective Buffer"
     :action #'persp-switch-to-buffer
     :items #'wal/consult-persp-buffer-names)
    (add-to-list 'consult-buffer-sources
                 (list :name "Dired"
                       :narrow ?d
                       :category 'buffer
                       :face 'font-lock-keyword-face
                       :state #'consult--buffer-state
                       :items #'wal/consult-persp-dired-buffer-names)
                 t))
  (transient-define-prefix wal/persp ()
    "Call `perspective' functions."
    [["Buffers"
      ("a" "add" persp-add-buffer)
      ("s" "set" persp-set-buffer)
      ("r" "remove" persp-remove-buffer)
      ("f" "forget" persp-forget-buffer)
      ("l" "list" persp-buffer-menu)]
     ["Perspectives"
      ("n" "rename" persp-rename)
      ("k" "kill" persp-kill)
      ("m" "merge" persp-merge)]
     ["Other"
      ("x" "scratch" wal/switch-to-scratch-buffer)]])
  (wal/lieutenant "i" '(:keymap perspective-map :wk "perspective"))
  (persp-mode +1)
  ;; Override the override to `perspective-map'.
  (when (< emacs-major-version 28)
    (define-key persp-mode-map (kbd "C-x x") ctl-x-x-map))
  :custom
  (persp-modestring-dividers '("(" ")" "/"))
  (persp-initial-frame-name wal/default-perspective)
  (persp-state-default-file (expand-file-name "persp-persist" wal/cache-directory))
  (persp-suppress-no-prefix-key-warning t)
  :bind
  (:map persp-mode-map
   ("C-x b" . persp-switch-to-buffer)
   ("C-x C-b" . persp-buffer-menu))
  :wal-bind
  (:map persp-mode-map
   ("i" . persp-switch))
  :general
  (wal/captain "i" '(wal/persp :wk "perspective"))
  :hook
  ((kill-emacs . persp-state-save)
   ((persp-created
     persp-killed
     persp-after-rename) . wal/persp-maybe-shorten))
  :commands (wal/persp)
  :defer 1)
#+END_SRC

*** projectile
:PROPERTIES:
:UNNUMBERED: t
:END:

More robust project management.

#+BEGIN_SRC emacs-lisp
(defmacro wal/maybe-use-projectile (func)
  "Maybe use the `projectile' variant for FUNC."
  (let* ((func-name (symbol-name func))
         (projectile-func-name (concat "projectile-" func-name)))
  `(defun ,(intern (concat "wal/maybe-use-projectile-" func-name)) ()
     ,(format "Use `%s' instead of `%s' if in a project." projectile-func-name func-name)
     (interactive)
     (with-demoted-errors "%s"
       (require 'projectile)
       (if (projectile-project-p)
           (call-interactively (symbol-function ',(intern projectile-func-name)))
         (call-interactively (symbol-function ',func)))))))

(defun wal/advise-projectile-find-file (func &rest r)
  "Call FUNC with R or switch project."
  (if (projectile-project-p)
      (apply func r)
    (call-interactively 'projectile-switch-project)))

(defun wal/advise-projectile-maybe-read-command (arg default-cmd prompt)
  "Advise function to only PROMPT if ARG is provided.
Otherwise treat DEFAULT-CMD normally."
  (if (and (stringp default-cmd) (not arg))
      default-cmd
    (projectile-read-command prompt default-cmd)))

(use-package projectile
  :if wal/use-projectile
  :init
  (advice-add
    'projectile-find-file :around
    #'wal/advise-projectile-find-file)
  (advice-add
    'projectile-maybe-read-command :override
    #'wal/advise-projectile-maybe-read-command)
  :config
  (wal/append 'projectile-globally-ignored-directories
              (nth 0 wal/projectile-ignored))
  (wal/append 'projectile-globally-ignored-files
              (nth 1 wal/projectile-ignored))
  (wal/append 'projectile-globally-ignored-file-suffixes
              (nth 2 wal/projectile-ignored))
  (transient-define-prefix wal/projectile ()
    "Call `projectile' commands."
    [["Command"
      ("c" "compile" projectile-compile-project)
      ("i" "install" projectile-install-project)
      ("x" "configure" projectile-configure-project)
      ("p" "package" projectile-package-project)
      ("u" "run" projectile-run-project)
      ("t" "test"  projectile-test-project)]
     ["Buffers"
      ("k" "kill" projectile-kill-buffers)
      ("s" "switch" projectile-switch-to-buffer)]
     ["Find"
      ("a" "other file" projectile-find-other-file)
      ("d" "directory" projectile-find-dir)
      ("f" "file in directory" projectile-find-file-in-directory)
      ("r" "recent file" projectile-recentf)]
     ["Other"
      ;; The `projectile' variant seems buggy.
      ("l" "add dir local" add-dir-local-variable)
      ("?" "tokei" tokei
       :inapt-if-not (lambda () (featurep 'tokei)))]
     ["Projects"
      ("o" "switch to open project" projectile-switch-open-project)]])
  (wal/lieutenant "p" '(:keymap projectile-command-map :wk "projectile"))
  (projectile-mode +1)
  :custom
  (projectile-switch-project-action #'projectile-dired)
  (projectile-sort-order 'recentf)
  ;; Allow finding files that are ignored by `.gitignore'.
  (projectile-indexing-method 'hybrid)
  (projectile-enable-caching t)
  ;; TEMP: Currently passing missing switch "--strip-cwd-prefix".
  (projectile-generic-command "fd . -0 --type f --color=never")
  :wal-bind
  (("l" . projectile-find-file)
   ("p" . projectile-switch-project))
  :general
  (wal/captain "p" '(wal/projectile :wk "projectile"))
  :commands
  (wal/projectile
   projectile-project-root)
  :delight " pjt")
#+END_SRC

*** project
:PROPERTIES:
:UNNUMBERED: t
:END:

Built-in but entirely dependent on either =git= or =hg=.

#+BEGIN_SRC emacs-lisp
(use-package project
  :if (not wal/use-projectile)
  :custom
  (project-switch-commands 'project-find-dir)
  (project-vc-ignores wal/project-vc-ignores)
  :wal-bind
  (("l" . project-find-file)
   ("p" . project-switch-project))
  :general
  (wal/lieutenant "p" '(:keymap project-prefix-map :wk "project"))
  :ensure nil
  :demand)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-workspace)

;;; wal-workspace.el ends here
#+END_SRC

* Org Mode
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-org.el" wal/emacs-config-package-path)
:END:

The best thing about Emacs. Check out the [[https://orgmode.org/manual/][manual]].

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-org.el --- Org. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide org packages/configurations.

;;; Code:

(eval-when-compile
  (require 'transient))
  (require 'wal-func (expand-file-name "wal-func.el" "."))

(declare-function org-alert--to-minute "ext:org-alert.el")
(declare-function projectile-project-root "ext:projectile.el")
(declare-function project-root "ext:project.el")
(declare-function transient-define-prefix "ext:transient.el")
(declare-function wal/append "wal-func.el")
(declare-function wal/disable-tabs "wal-settings.el")
(declare-function wal/message-in-a-bottle "wal-func.el")
(declare-function wal/replace-in-alist "wal-fun.el")
(declare-function wal/truncate "wal-func.el")
(declare-function wal/univ-p "wal-func.el")

(defvar org-alert-notify-cutoff)
(defvar org-global-properties)
(defvar org-mode-map)
(defvar text-scale-mode-step)
(defvar visual-fill-column-width)
(defvar visual-fill-column-center-text)
(defvar wal/use-projectile)

(defgroup wal-org nil
  "Change settings used for org packages."
  :group 'wal
  :tag "Org")

;;;; Customization:

(defcustom wal/org-super-agenda-groups
  '((:name "Schedule"
     :time-grid t)
    (:name "Unscheduled"
     :and (:scheduled nil
           :not (:tag "@intermittent" :todo "BLOCKED")))
    (:name "Leftovers"
     :and (:todo ("IN PROGRESS" "WAITING")
           :scheduled past
           :not (:tag "@repeated" :tag "@edu")))
    (:name "Blocked"
     :todo "BLOCKED")
    (:discard (:anything t)))
  "The super agenda groups."
  :type '(repeat plist)
  :group 'wal-org)

(defcustom wal/org-roam-dailies-directory "tagebuch/"
  "The directory for dailies."
  :type 'string
  :group 'wal-org)

(defcustom wal/org-tree-slide-visual-fill-column-width 160
  "The base `visual-fill-column-width' for `org-tree-slide' presentations."
  :type 'integer
  :group 'wal-org)

(defcustom wal/org-src-lang-modes
  '(("dockerfile" . dockerfile)
    ("conf" . conf)
    ("markdown" . markdown)
    ("fish" . fish))
  "Additional mappings to add to `org-src-lang-modes'."
  :type '(repeat
	      (cons
	       (string "Language name")
	       (symbol "Major mode")))
  :group 'wal-org)

(defcustom wal/org-speed-commands '(("a" . org-archive-subtree)
                                    ("j" . consult-org-heading))
  "Changes to `org-speed-commands'."
  :type '(repeat
          (cons "Key")
          (symbol "Command"))
  :group 'wal-org)
#+END_SRC

** The Mode Itself

*** org
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(defun wal/advise-org-export-dispatch (&rest _r)
  "Advise to require `ox-md' before export dispatch."
  (unless (featurep 'ox-md)
    (require 'ox-md nil t)))

(defun wal/org-content (level)
  "Show up to given LEVEL.
This calls `org-content' interactively."
  (interactive "nShow content up to level: ")
  (when (fboundp 'org-content)
    (org-content level)))

(use-package org
  :init
  (wal/lang-hook org-mode
    "Hook into `org-mode'."
    :messages '("Organize! Seize the means of production!"))
  :config
  (require 'org-indent) ; TEMP: Getting missing face errors otherwise.
  (define-key org-mode-map (kbd "C-,") nil) ; Remove `org-cycle-agenda-files'.
  (advice-add
   'org-export-dispatch :before
   #'wal/advise-org-export-dispatch)
  (transient-define-prefix wal/org ()
    "Access `org-mode' commands."
    [["Commands"
      ("n" "add note" org-add-note)
      ("e" "edit source" org-edit-src-code
       :inapt-if-not (lambda () (org-in-src-block-p)))]
     ["Subtrees"
      ("s w" "cut" org-cut-subtree
       :inapt-if-not (lambda () (org-at-heading-p)))
      ("s y" "paste" org-paste-subtree)]
     ["Visibility"
      ("v a" "show all" org-show-all)
      ("v l" "up to level" wal/org-content)
      ("v h" "sticky header" org-sticky-header-mode)]
     ["Presentation"
      ("p" "present" org-tree-slide-mode)]
     ["Footnotes"
      ("f a" "add" org-footnote-new
       :inapt-if (lambda () (org-in-src-block-p)))
      ("f n" "normalize" org-footnote-normalize)]
     ["Transclusion"
      ("t" "transclusion" wal/org-transclusion)]])
  :custom
  (org-adapt-indentation nil)
  (org-ellipsis "↷")
  (org-hide-emphasis-markers t)
  (org-log-done 'time)
  (org-log-note-clock-out t)
  (org-startup-folded 'overview)
  (org-directory wal/org-directory)
  (org-default-notes-file (concat org-directory "/notes.org"))
  (org-agenda-files `(,wal/agenda-tasks-directory ,wal/org-roam-directory))
  (org-deadline-warning-days 2)
  (org-startup-with-inline-images t)
  ;; Be sure to add archive tag with `org-toggle-archive-tag'.
  (org-archive-location "::* Archived")
  ;; Too many clock entries clutter up a heading.
  (org-log-into-drawer t)
  (org-todo-keywords
   '((sequence "TODO(t)" "IN PROGRESS(p)" "WAITING(w)" "BLOCKED(b)" "|" "DONE(d)" "CANCELED(c)")))
  (org-tag-alist
   '(;; Depth.
     ("@immersive" . ?i)
     ("@process" . ?p)
     ;; Context.
     ("@work" . ?w)
     ("@home" . ?h)
     ("@away" . ?a)
     ("@repeated" . ?r)
     ("@unbillable" . ?u)
     ("@intermittent" . ?m)
     ;; Energy.
     ("@easy" . ?1)
     ("@average" . ?2)
     ("@challenge" . ?3)
     ;; Category.
     ("@dev" . ?d)
     ("@bla" . ?b)
     ("@edu" . ?e)))
  :bind
  (:map org-mode-map
   ("M-p" . org-previous-visible-heading)
   ("M-n" . org-next-visible-heading))
  :general
  (wal/major! wal/org :keymaps 'org-mode-map)
  :hook (org-mode . auto-fill-mode)
  :ensure nil)
#+END_SRC

** Agendas

*** org-agenda
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(defun wal/advise-org-agenda (&rest _r)
  "Advise `org-agenda' to just display current day."
  (list (wal/univ-p) "a"))

(use-package org-agenda
  :config
  (advice-add 'org-agenda :filter-args #'wal/advise-org-agenda)
  :custom
  (org-agenda-hide-tags-regexp "^@")
  (org-agenda-span 'day)
  (org-agenda-restore-windows-after-quit t)
  (org-agenda-time-leading-zero t)
  (org-agenda-log-mode-items '(clock))
  (org-agenda-clockreport-parameter-plist
   '(:link t
     :maxlevel 3
     :fileskip0 t
     :emphasize t
     :match "-@unbillable"))
  :bind
  ("C-c a" . org-agenda)
  :ensure nil)
#+END_SRC

*** org-super-agenda
:PROPERTIES:
:UNNUMBERED: t
:END:

Allow for better grouping.

#+BEGIN_SRC emacs-lisp
(use-package org-super-agenda
  :wal-ways nil
  :config
  (org-super-agenda-mode)
  :custom
  (org-super-agenda-groups wal/org-super-agenda-groups)
  :demand
  :after org-agenda)
#+END_SRC

** Zettelkasten

Trying to organize my thoughts using Zettelkästen.

/Note/ that you will need to install =sqlite3= manually.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack org-roam
  "Note rhizome."
  :packages (org-roam)
  :extras (org-roam-ui))
#+END_SRC

*** org-roam
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(defun wal/advise-org-roam-dailies-goto-date (&rest _r)
  "Advise to preselect default template."
  (list nil "d"))

(use-package org-roam
  :if (executable-find "sqlite3")
  :wal-ways nil
  :init
  (setq org-roam-v2-ack t)
  :config
  (org-roam-db-autosync-enable)
  (wdb/side 'org-roam-mode :side 'right)
  (advice-add 'org-roam-dailies-goto-date :filter-args
    #'wal/advise-org-roam-dailies-goto-date)
  (transient-define-prefix wal/org-roam ()
    "Run `org-roam' commands."
    [["Capture"
      ("c" "capture" org-roam-capture)
      ("t" "today" org-roam-dailies-capture-today)
      ("d" "default" org-capture)]
     ["Find"
      ("f" "find" org-roam-node-find)
      ("d" "find daily" org-roam-dailies-goto-date)]
     ["Actions"
      ("b" "buffer" org-roam-buffer-toggle)
      ("w" "refile" org-roam-refile
       :inapt-if-not (lambda () (eq major-mode 'org-mode)))
      ("i" "insert" org-roam-node-insert
       :inapt-if-not (lambda () (eq major-mode 'org-mode)))
      ("@" "tag" org-roam-tag-add
       :inapt-if-not (lambda () (eq major-mode 'org-mode)))]
     ["Visualization"
      ("g" "graph" org-roam-graph)
      ("u" "ui" org-roam-ui-mode
       :inapt-if-not (lambda () (featurep 'org-roam-ui)))]])
  :custom
  (org-roam-directory wal/org-roam-directory)
  (org-roam-dailies-directory wal/org-roam-dailies-directory)
  (org-roam-extract-new-file-path "${slug}.org")
  (org-roam-capture-templates
   '(("d" "default" plain "%?"
      :target (file+head "${slug}.org"
                         "#+title: ${title}\n")
      :unnarrowed t)))
  (org-roam-dailies-capture-templates
    '(("d" "default" entry
       "* %?\n%U"
       :target (file+head "%<%Y-%m-%d>.org"
                          "#+title: %<%Y-%m-%d>\n")
       :unnarrowed t
       :empty-lines 1)
      ("a" "active" entry
       "* TODO %?\n%t"
       :target (file+head "%<%Y-%m-%d>.org"
                          "#+title: %<%Y-%m-%d>\n")
       :unnarrowed t
       :empty-lines 1)))
  :general
  (wal/captain "c" 'wal/org-roam)
  :commands
  (wal/org-roam
   org-roam-buffer-display-dedicated
   org-roam-capture
   org-roam-node-create
   org-roam-node-find
   org-roam-node-read)
  :ensure nil)
#+END_SRC

*** org-roam-ui
:PROPERTIES:
:UNNUMBERED: t
:END:

Fancy UI.

#+BEGIN_SRC emacs-lisp
(use-package org-roam-ui
  :wal-ways nil
  :demand
  :after org-roam
  :ensure nil)
#+END_SRC

** Presentations

*** org-tree-slide
:PROPERTIES:
:UNNUMBERED: t
:END:

Turn any =org-mode= buffer into a presentation.

#+BEGIN_SRC emacs-lisp
(defun wal/relative-column-width (&optional target-width)
  "Get the relative column width of TARGET-WIDTH."
  (let ((width (or target-width 160))
        (scale (if (and (boundp 'text-scale-mode-amount)
                        (numberp text-scale-mode-amount))
                   (expt text-scale-mode-step text-scale-mode-amount)
                 1)))
    (ceiling (/ width scale))))

(defun wal/org-tree-slide-toggle-visibility ()
  "Toggle visibility of cursor."
  (interactive)
  (if cursor-type
      (setq cursor-type nil)
    (setq cursor-type t)))

(defvar wal/org-tree-slide-disabled-modes '())

(defun wal/org-tree-slide-play ()
  "Hook into `org-tree-slide-play'."
  (setq visual-fill-column-width (wal/relative-column-width
                                  wal/org-tree-slide-visual-fill-column-width)
        visual-fill-column-center-text t
        cursor-type nil)
  (visual-fill-column-mode 1)
  (when (bound-and-true-p org-sticky-header-mode)
    (setq wal/org-tree-slide-disabled-modes
      (append wal/org-tree-slide-disabled-modes '(org-sticky-header-mode)))
    (org-sticky-header-mode -1))
  (when (bound-and-true-p dimmer-mode)
    (setq wal/org-tree-slide-disabled-modes
      (append wal/org-tree-slide-disabled-modes '(dimmer-mode)))
    (dimmer-mode -1))
  (mixed-pitch-mode +1))

(defun wal/org-tree-slide-stop ()
  "Hook into `org-tree-slide-stop'."
  (setq visual-fill-column-width nil
        visual-fill-column-center-text nil
        cursor-type t)
  (visual-fill-column-mode -1)
  (when (fboundp 'outline-show-all)
    (outline-show-all))
  (when (memq 'org-sticky-header-mode wal/org-tree-slide-disabled-modes)
    (org-sticky-header-mode +1))
  (when (memq 'dimmer-mode wal/org-tree-slide-disabled-modes)
    (dimmer-mode +1))
  (setq wal/org-tree-slide-disabled-modes '())
  (mixed-pitch-mode -1))

(defun wal/org-tree-slide-text-scale ()
  "Hook into `text-scale-mode-hook' for `org-tree-slide'."
  (when (and (boundp 'org-tree-slide-mode) org-tree-slide-mode)
    (wal/org-tree-slide-play)))

(use-package org-tree-slide
  :wal-ways nil
  :custom
  (org-tree-slide-never-touch-face t)
  (org-tree-slide-cursor-init nil)
  (org-tree-slide-activate-message "We're on a road to nowhere")
  (org-tree-slide-deactivate-message "Take you here, take you there")
  (org-tree-slide-indicator '(:next "   >>>" :previous "<<<" :content "< Here is where time is on our side >"))
  :bind
  (:map org-tree-slide-mode-map
   ("q" . org-tree-slide-mode) ; To close it again.
   ("n" . org-tree-slide-move-next-tree)
   ("p" . org-tree-slide-move-previous-tree)
   ("i" . text-scale-increase)
   ("d" . text-scale-decrease)
   ("v" . wal/org-tree-slide-toggle-visibility))
  :hook
  ((org-tree-slide-play . wal/org-tree-slide-play)
   (org-tree-slide-stop . wal/org-tree-slide-stop)
   (text-scale-mode . wal/org-tree-slide-text-scale))
  :diminish buffer-face-mode)
#+END_SRC

** Editing

*** org-src
:PROPERTIES:
:UNNUMBERED: t
:END:

Editing source blocks.

#+BEGIN_SRC emacs-lisp
(defun wal/org-src-mode ()
  "Hook into function `org-src-mode'."
  (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

(use-package org-src
  :config
  (wal/append 'org-src-lang-modes wal/org-src-lang-modes)
  :custom
  (org-src-tab-acts-natively nil)
  (org-edit-src-content-indentation 0)
  :bind
  (:map org-src-mode-map
   ("C-c C-c" . org-edit-src-exit))
  :hook (org-src-mode . wal/org-src-mode)
  :after org
  :ensure nil
  :delight " osc")
#+END_SRC

*** org-capture
:PROPERTIES:
:UNNUMBERED: t
:END:

Capture templates.

#+BEGIN_SRC emacs-lisp
(defun wal/org-capture-find-project-tasks ()
  "Find a project's tasks file.

If the project root cannot be determined, use
`wal/org-directory'. as destination."
  (let ((proj-root (if wal/use-projectile
                       (projectile-project-root)
                     (project-root (project-current)))))
    (expand-file-name "tasks.org" (or proj-root org-directory))))

(use-package org-capture
  :custom
  (org-capture-templates
   `(("c" "current task" plain
      (clock)
      "\n%?\n"
      :empty-lines-before 1)
     ("d" "daily" plain
      (file+olp+datetree ,(concat org-directory "/dailies.org"))
      "%i\n%?")
     ("p" "project task" entry
      (file+headline wal/org-capture-find-project-tasks "Tasks")
      "* TODO %?\n\n%F\n\n%i"
      :empty-lines-before 1)))
  (org-capture-bookmark nil) ; Prevents countless edit buffers since we annotate bookmarks.
  :ensure nil
  :delight " cap")
#+END_SRC

*** org-transclusion
:PROPERTIES:
:UNNUMBERED: t
:END:

Spectral inclusion.

#+BEGIN_SRC emacs-lisp
(use-package org-transclusion
  :config
  ;; Not using `org-transclusion-map' as it includes `org-mode-map'.
  (transient-define-prefix wal/org-transclusion ()
    "Access `org-transclusion' commands."
    [["Transclusion commands"
      ("a" "add" org-transclusion-add)
      ("A" "add all" org-transclusion-add-all)
      ("x" "remove" org-transclusion-remove)
      ("X" "remove all" org-transclusion-remove-all all)
      ("l" "from link" org-transclusion-make-from-link)
      ("r" "refresh" org-transclusion-refresh)
      ("s" "sync start" org-transclusion-live-sync-start)
      ("S" "sync exit" org-transclusion-live-sync-exit)]])
  :custom
  (org-transclusion-mode-lighter " tra")
  :commands wal/org-transclusion)
#+END_SRC

*** org-refile
:PROPERTIES:
:UNNUMBERED: t
:END:

Configure refiling headings.

#+BEGIN_SRC emacs-lisp
(use-package org-refile
  :custom
  (org-refile-targets
   ;; Allow refiling in same file up to level 3.
   '((nil . (:maxlevel . 3))))
  :ensure nil)
#+END_SRC

** Other

*** org-babel
:PROPERTIES:
:UNNUMBERED: t
:END:

Convenient (and less safe) source block interaction.

#+BEGIN_SRC emacs-lisp
(use-package ob
  :config
  (wal/append
   'org-babel-load-languages
   '((shell . t)
     (python . t)
     (latex . t)
     (js . t)))
  :custom
  (org-confirm-babel-evalute nil)
  :ensure nil)
#+end_src

*** org-clock
:PROPERTIES:
:UNNUMBERED: t
:END:

You know the drill. Clock in, clock out.

#+BEGIN_SRC emacs-lisp
(defun wal/org-clock-in-switch-to-state (todo-state)
  "Only switch state to IN PROGRESS if TODO-STATE was given."
  (when todo-state
    "IN PROGRESS"))

(defun wal/org-clock-heading ()
  "Render a truncated heading for modeline."
  (when (and (fboundp 'org-link-display-format) (fboundp 'org-get-heading))
    (let ((heading (org-link-display-format
	                (org-no-properties (org-get-heading t t t t)))))
      (wal/truncate heading 12))))

(defun wal/org-clock-in-from-now ()
  "Force `org-clock-in' without continuous logging."
  (let ((org-clock-continuously nil))
    (when (fboundp 'org-clock-in)
      (org-clock-in))))

(use-package org-clock
  :init
  (add-to-list 'org-speed-commands '("N" . wal/org-clock-in-from-now))
  :custom
  (org-clock-idle-time 60)
  (org-clock-continuously t)
  (org-clock-persist t)
  (org-clock-in-switch-to-state 'wal/org-clock-in-switch-to-state)
  (org-clock-in-resume t)
  (org-clock-report-include-clocking-task t)
  (org-clock-out-remove-zero-time-clocks t)
  (org-clock-into-drawer t)
  (org-clock-heading-function #'wal/org-clock-heading)
  :bind
  (:map goto-map
    ("t" . org-clock-goto))
  :after org
  :ensure nil)
#+END_SRC

*** org-duration
:PROPERTIES:
:UNNUMBERED: t
:END:

Set up durations for a 40-hour week.

#+BEGIN_SRC emacs-lisp
(use-package org-duration
  :config
  (wal/replace-in-alist
    org-duration-units
    `(("d" . ,(* 60 8))
      ("w" . ,(* 60 8 5))
      ("m" . ,(* 60 8 5 4))
      ("y" . ,(* 60 8 5 4 11))))
  :after org
  :ensure nil)
#+END_SRC

*** org-keys
:PROPERTIES:
:UNNUMBERED: t
:END:

Add some user speed commands.

#+BEGIN_SRC emacs-lisp
(use-package org-keys
  :config
  (wal/replace-in-alist org-speed-commands wal/org-speed-commands)
  :custom
  (org-use-speed-commands t)
  (org-return-follows-link t)
  :after org
  :ensure nil)
#+END_SRC

*** org-bullets
:PROPERTIES:
:UNNUMBERED: t
:END:

Prettier headlines.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :wal-ways nil
  :custom
  (org-bullets-bullet-list '("◆" "◈" "►" "▻" "▸" "▹" "•"))
  :hook (org-mode . org-bullets-mode))
#+END_SRC

*** org-modern
:PROPERTIES:
:UNNUMBERED: t
:END:

Modern look.

#+begin_src emacs-lisp
(use-package org-modern
  :wal-ways nil
  :custom
  (org-modern-star nil)
  (org-modern-hide-stars nil)
  (org-modern-variable-pitch nil)
  (org-modern-label-border 0.1)
  :hook (org-mode . org-modern-mode)
  :ensure nil)
#+end_src

*** org-sticky-header
:PROPERTIES:
:UNNUMBERED: t
:END:

Display current location in a sticky header.

#+BEGIN_SRC emacs-lisp
(use-package org-sticky-header
  :wal-ways nil
  :custom
  (org-sticky-header-full-path 'full)
  (org-sticky-header-prefix
   (concat (all-the-icons-fileicon "org"
                                   :face 'font-lock-keyword-face
                                   :height 0.8
                                   :v-adjust -0.1
                                   :h-adjust: 0.2) " "))
  (org-sticky-header-outline-path-separator " → ")
  (org-sticky-header-show-keyword nil)
  (org-sticky-header-show-priority nil)
  :hook (org-mode . org-sticky-header-mode))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-org)

;;; wal-org.el ends here
#+END_SRC

* Dired
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-dired.el" wal/emacs-config-package-path)
:END:

Run =dired= with =C-x d=.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-dired.el --- Dired. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide Dired packages.

;;; Code:

(declare-function dired-read-dir-and-switches "ext:dired.el")
#+END_SRC

** Packages

*** dired
:PROPERTIES:
:UNNUMBERED: t
:END:

The mother of all buffers. You don't need no tree views.

#+BEGIN_SRC emacs-lisp
(defun wal/dired-from-home (dirname &optional switches)
  "Find DIRNAME local to HOME directory.
Uses the same optional SWITCHES."
  (interactive (let ((default-directory (expand-file-name "~/")))
                 (dired-read-dir-and-switches "")))
  (pop-to-buffer-same-window (dired-noselect dirname switches)))

(defun wal/image-dired ()
  "Run `image-dired' in the `default-directory'."
  (interactive)
  (image-dired (expand-file-name default-directory)))

(use-package dired
  :config
  (put 'dired-find-alternate-file 'disabled nil)
  (define-key dired-mode-map (kbd "C-o") nil) ; Removes `dired-display-file'.
  (transient-define-prefix wal/dired ()
    "Access Dired commands."
    [["Utility"
      ("q" "query replace" dired-do-query-replace-regexp)
      ("t" "create empty file" dired-create-empty-file)]
     ["Other"
      ("v" "show images" wal/image-dired)]])
  :custom
  (dired-listing-switches "-lah --group-directories-first")
  (dired-auto-revert-buffer t)
  (dired-kill-when-opening-new-dired-buffer nil) ; New in Emacs 28.
  :bind
  (:map ctl-x-map
   ("j" . dired-jump)
   :map ctl-x-x-map
   ("d" . wal/dired-from-home)
   ("j" . dired-jump-other-window)
   :map dired-mode-map
   ("." . dired-up-directory) ; Overrides `dired-clean-directory'.
   ("," . dired-display-file))
  :general
  (wal/major! wal/dired :keymaps 'dired-mode-map)
  :ensure nil)
#+END_SRC

*** dired-filter
:PROPERTIES:
:UNNUMBERED: t
:END:

Hit =/= to filter in dired buffers.

#+BEGIN_SRC emacs-lisp
(use-package dired-filter
  :delight " drf"
  :demand
  :after dired)
#+END_SRC

*** diredfl
:PROPERTIES:
:UNNUMBERED: t
:END:

Highlighting in dired buffers.

#+BEGIN_SRC emacs-lisp
(use-package diredfl
  :wal-ways nil
  :config
  (diredfl-global-mode)
  :demand
  :after dired)
#+END_SRC

*** wdired
:PROPERTIES:
:UNNUMBERED: t
:END:

Did you know you can edit =dired= buffers using =C-x C-q=?

#+BEGIN_SRC emacs-lisp
(use-package wdired
  :custom
  (wdired-allow-to-change-permissions t)
  :bind
  (:map wdired-mode-map
   ("C-c C-k" . wdired-abort-changes))
  :ensure nil)
#+END_SRC

*** all-the-icons-dired
:PROPERTIES:
:UNNUMBERED: t
:END:

Show file icons.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :wal-ways nil
  :custom
  (all-the-icons-dired-monochrome nil)
  :hook (dired-mode . all-the-icons-dired-mode)
  :after all-the-icons
  :diminish)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-dired)

;;; wal-dired.el ends here
#+END_SRC

* Terminal
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-terminal.el" wal/emacs-config-package-path)
:END:

#+BEGIN_QUOTE
I am convinced that we are in a terminal process.
— E. P. Thompson
#+END_QUOTE

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-terminal.el --- Terminal. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide terminal packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function project-buffers "ext:project.el")
(declare-function projectile-project-p "ext:projectile.el")
(declare-function projectile-project-buffers "ext:projectile.el")
(declare-function wal/univ-p "wal-func.el")
(declare-function wdb/side "wal-func.el")

(defvar eshell-highlight-prompt)
(defvar eshell-prompt-function)
(defvar wal/use-projectile)
#+END_SRC

** Packages

*** with-editor
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package with-editor
  :custom
  (with-editor-mode-lighter " w/e"))
#+END_SRC

*** vterm
:PROPERTIES:
:UNNUMBERED: t
:END:

=vterm= is better[fn:17] than included shells.

Some common shell commands require an additional =C-c=:

+ =C-c C-c= to send =C-c=.
+ =C-c C-g= to send =C-g=.
+ =C-c C-u= to send =C-u=.
+ =C-c C-t= to enter/exit =copy-mode=.

#+BEGIN_SRC emacs-lisp
(defconst wal/vterm-prefix "VTerm")

(defun wal/vterm-mode ()
  "Hook into `vterm-mode'.

This disables `ctrlf-mode' locally and sets the query on exit
flag to nil for the vterm process."
  (ctrlf-local-mode -1)
  (when-let* ((buf (current-buffer))
              (proc (get-buffer-process buf)))
    (set-process-query-on-exit-flag proc nil)))

(defun wal/vterm (&optional force-new)
  "Get a `vterm' buffer.

If called from a project buffer, this only creates a `vterm'
buffer if one doesn't exist yet (unless called with
FORCE-NEW/`universal-argument')."
  (interactive "P")
  (if-let* ((cont (and (not force-new)
                       (if wal/use-projectile
                           (projectile-project-p)
                         (project-current))))
            (buffers (if wal/use-projectile
                         (projectile-project-buffers)
                       (project-buffers (project-current))))
            (project-vterm
             (cl-find-if
              #'(lambda (it)
                  (and (provided-mode-derived-p
                        (buffer-local-value 'major-mode it)
                        'vterm-mode)
                       (string-match-p
                        wal/vterm-prefix
                        (buffer-name it))))
              buffers)))
      (switch-to-buffer project-vterm)
    (vterm)))

(use-package vterm
  :wal-ways nil
  :custom
  (vterm-buffer-name-string (concat wal/vterm-prefix ": %s"))
  :bind
  ("C-c t" . wal/vterm)
  :hook
  ((vterm-mode . wal/vterm-mode)
   (vterm-mode . with-editor-export-git-editor))
  :delight
  (vterm-copy-mode " vcp"))
#+END_SRC

**** =fish= configuration
:PROPERTIES:
:UNNUMBERED: t
:END:

Add this function to your =fish= configuration to title your =vterm=
buffers.

#+BEGIN_SRC fish :tangle no
function fish_title
  if set -q argv[1] && test argv[1] != "fish"
    echo $argv[1]":"
  end
  echo (pwd)"@"(hostname)
end
#+END_SRC

** Eshell

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack eshell
  "Make eshell feel like a feature-complete shell."
  :packages (esh-autosuggest
             eshell-prompt-extras
             eshell-syntax-highlighting))
#+END_SRC

*** eshell
:PROPERTIES:
:UNNUMBERED: t
:END:

Set up =eshell=. I like the idea of it but I don't really use it.

#+BEGIN_SRC emacs-lisp
(defun wal/advise-eshell/clear (&rest _r)
  "Advise to truncate buffer."
  (let ((eshell-buffer-maximum-lines 0))
    (when (fboundp 'eshell-truncate-buffer)
      (eshell-truncate-buffer))))

(use-package eshell
  :config
  (advice-add 'eshell/clear :override #'wal/advise-eshell/clear)
  :general
  (wal/general-sink "e" '(eshell :wk "eshell"))
  :hook
  ((eshell-mode . with-editor-export-editor)
   (eshell-mode . with-editor-export-git-editor))
  :ensure nil)
#+END_SRC

*** esh-autosuggest
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package esh-autosuggest
  :wal-ways nil
  :hook (eshell-mode . esh-autosuggest-mode)
  :ensure nil)
#+END_SRC

*** eshell-prompt-extras
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package eshell-prompt-extras
  :wal-ways nil
  :config
  (setq eshell-highlight-prompt nil
        eshell-prompt-function 'epe-theme-lambda)
  :demand
  :after eshell
  :ensure nil)
#+END_SRC

*** eshell-syntax-highlighting
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package eshell-syntax-highlighting
  :wal-ways nil
  :hook (eshell-mode . eshell-syntax-highlighting-mode)
  :ensure nil)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-terminal)

;;; wal-terminal.el ends here
#+END_SRC

* Version Control
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-vc.el" wal/emacs-config-package-path)
:END:

I'm becoming an old git.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-vc.el --- Version control. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide version control packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wal/captain "wal-key-bindings.el")
(declare-function wal/message-in-a-bottle "wal-lang.el")
#+END_SRC

** Magit

Forget remembering =git= commands, use =transient=.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack magit
  "Support pull requests and code reviews."
  :packages (forge code-review))
#+END_SRC

*** magit
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package magit
  :init
  (wal/univ magit-status-quick wal/magit-dispatch)
  :config
  (transient-define-prefix wal/magit-dispatch ()
    "Call `magit' functions in a `magit'-y way."
    [["Core"
      ("s" "status (full)" magit-status)
      ("b" "blame" magit-blame)]
     ["Files"
      ("f" "find" magit-find-file)
      ("o" "find other window" magit-find-file-other-window)]
     ["Diff"
      ("d" "file" magit-diff-buffer-file)
      ("r" "range" magit-diff-range)]
     ["Other"
      ("x" "run" magit-run)
      ("c" "clone" magit-clone)
      ("t" "time machine" git-timemachine-toggle
       :inapt-if-not (lambda () (featurep 'git-timemachine)))]])
  :wal-bind
  ("m" . wal/univ-magit-status-quick)
  :custom
  (magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1)
  (magit-blame-mode-lighter " mbl")
  (magit-bury-buffer-function 'magit-restore-window-configuration)
  :commands (wal/univ-magit-status-quick wal/magit-dispatch))
#+END_SRC

*** forge
:PROPERTIES:
:UNNUMBERED: t
:END:

Deal with pull/merge requests.

#+BEGIN_SRC emacs-lisp
(use-package forge
  :wal-ways nil
  :demand
  :after magit
  :ensure nil)
#+END_SRC

*** code-review
:PROPERTIES:
:UNNUMBERED: t
:END:

Review pull/merge requests.

#+BEGIN_SRC emacs-lisp
(use-package code-review
  :wal-ways nil
  :demand
  :after forge
  :ensure nil)
#+END_SRC

** Other

*** git-timemachine
:PROPERTIES:
:UNNUMBERED: t
:END:

If you want to go back in time and point fingers at the progenitors of doom.

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :wal-ways nil
  :delight " gtm")
#+END_SRC

*** git-modes
:PROPERTIES:
:UNNUMBERED: t
:END:

Syntax highlighting.

#+BEGIN_SRC emacs-lisp
(use-package git-modes
  :init
  (wal/lang-hook gitignore-mode
    "Hook into `gitignore-mode'."
    :messages '("I don't think I know you"))
  :mode (("/\\.npmignore\\'" . gitignore-mode)
         (".projectile" . gitignore-mode)
         ("/\\.dockerignore" . gitignore-mode)))
#+END_SRC

*** smerge-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

When resolving conflicts, using =ours= and =theirs= should be easy.

#+BEGIN_SRC emacs-lisp
(use-package smerge-mode
  :config
  (defhydra wal/smerge (:hint nil :foreign-keys warn)
    "
%s(wal/ascii-whale-hydra-offset 12)^_p_^
%s`wal/ascii-whale Resolve: _u_   _l_.
%s(wal/ascii-whale-hydra-offset 12)^_n_^
"
    ("p" smerge-prev)
    ("n" smerge-next)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all "keep all")
    ("q" nil "quit"))
  (wal/lieutenant :keymaps 'smerge-mode-map
    "@" '(:keymap smerge-basic-map :wk "smerge"))
  :general
  (wal/major :keymaps 'smerge-mode-map
    "@" '(wal/smerge/body :wk "smerge"))
  :ensure nil
  :delight " smg")
#+END_SRC

*** ediff
:PROPERTIES:
:UNNUMBERED: t
:END:

Use a single frame and split horizontally when diffing.

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :custom
  (ediff-window-setup-function #'ediff-setup-windows-plain) ; Single frame.
  (ediff-split-window-function #'split-window-horizontally)
  :ensure nil)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-vc)

;;; wal-vc.el ends here
#+END_SRC

* Languages
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-lang.el" wal/emacs-config-package-path)
:END:

Let's greet the world[fn:18].

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-lang.el --- Languages. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide Emacs settings/configurations.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function add-node-modules-path "ext:add-node-modules-path.el")
(declare-function poetry-get-virtualenv "ext:poetry.el")
(declare-function poetry-venv-exist-p "ext:poetry.el")
(declare-function wal/biased-random "wal-func.el")
(declare-function wal/disable-tabs "wal-settings.el")
(declare-function wdb/side "wal-func.el")
(declare-function wal/install-packages "wal-func.el")
(declare-function wal/lsp "wal-lsp.el")
(declare-function wal/major "wal-key-bindings.el")
(declare-function wal/maybe-enable-tabs "wal-settings.el")
(declare-function wal/maybe-intern "wal-func.el")
(declare-function wal/message-in-a-bottle "wal-func.el")

(defvar js2-mode-map)
(defvar wal/ascii-whale)
(defvar wal/use-projectile)
#+END_SRC

** Elixir

Bitches brew.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack elixir
  "For Elixir developers."
  :packages (elixir-mode))
#+END_SRC

*** elixir-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package elixir-mode
  :wal-ways nil
  :init
  (wal/lang-hook elxir-mode
    "Hook into `elixir-mode'."
    :lsp t
    :messages '("Mixin' potions" "A hex on you"))
  :ensure nil)
#+END_SRC

** C/C++

I want to be ready for =jai=.

*** c++-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package cc-mode
  :init
  (wal/lang-hook c++-mode
    "Hook into `c++-mode'."
    :lsp t
    :messages '("Make tidy! Make clean!" "Serenity now!"))
  :config
  ;; Eliminates conflicts with `delight'.
  (advice-add 'c-update-modeline :override #'ignore)
  (transient-define-prefix wal/c++ ()
    "Access `c++-mode' commands."
    [["Style"
      ("s s" "set" c-set-style)
      ("s g" "guess" c-guess-install)]])
  :general
  (wal/major! wal/c++ :keymaps 'c++-mode-map)
  :mode ("\\.h\\'" . c++-mode) ; I don't use C, no need to (often incorrectly) guess.
  :ensure nil)
#+END_SRC

** Rust

Consider the lobster.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack rust
  "For Rust developers."
  :packages (rust-mode cargo))
#+END_SRC

*** rust-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Follow [[https://rust-analyzer.github.io/manual.html#rust-analyzer-language-server-binary][these instructions]] to download the =rust-analyzer= binary.

#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :if (executable-find "cargo")
  :wal-ways nil
  :init
  (wal/lang-hook rust-mode
    "Hook into `rust-mode'."
    :lsp t
    :messages '("Consider the lobster"))
  :config
  (transient-define-prefix wal/rust ()
    "Access `rust-mode' commands."
    [["Commands"
      ("c" "compile" rust-compile)
      ("r" "run" rust-run)]
     ["Test"
      ("t a" "test all" rust-test)
      ("t c" "current" cargo-process-current-test)
      ("t f" "file" cargo-process-current-file-tests)]])
  :general
  (wal/major! wal/rust :keymaps 'rust-mode-map)
  :ensure nil)
#+END_SRC

*** cargo
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package cargo
  :wal-ways nil
  :demand
  :after rust-mode
  :ensure nil)
#+END_SRC

** Python

Hide those details from me.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack python
  "Virtual environment, isort, poetry and notebook support."
  :packages (pyvenv python-isort python-pytest poetry)
  :extras (ein))
#+END_SRC

*** python-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Use snake when you can't =make=.

#+BEGIN_SRC emacs-lisp
(use-package python
  :init
  (wal/lang-hook python-mode
    "Hook into `python-mode'."
    :lsp t
    :messages '("Watch out for snakes!" "Vegetation, aggravation")
    (setq-local comment-inline-offset 2)
    (wal/activate-venv))
  :config
  (with-eval-after-load 'dap-mode
    (require 'dap-python))
  (wdb/side 'inferior-python-mode)
  (transient-define-prefix wal/python ()
    "Access `python-mode' commands."
    [["Inferior shell"
      ("r" "run shell" run-python)
      ("i r" "send region" python-shell-send-region)
      ("i b" "send buffer" python-shell-send-buffer)
      ("i f" "send file" python-shell-send-file)]
     ["Commands"
      ("s" "isort" python-isort-buffer
       :inapt-if-not (lambda () (fboundp 'python-isort-buffer)))]
     ["Test"
      ("t" "pytest" python-pytest-dispatch
       :inapt-if-not (lambda () (fboundp 'python-pytest-dispatch)))]
     ["Notebooks"
      ("e r" "ein run" ein:run)
      ("e s" "ein stop" ein:stop)]
     ["Virtual environment"
      ("v" "activate pyvenv" pyvenv-activate)]
     ["Poetry"
      ("p" "poetry" poetry)]])
  :general
  (wal/major! wal/python :keymaps 'python-mode-map)
  :ensure nil)
#+END_SRC

*** python-isort
:PROPERTIES:
:UNNUMBERED: t
:END:

Sort with =isort=.

#+begin_src emacs-lisp
(use-package python-isort
  :wal-ways nil
  :demand
  :after python-mode
  :ensure nil)
#+end_src

*** python-pytest
:PROPERTIES:
:UNNUMBERED: t
:END:

Test with =pytest=.

#+BEGIN_SRC emacs-lisp
(use-package python-pytest
  :wal-ways nil
  :config
  (wdb/pop-up python-pytest-buffer-name)
  :bind
  (:map python-pytest-mode-map
   ("g" . python-pytest-repeat)
   ("q" . quit-window))
  :demand
  :after python-mode
  :ensure nil)
#+END_SRC

*** ein
:PROPERTIES:
:UNNUMBERED: t
:END:

Work with Jupyter notebooks.

#+BEGIN_SRC emacs-lisp
(use-package ein
  :wal-ways nil
  :demand
  :after python-mode
  :ensure nil)
#+END_SRC

*** Virtual Envs

It takes more than one environment to make sense of Python code.

#+BEGIN_SRC emacs-lisp
(defun wal/configure-python-lsp-server (venv)
  "Configure poetry-managed server using VENV."
  (let ((pylsp (file-exists-p (expand-file-name "bin/pylsp" venv)))
        (jedi-env (expand-file-name (poetry-get-virtualenv))))
    (when pylsp
      (setq-local lsp-pylsp-server-command '("poetry" "run" "pylsp"))
      (setq-local lsp-pylsp-plugins-jedi-environment jedi-env))))

(defun wal/activate-venv ()
  "Activate venv using poetry.

This also works if the project isn't a poetry project."
  (interactive)
  (condition-case err
      (let* ((venv (poetry-venv-exist-p))
             (is-poetry (poetry-find-project-root)))
        (when venv
          (setq-local python-shell-virtualenv-root venv)
          (if is-poetry
              (progn
                (wal/configure-python-lsp-server venv)
                (poetry-venv-workon))
            (pyvenv-activate venv))))
    (error
     (message "Failed to activate venv: %s" err))))
#+END_SRC

**** pyvenv
:PROPERTIES:
:UNNUMBERED: t
:END:

Activating =virtualenv= inside of Emacs.

#+BEGIN_SRC emacs-lisp
(use-package pyvenv
  :wal-ways nil
  :demand
  :after python-mode
  :ensure nil)
#+END_SRC

**** poetry
:PROPERTIES:
:UNNUMBERED: t
:END:

=poetry= is like =npm= for Python, it's why it rhymes.

#+BEGIN_SRC emacs-lisp
(use-package poetry
  :wal-ways nil
  :commands (poetry-venv-exist-p)
  :ensure nil)
#+END_SRC

** Lisp

The philosopher's choice.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack lisp
  "For (common-) Lisp developers using sbcl."
  :packages (highlight-quoted slime))

(wal/define-expansion-pack clojure
  "For Clojure developers using cider with lein."
  :packages (clojure-mode cider))
#+END_SRC

*** elisp-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package elisp-mode
  :init
  (wal/lang-hook emacs-lisp-mode
    "Hook into `emacs-lisp-mode'."
    :messages '("So it's just a bunch of lists?" "List your lambdas")
    (prettify-symbols-mode)
    (flycheck-mode 1))
  :config
  (transient-define-prefix wal/elisp ()
    "Access `elisp' commands."
    [["Utility"
      ("p" "check parens" check-parens)
      ("d" "edebug function" edebug-defun)
      ("h" "helpful" helpful-at-point)
      ("m" "expand macro" emacs-lisp-macroexpand)]])
  :general
  (wal/major! wal/elisp :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map))
  :ensure nil)
#+END_SRC

*** lisp-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package lisp-mode
  :config
  (transient-define-prefix wal/lisp ()
    "Access `lisp-mode' actions."
    [["Slime"
      ("s" "slime" slime-mode
       :inapt-if-not (lambda (featurep 'slime)))
      ("r" "open REPL" slime
       :inapt-if not (lambda (featurep 'slime)))]])
  :general
  (wal/major! wal/lisp :keymaps 'common-lisp-mode-map)
  :commands (wal/lisp)
  :ensure nil)
#+END_SRC

*** clojure-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Get some closure.

#+begin_src emacs-lisp
(use-package clojure-mode
 :wal-ways nil
 :init
 (wal/lang-hook clojure-mode
   "Hook into `clojure-mode'."
   :lsp t
   :messages '("Cider brew"))
 :config
 (transient-define-prefix wal/clojure ()
   "Access `clojure-mode' commands."
   [["Cider"
     ("r" "repl" cider-jack-in
      :inapt-if-nil (lambda () (featurep 'cider)))
     ("n" "set namespace" cider-repl-set-ns
      :inapt-if-nil (lambda () (featurep 'cider)))]])
 :general
 (wal/major! wal/clojure :keymaps 'clojure-mode-map)
 :ensure nil)
#+end_src

*** cider
:PROPERTIES:
:UNNUMBERED: t
:END:

Can't have closure without REPL.

#+begin_src emacs-lisp
(use-package cider
  :wal-ways nil
  :config
  (wdb/side 'cider-repl-mode)
  :custom
  (cider-jack-in-default 'lein)
  :demand
  :after clojure-mode
  :ensure nil)
#+end_src

*** highlight-quoted
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package highlight-quoted
  :wal-ways nil
  :hook (emacs-lisp-mode . highlight-quoted-mode)
  :ensure nil)
#+END_SRC

*** slime
:PROPERTIES:
:UNNUMBERED: t
:END:

Check out the [[https://lispcookbook.github.io/cl-cookbook/getting-started.html][lisp cookbook]] for =slime=.

#+BEGIN_SRC emacs-lisp
(use-package slime
  :if (executable-find "sbcl")
  :wal-ways nil
  :config
  (setq inferior-lisp-program "sbcl")
  (slime-setup '(slime-fancy slime-quicklisp slime-asdf))
  :demand
  :after lisp-mode
  :ensure nil
  :delight " slm")
#+END_SRC

** JavaScript

Can we have =deno= instead of =node=?

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack javascript
  "For Node.js developers."
  :packages (js2-mode add-node-modules-path prettier)
  :extras (rjsx-mode typescript-mode))
#+END_SRC

*** js2-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :wal-ways nil
  :init
  (wal/lang-hook js2-mode
    "Hook into `js2-mode'."
    :messages '("NaN !== NaN" "Null falsy values or undefined")
    :tabs t
    :lsp t
    (when (fboundp 'add-node-modules-path)
      (add-node-modules-path)))
  :config
  ;; Don't override `xref-find-definitions'.
  (define-key js2-mode-map (kbd "M-.") nil)
  (with-eval-after-load 'dap-mode
    (require 'dap-node))
  (transient-define-prefix wal/js ()
    "Access JS commands."
    [["Linting"
      ("p" "prettier" prettier-prettify
       :inapt-if-not (lambda () (featurep 'prettier)))]])
  :custom
  (js2-show-parse-errors nil)
  (js2-highlight-level 3)
  (js2-mode-show-strict-warnings nil)
  (js2-include-node-externs t)
  :bind
  (:map js2-mode-map
   ("<backtab>" . js2-indent-bounce)) ; `js2-bounce-indent-p' also binds <TAB>.
  :general
  (wal/major! wal/js :keymaps '(js2-mode-map rjsx-mode-map typescript-mode-map))
  :mode "\\.js\\'"
  :ensure nil)
#+END_SRC

*** rjsx-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Improved editing for JSX files. Extends =js2=.

#+BEGIN_SRC emacs-lisp
(use-package rjsx-mode
  :wal-ways nil
  :init
  (wal/lang-hook rjsx-mode
    "Hook into `rjsx-mode'."
    :tabs 'js-jsx-indent-line
    :messages '("Extend those ugly JavaScripts of yours!"))
  :mode "\\.jsx\\'"
  :ensure nil)
#+END_SRC

*** typescript-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Please use TypeScript.

#+BEGIN_SRC emacs-lisp
(use-package typescript-mode
  :wal-ways nil
  :init
  (wal/lang-hook typescript-mode
    "Hook into `typescript-mode'."
    :lsp t
    :tabs t
    :messages '("This is any, that is any, everything is any!")
    (add-node-modules-path))
  :mode "\\.ts\\'"
  :ensure nil)
#+END_SRC

*** add-node-modules-path
:PROPERTIES:
:UNNUMBERED: t
:END:

Allow accessing a project's =node_modules=.

#+BEGIN_SRC emacs-lisp
(use-package add-node-modules-path
  :wal-ways nil
  :ensure nil)
#+END_SRC

*** prettier
:PROPERTIES:
:UNNUMBERED: t
:END:

Prettify your ugly JavaScript.

#+BEGIN_SRC emacs-lisp
(use-package prettier
  :wal-ways nil
  :demand
  :after js2-mode
  :ensure nil)
#+END_SRC

** Go

Ogling new languages.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack go
  "For Go developers."
  :packages (go-mode))
#+END_SRC

*** go-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Setup for LSP.

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :wal-ways nil
  :init
  (wal/lang-hook go-mode
    "Hook into `go-mode'."
    :lsp t
    :messages '("What does Sonic say?" "Put a golang under your tongue"))
  :ensure nil)
#+END_SRC

** Scripting

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack fish
  "For fish shell users."
  :packages (fish-mode))

(wal/define-expansion-pack cli
  "For CLI power users."
  :packages (crontab-mode))
#+END_SRC

*** sh-script
:PROPERTIES:
:UNNUMBERED: t
:END:

Bash your head in!

#+BEGIN_SRC emacs-lisp
(use-package sh-script
  :init
  (wal/lang-hook sh-mode
    :messages '("Sh..sh..h.." "Bash your head in"))
  :custom
  (sh-basic-offset 2)
  (sh-indent-after-continuation nil)
  :ensure nil)
#+END_SRC

*** crontab-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Sometimes you have to deal with things at their time.

#+BEGIN_SRC emacs-lisp
(use-package crontab-mode
  :wal-ways nil
  :ensure nil)
#+END_SRC

*** fish-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Support =fish= functions.

#+BEGIN_SRC emacs-lisp
(use-package fish-mode
  :wal-ways nil
  :custom
  (fish-indent-offset 2)
  :ensure nil)
#+END_SRC

** Markup

Sometimes things that don't do things need to look nice.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack markdown
  "For MD users."
  :packages (markdown-mode))
#+END_SRC

*** markdown-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(defun wal/markdown-view ()
  "Toggle between different markdown views."
  (interactive)
  (cond
   ((eq major-mode 'markdown-mode)
    (markdown-view-mode)
    (mixed-pitch-mode 1))
   ((eq major-mode 'markdown-view-mode)
    (markdown-mode)
    (mixed-pitch-mode -1))
   (t
    (error "Can't change view outside of markdown modes"))))

(use-package markdown-mode
  :wal-ways nil
  :config
  (transient-define-prefix wal/markdown ()
    "Access `markdown-mode' commands."
    [["View"
      ("v" "toggle view" wal/markdown-view)]])
  :general
  (wal/major! wal/markdown :keymaps 'markdown-mode-map)
  :ensure nil)
#+END_SRC

** Flutter

Yes, you need to install *Android Studio* for some reason.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack flutter
  "Dart major mode and LSP package."
  :packages (dart-mode lsp-dart))
#+END_SRC

*** dart-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package dart-mode
  :wal-ways nil
  :init
  (wal/lang-hook dart-mode
    "Hook into `dart-mode'."
    :lsp t
    :messages '("Bull's eye!"))
  :ensure nil)
#+END_SRC

*** lsp-dart
:PROPERTIES:
:UNNUMBERED: t
:END:

LSP support for Dart.

#+BEGIN_SRC emacs-lisp
(defun wal/find-dart-flutter-sdk-dir ()
  "Find the Dart Flutter SDK directory."
  (when-let* ((flutter-bin (executable-find "flutter"))
              (sdk-dir (string-trim (shell-command-to-string "flutter sdk-path"))))
    sdk-dir))

(defun wal/find-dart-sdk-dir ()
  "Find the Dart SDK directory."
  (when-let* ((flutter-sdk-dir (wal/find-dart-flutter-sdk-dir)))
    (expand-file-name "bin/cache/dart-sdk" flutter-sdk-dir)))

(defun wal/lsp-dart-set-process-query-on-exit-flag ()
  "Set the query-on-exit flag to nil for the Dart language server."
  (defvar lsp-dart-flutter-daemon-buffer-name)
  (when-let (proc (get-buffer-process lsp-dart-flutter-daemon-buffer-name))
    (set-process-query-on-exit-flag proc nil)))

(defun wal/lsp-dart-service-uri ()
  "Get the service URI (needed for devtools)."
  (interactive)
  (condition-case err
      (when (fboundp 'lsp-workspace-get-metadata)
        (let ((uri (lsp-workspace-get-metadata "devtools-vm-service-uri")))
          (kill-new uri)
          (message "Service URI (%s) copied to kill ring" uri)))
    (error
      (message "Couldn't get service URI: %s" err))))

(use-package lsp-dart
  :if (or (executable-find "flutter") (executable-find "dart"))
  :wal-ways nil
  :config
  (when (fboundp 'lsp-dart-define-key)
    (lsp-dart-define-key "r" #'lsp-dart-run))
  (add-hook
   'lsp-after-initialize-hook
   #'wal/lsp-dart-set-process-query-on-exit-flag)
  (wdb/side "\\*Flutter" :height 10)
  (transient-define-prefix wal/flutter ()
    "Access flutter commands."
    [["Hot-reloading"
      ("R" "restart" lsp-dart-dap-flutter-hot-restart)
      ("r" "reload" lsp-dart-dap-flutter-hot-reload)]
     ["Test"
      ("t c" "current" lsp-dart-run-test-at-point)
      ("t a" "all" lsp-dart-run-all-tests)]
     ["Devtools"
      ("d" "open" lsp-dart-open-devtools)
      ("u" "get service URI" wal/lsp-dart-service-uri)]])
  :custom
  (lsp-dart-flutter-sdk-dir (wal/find-dart-flutter-sdk-dir))
  (lsp-dart-sdk-dir (wal/find-dart-sdk-dir))
  (lsp-dart-dap-use-sdk-debugger nil) ; Run `lsp-dart-dap-setup' once to install debugger.
  :general
  (wal/major! wal/flutter :keymaps 'dart-mode-map)
  :after lsp-mode
  :ensure nil)
#+END_SRC

** Java

It's a =JavaEmacsPackageConfigurationSectionFactory=, mate.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack java
  "Java LSP package."
  :packages (lsp-java))
#+END_SRC

*** java-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
;; For some reason, this is also defined in `cc-mode'.
(use-package cc-mode
  :init
  (wal/lang-hook java-mode
    "Hook into `java-mode'."
    :lsp t
    :messages '("Mmmh ... maven"))
  :ensure nil)
#+END_SRC

*** lsp-java
:PROPERTIES:
:UNNUMBERED: t
:END:

LSP integration.

#+begin_src emacs-lisp
(defconst wal/jdtls-fs
  "https://download.eclipse.org/jdtls/milestones/%1$s/jdt-language-server-%1$s-%2$s.tar.gz"
  "The base URL for jdtls.")

(use-package java-lsp
  :wal-ways nil
  :config
  (require 'dap-java)
  :custom
  ;; Latest version.
  (lsp-java-jdt-download-url (format wal/jdtls-fs "1.9.0" "202203031534"))
  ;; Suggested fix for failing completion.
  (lsp-java-format-on-type-enabled nil)
  (lsp-java-references-code-lens-enabled t)
  (lsp-java-implementations-code-lens-enabled t)
  (lsp-java-signature-help-enabled nil)
  :ensure nil)
#+end_src

** PHP

The elephant in the room.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack php
  "Major mode and web mode for templates."
  :packages (php-mode web-mode))
#+END_SRC

*** php-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package php-mode
  :wal-ways nil
  :init
  (wal/lang-hook php-mode
    "Hook into `php-mode'."
    :lsp t
    :messages '("Stampy, no!"))
  :config
  (require 'dap-php) ; Run `dap-php-setup'.
  (wdb/side "\\*Php SOE" :height 15)
  :ensure nil)
#+END_SRC

*** web-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :wal-ways nil
  :init
  (wal/lang-hook web-mode
    "Hook into `web-mode'."
    :lsp t
    :tabs t
    :messages '("This is the Internet"))
  :custom
  (web-mode-comment-style 2)
  :mode ("\\.vue\\'"
         "\\.blade.php\\'"
         "\\.component.html\\'")
  :ensure nil)
#+END_SRC

** Web

Does anyone actually like web development?

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack web
  "For web developers."
  :packages (yaml-mode jsonian)
  :extras (pug-mode))
#+END_SRC

*** jsonian
:PROPERTIES:
:UNNUMBERED: t
:END:

The only way to store strings, JSON.

#+BEGIN_SRC emacs-lisp
(use-package jsonian
  :wal-ways nil
  :init
  (wal/lang-hook jsonian-mode
    "Hook into `jsonian-mode'."
    :tabs t
    :messages '("JSON ...? JSON?! JSON!!")
    (flycheck-mode 1))
  :config
  (jsonian-no-so-long-mode)
  (with-eval-after-load 'flycheck
    (jsonian-enable-flycheck))
  (transient-define-prefix wal/jsonian ()
    "Access `jsonian-mode' commands."
    [["Jsonian"
      ("f" "find" jsonian-find)
      ("e" "edit" jsonian-edit-string)]])
  :general
  (wal/major! wal/jsonian :keymaps 'jsonian-mode-map)
  :mode ("\\.arb\\'" . jsonian-mode)
  :after so-long
  :ensure nil)
#+END_SRC

*** yaml-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Sometimes things that do as well.

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :wal-ways nil
  :init
  (wal/lang-hook yaml-mode
    "Hook into command `yaml-mode'."
    :messages '("JSON?! ... Ah, thank God it's you, YAML!")
    (drag-stuff-mode +1)
    (flycheck-mode +1))
  :mode "\\.tpl\\'" ; Helm templates.
  :ensure nil)
#+END_SRC

*** css-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

We want quicker suggestions when in CSS modes.

#+BEGIN_SRC emacs-lisp
(use-package css-mode
  :init
  (wal/lang-hook css-mode
    "Hook into `css-mode'."
    :tabs t
    :messages '("Centering? It's simple. Here's 15 ways to do it.")
    (setq-local corfu-auto-delay 0.1)
    (flycheck-mode +1))
  :ensure nil)
#+END_SRC

*** pug-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Support for =pug= templates.

#+BEGIN_SRC emacs-lisp
(use-package pug-mode
  :wal-ways nil
  :ensure nil)
#+END_SRC

** Games

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack games
  "For game developers."
  :packages (gdscript-godot))
#+END_SRC

*** gdscript-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

The engine you've been waiting for.

#+BEGIN_SRC emacs-lisp
;; Workaround from https://github.com/godotengine/emacs-gdscript-mode#known-issues
(defun wal/advise-lsp--get-message-type (fun &rest args)
  "Advise FUN, passing ARGS.

This will ignore the error message resulting from Godot not
replying to the `JSONRPC' request."
  (if (string-equal major-mode "gdscript-mode")
      (let ((json-data (nth 0 args)))
        (unless (and (string= (gethash "jsonrpc" json-data "") "2.0")
                     (not (gethash "id" json-data nil))
                     (not (gethash "method" json-data nil)))
          (apply fun args)))
    (apply fun args)))

(use-package gdscript-mode
  :wal-ways nil
  :init
  (wal/lang-hook gdscript-mode
    "Hook into `gdscript-mode'."
    :lsp t
    :tabs always
    :messages '("I wish you were Estra-gone"))
  (when wal/use-projectile
    (eval-after-load 'projectile
      '(projectile-register-project-type
        'godot
        '("project.godot")
        :project-file "project.godot")))
  :config
  (advice-add
   'lsp--get-message-type :around
   #'wal/advise-lsp--get-message-type)
  :ensure nil)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-lang)

;;; wal-lang.el ends here
#+END_SRC

* Fixing Things
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-fix.el" wal/emacs-config-package-path)
:END:

Please let me know when I screwed up. I promise I will learn.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-fix.el --- Fixing things. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide fixing packages.

;;; Code:
#+END_SRC

** Packages

*** flycheck
:PROPERTIES:
:UNNUMBERED: t
:END:

=flycheck= is for all of our linting/code quality needs.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :custom
  (flycheck-mode-line-prefix "fly")
  :general
  (wal/lieutenant :keymaps 'flycheck-mode-map
    "f" '(:keymap flycheck-command-map :wk "flycheck"))
  :hook (sh-set-shell . flycheck-mode))
#+END_SRC

*** flyspell
:PROPERTIES:
:UNNUMBERED: t
:END:

My spelling is bad. Uses American English for =flyspell=.

#+BEGIN_SRC emacs-lisp
(defun wal/flyspell ()
  "(De-)Activate the appropriate `flyspell' mode."
  (interactive)
  (if (derived-mode-p 'prog-mode)
      (flyspell-prog-mode)
    (flyspell-mode)))

(use-package flyspell
  :custom
  (flyspell-issue-message-flag nil)
  (flyspell-mode-line-string " fsp")
  (flyspell-default-dictionary "american")
  :bind
  (:map flyspell-mode-map
   ("C-." . ispell-word)) ; Replaces `flyspell-auto-correct-word', which is still available via `C-M-i'.
  :general
  (wal/major "s" #'wal/flyspell :predicate '(lambda () (not flyspell-mode)))
  (wal/major :keymaps 'flyspell-mode-map
    "s" '(:ignore t :wk "flyspell")
    "sb" '(flyspell-buffer :wk "buffer")
    "sr" '(flyspell-region :wk "region")
    "sc" '(ispell-change-dictionary :wk "change dictionary"))
  :ensure nil)
#+END_SRC

*** consult-flycheck
:PROPERTIES:
:UNNUMBERED: t
:END:

Find errors by severity.

#+BEGIN_SRC emacs-lisp
(use-package consult-flycheck
  :general
  (general-define-key
    :keymaps 'flycheck-command-map
    "u" '(consult-flycheck :wk "consult flycheck"))
  :demand
  :after (consult flycheck))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-fix)

;;; wal-fix.el ends here
#+END_SRC

* LSP
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-lsp.el" wal/emacs-config-package-path)
:END:

Language servers are awesome. Thanks, Microsoft.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-lsp.el --- LSP. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide LSP packages.

;;; Code:

(eval-when-compile
  (require 'transient)
  (require 'dash)
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function dap--completing-read "ext:dap-mode.el")
(declare-function dap--json-encode "ext:dap-mode.el")
(declare-function dap-register-debug-template "ext:dap-mode.el")
(declare-function lsp-enable-which-key-integration "ext:lsp-mode.el")
(declare-function wal/append "wal-func.el")
(declare-function wal/captain "wal-key-bindings.el")
(declare-function wdb/side "wal-func.el")

(defvar dap-debug-template-configurations)
(defvar lsp-completion-provider)
(defvar lsp-file-watch-ignored-directories)

(defgroup wal-lsp nil
  "Change settings for LSP packages."
  :group 'wal
  :tag "LSP")

(defcustom wal/lsp-slow-modes '()
  "Modes that have slow language servers.

For these modes `corfu' settings will not be adjusted to be
smaller."
  :type '(repeat symbol)
  :group 'wal-lsp)

(defcustom wal/lsp-file-watch-ignored-directories
  '("[/\\\\]build\\'" "[/\\\\]vendor\\'")
  "Additional directories to not monitor."
  :type '(repeat regexp)
  :group 'wal-lsp)
#+END_SRC

** Packages

*** lsp-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

=lsp-mode= is the fancy version. You'll have to install some language
servers yourself[fn:19].

#+BEGIN_SRC emacs-lisp
(defun wal/slow-lsp-p (mode)
  "Check if MODE is considered slow."
  (memq mode wal/lsp-slow-modes))

(defun wal/lsp ()
  "Defer LSP setup for the file.

Unless the associated server is considered slow, delays and
minimum prefixes are reduced."
  (unless (wal/slow-lsp-p major-mode)
    (setq-local corfu-auto-delay 0.0
                corfu-auto-prefix 1))
  (lsp-deferred))

(defun wal/lsp-completion-with-corfu ()
  "Advise completion to work better with `corfu' and `orderless'."
  (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
        completion-styles))

(defun wal/advise-lsp-to-prevent-multi-root (&rest _r)
  "Prevent adding workspace roots from other projects."
  (eval '(setf (lsp-session-server-id->folders (lsp-session)) (ht))))

(use-package lsp-mode
  :wal-ways nil
  :config
  (require 'avy nil t) ; For code lenses to work immediately.
  (wal/append 'lsp-file-watch-ignored-directories
              wal/lsp-file-watch-ignored-directories)
  (advice-add 'lsp :before #'wal/advise-lsp-to-prevent-multi-root)
  (transient-define-prefix wal/lsp-dispatch ()
    "Call `lsp-mode' functions."
    [["Format"
      ("f" "buffer" lsp-format-buffer)
      ("F" "region" lsp-format-region)]
     ["Actions"
      ("a" "execute" lsp-execute-code-action)
      ("l" "jump to lens" lsp-avy-lens)
      ("h" "highlight symbol" lsp-document-highlight)]
     ["Refactor"
      ("r" "rename" lsp-rename)
      ("o" "organize imports" lsp-organize-imports)]
     ["Go to"
      ("d" "definition" lsp-find-definition)
      ("e" "errors" lsp-treemacs-errors-list)
      ("s" "symbol" consult-lsp-file-symbols
       :inapt-if-not (lambda () (featurep 'consult-lsp)))
      ("H" "hierarchy" lsp-treemacs-call-hierarchy)]
     ["Workspace"
      ("R" "restart" lsp-workspace-restart)
      ("Q" "quit" lsp-workspace-shutdown)]])
  (wal/lieutenant :keymaps 'lsp-mode-map
    "l" '(:keymap lsp-command-map :wk "lsp"))
  (lsp-enable-which-key-integration t)
  :custom
  (lsp-headerline-breadcrumb-enable nil)
  (lsp-keymap-prefix (wal/prefix-user-key (concat wal/lieutenant-key " " "l")))
  (lsp-pylsp-plugins-jedi-use-pyenv-environment t)
  (lsp-clients-typescript-log-verbosity "off")
  (lsp-rust-analyzer-cargo-watch-command "clippy")
  (lsp-signature-render-documentation nil)
  (lsp-signature-function 'lsp-signature-posframe)
  (lsp-signature-auto-activate '(:on-server-request))
  (lsp-keep-workspace-alive nil)
  (lsp-completion-provider :none) ;; We're using `corfu'.
  :general
  (wal/major :keymaps 'lsp-mode-map "l" '(wal/lsp-dispatch :wk "lsp"))
  :hook
  (lsp-completion-mode . wal/lsp-completion-with-corfu)
  :delight
  (lsp-mode " lsp")
  (lsp-lens-mode " lns"))
#+END_SRC

*** lsp-ui
:PROPERTIES:
:UNNUMBERED: t
:END:

Don't clutter things up too much.

#+BEGIN_SRC emacs-lisp
(use-package lsp-ui
  :wal-ways nil
  :custom
  (lsp-ui-doc-show-with-cursor t)
  (lsp-ui-doc-delay 1.0)
  (lsp-ui-doc-max-height 10) ; Ensures that docs fit.
  (lsp-ui-doc-text-scale-level -1)
  :after lsp-mode)
#+END_SRC

*** dap-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Debugging using VSCode's DAP (in =lsp-mode=)

#+BEGIN_SRC emacs-lisp
(use-package dap-mode
  :wal-ways nil
  :config
  (dap-ui-mode 1)
  (dap-auto-configure-mode)
  (wdb/side 'dap-ui-repl-mode)
  (with-no-warnings
    (defhydra wal/dap-hydra (:hint nil :foreign-keys warn)
      "
%s`wal/ascii-whale _d_ebug: _n_ext, _i_n, _o_ut or _c_ontinue.
"
      ("n" dap-next)
      ("i" dap-step-in)
      ("o" dap-step-out)
      ("c" dap-continue)
      ("d" dap-debug :color blue)
      ("b" dap-breakpoint-toggle "toggle breakpoint" :color blue)
      ("l" dap-go-to-output-buffer "show logs" :color blue)
      ("f" dap-hydra "full" :color blue)
      ("q" nil)))
  :custom
  (dap-python-executable "python3")
  (dap-python-debugger 'debugpy)
  (dap-auto-show-output nil)
  (dap-auto-configure-features '(repl))
  :general
  (wal/major :keymaps 'lsp-mode-map "d" '(wal/dap-hydra/body :wk "debug"))
  :after lsp-mode
  :delight " dap")
#+END_SRC

*** consult-lsp
:PROPERTIES:
:UNNUMBERED: t
:END:

Jump to symbols with =consult=.

#+begin_src emacs-lisp
(use-package consult-lsp
  :wal-ways nil
  :after (consult lsp-mode))
#+end_src

** Debug Templates

Put these templates in a file in your project root, and evaluate them
there using =C-x C-e=.

#+BEGIN_SRC emacs-lisp
(defun wal/dap-create-launch-json-from-template ()
  "Create and write a VSCode launch configuration using a template."
  (interactive)
  (wal/try dap-mode
    (let* ((args (-> (dap--completing-read "Select template: "
                                           dap-debug-template-configurations
                                           'cl-first nil t)
                     cl-rest
                     copy-tree))
           (serialized (dap--json-encode args))
           (file-args (find-file-read-args "Find file (deleting other windows): "
                                           (confirm-nonexistent-file-or-buffer)))
           (filename (car file-args)))
      (with-temp-buffer
        (insert serialized)
        (json-pretty-print-buffer)
        (write-region (buffer-string) nil filename)))))
#+END_SRC

*** Node.js
:PROPERTIES:
:UNNUMBERED: t
:END:

This for attaching to a remote host (Docker container) using =nodemon=.

For TypeScript compile your =src= with =--sourceMap= or set =sourceMap= to
=true= in your =tsconfig.json=.

#+BEGIN_SRC emacs-lisp :tangle no
(when (require 'dap-mode nil 'noerror)
  (progn
    (let* ((use-source-maps t)          ; Turn off if not needed.
           (build-directory "build")    ; Set to `nil' if this isn't transpiled JavaScript.
           (remote-root "/usr/src/app") ; If this is running remotely.
           (local-root (if build-directory
                           (concat (file-name-directory buffer-file-name) build-directory)
                         (file-name-directory buffer-file-name))))
      (dap-register-debug-template
       "attach::node"
       (list :type "node"
             :request "attach"
             :sourceMaps use-source-maps
             :remoteRoot remote-root
             :localRoot local-root
             :port 9229)))))
#+END_SRC

*** Python
:PROPERTIES:
:UNNUMBERED: t
:END:

Attach to running process.

#+BEGIN_SRC emacs-lisp
(defun wal/dap-register-debugpy-template (name remote-root)
  "Create template for debugpy.

Prompts user for NAME of the template and the REMOTE-ROOT."
  (interactive "sName of the template: \nsRemote root: ")
  (wal/try dap-mode
    (let ((mapping `(:localRoot "${workspaceFolder}" :remoteRoot ,remote-root)))
      (dap-register-debug-template
       name
       (list :type "python"
             :request "attach"
             :connect (list :host "localhost" :port 5678)
             :pathMappings (vector mapping))))))
#+END_SRC

*** Flutter
:PROPERTIES:
:UNNUMBERED: t
:END:

Debugging without sound null safety.

#+BEGIN_SRC emacs-lisp :tangle no
(when (require 'dap-mode nil 'noerror)
  (dap-register-debug-template
   "flutter::unsound"
   (list
    :type "flutter"
    :program "lib/main.dart"
    :args '("--no-sound-null-safety"))))
#+END_SRC

*** Laravel
:PROPERTIES:
:UNNUMBERED: t
:END:

Make sure you expose port =9003=.

#+BEGIN_SRC emacs-lisp :tangle no
(when (require 'dap-mode nil 'noerror)
  (let ((mapping '(:/var/www/html "${workspaceFolder}")))
    (dap-register-debug-template
     "laravel::launch"
     (list
      :type "php"
      :request "launch"
      :port 9003
      :pathMappings mapping))))
#+END_SRC

**** XDebug Config

Put the following into your =php.ini=.

#+BEGIN_SRC conf
[XDebug]
xdebug.start_with_request = yes
xdebug.show_local_vars = on
xdebug.discover_client_host = true
xdebug.client_host = 0.0.0.0
xdebug.client_port = 9003
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-lsp)

;;; wal-lsp.el ends here
#+END_SRC

* DevOps
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-devops.el" wal/emacs-config-package-path)
:END:

Put it into a container and throw it in the garbage that is the
Internet.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-devops.el --- DevOps. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide DevOps packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wdb/side "wal-func.el")
(declare-function wdb/direction "wal-func.el")
(declare-function wal/message-in-a-bottle "wal-func.el")
#+END_SRC

** Docker

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack docker
  "Docker and Kubernetes."
  :packages (docker dockerfile-mode))
#+END_SRC

*** docker
:PROPERTIES:
:UNNUMBERED: t
:END:

What goes =docker-compose= up, goes =docker-compose= down.

#+BEGIN_SRC emacs-lisp
(use-package docker
  :wal-ways nil
  :config
  (wdb/side "\\*docker-containers\\*" :side 'top :height 15)
  (wdb/direction "^\\* docker container")
  (wdb/direction "^\\*docker-compose")
  :custom
  (docker-run-async-with-buffer-function 'docker-run-async-with-buffer-shell)
  (docker-container-default-sort-key '("Names"))
  (docker-image-default-sort-key '("Created" . t))
  (docker-volume-default-sort-key '("Name"))
  (docker-show-status nil)
  :bind
  (("C-c d" . docker))
  :ensure nil)
#+END_SRC

*** dockerfile-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Make =Dockerfiles= look nice.

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :wal-ways nil
  :init
  (wal/lang-hook dockerfile-mode
    "Hook into `dockerfile-mode'."
    :messages '("Have you ever given?"))
  :ensure nil)
#+END_SRC

** Kubernetes

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack kubernetes
  "Kubernetes."
  :packages (kubernetes))
#+END_SRC

*** kubernetes
:PROPERTIES:
:UNNUMBERED: t
:END:

Who doesn't like pods and stuff?

#+BEGIN_SRC emacs-lisp
(use-package kubernetes
  :if (executable-find "kubectl")
  :wal-ways nil
  :custom
  (kubernetes-commands-display-buffer-function 'display-buffer)
  (kubernetes-poll-frequency 3600)
  (kubernetes-redraw-frequency 3600)
  (kubernetes-default-overview-view 'deployments)
  (kubernetes-json-mode (if (featurep 'jsonian-mode) 'jsonian-mode 'js-mode))
  :wal-bind
  ("8" . kubernetes-overview)
  :ensure nil)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-devops)

;;; wal-devops.el ends here
#+END_SRC

* The Internet
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-web.el" wal/emacs-config-package-path)
:END:

I browse, I request.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-web.el --- The Internet. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide web packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wdb/pop-up "wal-func.el")
#+END_SRC

** Requests

*** verb
:PROPERTIES:
:UNNUMBERED: t
:END:

Make requests using Org.

#+BEGIN_SRC emacs-lisp
(defun wal/advise-verb-to-keep-window (&rest _rest)
  "Provide t to `verb-kill-*' functions to keep window."
  (list t))

(use-package verb
  :wal-ways nil
  :init
  (add-to-list 'org-tag-alist '("verb" . ?v))
  (advice-add 'verb-kill-all-response-buffers :filter-args
    #'wal/advise-verb-to-keep-window)
  (advice-add 'verb-kill-response-buffer-and-window :filter-args
    #'wal/advise-verb-to-keep-window)
  :config
  (transient-define-prefix wal/verb ()
    "Dispatch `verb' commands."
    [["Request"
      ("r" "send" verb-send-request-on-point
       :inapt-if-non-nil verb-response-body-mode)
      ("e" "export" verb-export-request-on-point
       :inapt-if-non-nil verb-response-body-mode)]
     ["Response"
      ("R" "resend" verb-re-send-request
       :inapt-if-nil verb-response-body-mode)
      ("k" "kill all" verb-kill-all-response-buffers)]
     ["Variables"
      ("v" "set" verb-set-var)
      ("V" "show" verb-show-vars)]])
  (wal/lieutenant :keymaps '(verb-mode-map verb-response-body-mode-map)
    "v" '(:keymap verb-command-map :wk "verb"))
  :bind
  (:map verb-response-body-mode-map
   ("k" . verb-kill-buffer-and-window)
   ("q" . quit-window))
  :general
  (wal/major :keymaps '(verb-mode-map verb-response-body-mode-map)
    "v" '(wal/verb :wk "verb"))
  :defer 2
  :after org
  :commands (wal/verb)
  :delight
  (verb-mode " vrb")
  (verb-response-body-mode " vRb"))
#+END_SRC

** E-Mails

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack mailing
  "For people reading/writing emails in Emacs."
  :packages (smtpmail))
#+END_SRC

*** mu4e
:PROPERTIES:
:UNNUMBERED: t
:END:

You either need to install =maildir-utils= or build from [[https://github.com/djcb/mu][source]].

#+BEGIN_SRC emacs-lisp
(use-package mu4e
  :if (executable-find "mu")
  :wal-ways nil
  :config
  (setq mail-user-agent 'mu4e-user-agent)
  :custom
  (mu4e-confirm-quit nil)
  (mu4e-completing-read-function 'completing-read)
  (mu4e-compose-dont-reply-to-self t)
  (mu4e-get-mail-command "offlineimap") ; This one works nicely.
  :bind
  ("C-c m" . mu4e)
  :ensure nil)
#+END_SRC

*** smtpmail
:PROPERTIES:
:UNNUMBERED: t
:END:

This configuration is from a (kind of) working [[https://www.djcbsoftware.nl/code/mu/mu4e/Gmail-configuration.html][Gmail setup]].

I recommend putting personal data in a =site-start.el= file somewhere in
your =load-path=.

#+BEGIN_SRC emacs-lisp
(use-package smtpmail
  :wal-ways nil
  :custom
  (message-send-mail-function 'smtpmail-send-it)
  (message-kill-buffer-on-exit t)
  (starttls-use-gnutls t)
  :ensure nil)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-web)

;;; wal-web.el ends here
#+END_SRC

* Writing
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-writing.el" wal/emacs-config-package-path)
:END:

Sometimes you have to sit down and write something.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-writing.el --- Writing. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide writing packages.

;;; Code:
#+END_SRC

** Packages

*** typo
:PROPERTIES:
:UNNUMBERED: t
:END:

Access complex punctuation. To me this doesn't necessarily make sense
for all =text-mode= modes (like =org-mode=), so instead it needs to be
triggered explicitly.

#+BEGIN_SRC emacs-lisp
(use-package typo
  :wal-ways nil
  :hook (typo-mode . flycheck-mode)
  :delight " typ")
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-writing)

;;; wal-writing.el ends here
#+END_SRC

* Fluff
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-fluff.el" wal/emacs-config-package-path)
:END:

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-fluff.el --- Fluff. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide fluff packages. These are not installed by default.

;;; Code:
#+END_SRC


** Packages

*** display-wttr
:PROPERTIES:
:UNNUMBERED: t
:END:

Provide some knowledge of the outside world.

#+BEGIN_SRC emacs-lisp
(defun wal/advise-display-wttr--clean-string (string)
  "Advise to pad STRING."
  (concat " " (string-trim string)))

(use-package display-wttr
  :wal-ways nil
  :config
  (advice-add
   'display-wttr--clean-string :filter-return
   #'wal/advise-display-wttr--clean-string)
  :custom
  (display-wttr-format "1")
  :defer 4
  :ensure nil)
#+END_SRC

*** tokei
:PROPERTIES:
:UNNUMBERED: t
:END:

Display code statistics.

#+BEGIN_SRC emacs-lisp
(use-package tokei
  :if (executable-find "tokei")
  :wal-ways nil
  :ensure nil)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-fluff)

;;; wal-fluff.el ends here
#+END_SRC

* Config Package
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal.el" wal/emacs-config-package-path)
:END:

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal.el --- Walheimat's literate Emacs configuration. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Require all sub-packages.

;;; Code:

(declare-function transient-define-prefix "ext:transient.el")
(declare-function posframe-delete "ext:posframe.el")
(declare-function posframe-refresh "ext:posframe.el")
(declare-function posframe-show "ext:posframe.el")
(declare-function wal/directory-files "init.el")
(declare-function wal/posframe-hidehandler-when-invisible "wal-func.el")
(declare-function wal/tangle-config "init.el")

(defvar wal/emacs-config-default-path)
(defvar wal/emacs-config-package-path)

(defgroup wal nil
  "Walheimat's configuration."
  :group 'convenience
  :prefix "wal/")

(defgroup wal-config nil
  "Customize configuring the packages."
  :group 'wal
  :tag "Configuration")

(defcustom wal/config-show-whale-animation t
  "Whether to show an animated whale while editing the config."
  :type 'boolean
  :group 'wal-config)

(defconst wal/sub-packages
  '(wal-func
    wal-settings
    wal-key-bindings
    wal-look
    wal-fonts
    ;; The following packages are optional.
    wal-emacs
    wal-edit
    wal-windows
    wal-movement
    wal-find
    wal-complete
    wal-workspace
    wal-org
    wal-dired
    wal-terminal
    wal-vc
    wal-visuals
    wal-lang
    wal-fix
    wal-lsp
    wal-devops
    wal-web
    wal-writing
    wal-fluff)
  "List of sub-packages that will be loaded.

The order determines the load order as well.")
#+END_SRC

** Lovable Things

*** Whale Animation

Animate a swimming whale in a =posframe=.

#+BEGIN_SRC emacs-lisp
(defvar wal/ascii-whale-key-frames
  [
   "(__.- >{"
   "(__.' >{"
   "(__.- >{"
   "(__., >{"
   ])
(defvar wal/ascii-whale-frame-index 0)
(defvar wal/ascii-whale-animation-speed 0.4)

(defvar wal/ascii-whale-buffer "*swimming-whale*")
(defvar wal/ascii-whale-timer nil)
(defvar wal/ascii-whale-parent-buffer nil)

(defun wal/ascii-whale-animate ()
  "Animate the ASCII whale."
  (with-current-buffer (get-buffer-create wal/ascii-whale-buffer)
    (erase-buffer)
    (let* ((frame (aref wal/ascii-whale-key-frames wal/ascii-whale-frame-index))
           (colored (propertize frame 'face 'mode-line-highlight)))
      (insert colored)
      (setq wal/ascii-whale-frame-index
            (mod
             (1+ wal/ascii-whale-frame-index)
             (length wal/ascii-whale-key-frames))))))

(defun wal/ascii-whale-setup ()
  "Set up the animated whale."
  (when (featurep 'posframe)
    (setq wal/ascii-whale-parent-buffer (current-buffer))
    (add-hook 'kill-buffer-hook #'wal/ascii-whale-clean-up nil t)
    (add-hook 'window-configuration-change-hook #'wal/ascii-whale-display nil t)
    (unless wal/ascii-whale-timer
      (setq wal/ascii-whale-timer (run-with-timer
                                   0
                                   wal/ascii-whale-animation-speed
                                   #'wal/ascii-whale-animate)))
   (wal/ascii-whale-display)))

(defun wal/ascii-whale-clean-up ()
  "Clean up the animation."
  (when wal/ascii-whale-timer
    (cancel-timer wal/ascii-whale-timer)
    (setq wal/ascii-whale-timer nil))
  (posframe-delete wal/ascii-whale-buffer)
  (remove-hook 'kill-buffer-hook #'wal/ascii-whale-clean-up t)
  (remove-hook 'window-configuration-change-hook #'wal/ascii-whale-display t))

(defun wal/ascii-whale-display ()
  "Display the running animation in a posframe."
  (posframe-show
     wal/ascii-whale-buffer
     :position (point)
     :width 8
     :border-width 6
     :border-color (face-attribute 'mode-line-highlight :background nil t)
     :poshandler 'posframe-poshandler-window-top-right-corner
     :posframe-parent-buffer (or wal/ascii-whale-parent-buffer (current-buffer))
     :hidehandler 'wal/posframe-hidehandler-when-invisible))

(defun wal/ascii-whale-toggle-display ()
  "Toggle the animation."
  (interactive)
  (if wal/ascii-whale-timer
      (wal/ascii-whale-clean-up)
    (wal/ascii-whale-setup)))
#+END_SRC

** Editing the Config

Minor mode for editing this config.

#+BEGIN_SRC emacs-lisp
(defvar wal/tangle-do-prompt t
  "Whether to prompt user to tangle config.")

(defvar wal/config-mode-map (make-sparse-keymap)
  "Map for `wal/config-mode'.")

(defconst wal/readme-config (expand-file-name "README.org" wal/emacs-config-default-path)
  "The path to Walheimat's config.")

(defun wal/describe-config-version ()
  "Describe the config's version.

This returns the tag and its annotation as propertized strings."
  (interactive)
  (let* ((default-directory wal/emacs-config-default-path)
         (vers (propertize
                (string-trim
                 (shell-command-to-string "git describe --abbrev=0"))
                'face 'bold))
         (cat (propertize
               (string-trim
                (shell-command-to-string (format "git cat-file tag %s" vers)))
               'face 'italic))
         (out (concat vers ": " (car (last (string-lines cat))))))
    (cond
     (noninteractive out)
     (t (message out)))))

(defun wal/tangle-config-prompt ()
  "Prompt the user to tangle the config.
If the answer is no, there will be no additional prompt."
  (interactive)
  (let ((help-form (message "This will update your packages. Restart Emacs afterwards.")))
    (if (and wal/tangle-do-prompt (y-or-n-p "Config changed, want to tangle? "))
        (wal/tangle-config)
      (if wal/tangle-do-prompt
          (progn
            (setq-local wal/tangle-do-prompt nil)
            (message "To tangle, call `wal/tangle-config'"))
        (message "Config changed. To tangle, call `wal/tangle-config'")))))

(defun wal/find-config ()
  "Find Walheimat's config.

This will activate minor mode `wal/config-mode'."
  (interactive)
  (let ((buf (find-file-noselect wal/readme-config)))
    (switch-to-buffer buf)
    (wal/config-mode +1)))

(defun wal/find-init ()
  "Find and switch to the `user-init-file'."
  (interactive)
  (switch-to-buffer (find-file-noselect (file-truename user-init-file))))

(defun wal/customize-group ()
  "Customize `wal' group."
  (interactive)
  (customize-group 'wal t))

(defun wal/dired-packages ()
  "Open the packages with Dired."
  (interactive)
  (pop-to-buffer-same-window
    (dired-noselect wal/emacs-config-package-path)))

(defun wal/checkdoc-packages ()
  "Run `checkdoc-file' on all package files."
  (interactive)
  (let ((projectile-enable-caching nil))
    (dolist (it (wal/directory-files wal/emacs-config-package-path))
      (checkdoc-file it))))

(defun wal/config-maybe-create-transient ()
  "Create a `transient' if it doesn't exist yet and bind it."
  (unless (fboundp 'wal/config-dispatch)
    (require 'transient)
    (with-no-warnings
      (transient-define-prefix wal/config-dispatch ()
        "Facilitate the usage of or the working on Walheimat's config."
        [["Actions"
          ("t" "tangle" wal/tangle-config)
          ("x" "install expansion pack" wal/install-expansion-pack)
          ("c" "checkdoc" wal/checkdoc-packages)]
         ["Go to"
          ("h" "heading" consult-org-heading)
          ("d" "packages" wal/dired-packages)]
         ["Customization"
          ("g" "group" wal/customize-group)]
         ["Fluff"
          ("w" "toggle animation" wal/ascii-whale-toggle-display)]])
      (general-define-key
       :keymaps 'wal/config-mode-map
       "C-c 9" '(wal/config-dispatch :wk "config dispatch")))))

(define-minor-mode wal/config-mode
  "Mode for editing Walheimat's config."
  :init-value nil
  :global nil
  :lighter " wal"
  :keymap wal/config-mode-map
  (require 'transient nil t)
  (require 'checkdoc nil t)
  (require 'posframe nil t)
  (wal/config-maybe-create-transient)
  (add-hook 'after-revert-hook #'wal/tangle-config-prompt nil t)
  (when wal/config-show-whale-animation
    (wal/ascii-whale-setup)))
#+END_SRC

** Loading

This basically just a giant =require=.

#+BEGIN_SRC emacs-lisp
(when (boundp 'wal/emacs-config-package-path)
  (add-to-list 'load-path wal/emacs-config-package-path))

(dolist (it wal/sub-packages)
  (require it nil t))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal)

;;; wal.el ends here
#+END_SRC

* Footnotes

[fn:1] Jumped ship from =27.1=. Some minor things might not work there.
I currently use this config in =28.1.50= and =29.0.50=.

[fn:2] If you're feeling adventurous, [[https://git.savannah.gnu.org/cgit/emacs.git/tree/INSTALL][build from source]].

[fn:3] If you're not sure where your =user-emacs-directory= might be,
you can do the following:

+ Run Emacs
+ hit =M-x= (that is your Alt/Option key followed by the letter =x=)
+ type =describe-variable= and hit return
+ type =user-emacs-directory= and hit return again.

A window should pop up telling you the path.

Finally run =git clone git@gitlab.com:Walheimat/emacs-config.git ~/.emacs.d=
(replace =~/.emacs.d= with your actual path if it differs).

[fn:4] This includes this very config which will be exported as a
package collection.

Packages that belong to an expansion pack or its extras need to be
installed manually by calling =wal/install-expansion-pack=.

[fn:5] Which means that a frame is reused or created and control
immediately returned. If you're using Emacs 29, consider using
=emacsclient -r= to reuse an existing frame.

[fn:6] Not including where =:tangle no= was set.

/Note/ they will not necessarily be evaluated in the same order they
appear in this file. The order of evaluation is determined by the
=wal.el= file from [[*Config Package][this section]].

[fn:7] Send me an email, why don't you?

[fn:8] To get a full overview you'll have to call
=describe-personal-keybindings= and =general-describe-keybindings=.

[fn:9] If hyper can't be used (or shouldn't be used if Emacs is run in
=no-window-system=), it is replaced by =C-c w <key>= for both leader keys
and other bindings.

[fn:10] Be careful! If you make a mistake you could render your
keyboard unusable.

[fn:11] Provided the modes are active.

[fn:12] Alternate spelling is "expansion pak".

[fn:13] The following packages (and their related or sub-packages) are
found in other sections

- =org= and =org-agenda= in [[*Org Mode][Org Mode]]
- =flyspell= in [[*Fixing Things][Fixing Things]]
- =dired= in [[*Dired][Dired]]
- =eshell= in [[*Terminal][Terminal]]
- =python=, =emacs-lisp=, =cc-mode= and =css-mode= in [[*Languages][Languages]]

[fn:14] Unfortunately these themes require to the customizations to be set
before loading, which means that when using these themes you have to
load them twice.

[fn:15] The =all-the-icons= icons need to be downloaded manually by
running =M-x all-the-icons-install-fonts= and selecting =yes=.

If the installation process should fail for any reason, close Emacs
and re-run it.

[fn:16] You might have to call =emojify-download-emoji= to download a
set that supports your emojis.

[fn:17] If you're on an older distro your =libvterm= package might be
too old.

[fn:18] None of the language packages are ensured, meaning you will
need to install them yourself.

[fn:19] All languages listed [[https://emacs-lsp.github.io/lsp-mode/page/languages/][here]].
