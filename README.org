#+TITLE: Walheimat's Emacs Config
#+AUTHOR: [[https://gitlab.com/Walheimat][@Walheimat]]

[[./assets/logo.png]]

* About

** Heads-Up

This project is my personal literate Emacs[fn:1] configuration.

If you're a complete beginner, you will find [[https://github.com/emacs-tw/awesome-emacs#starter-kit][more user-friendly and
less tailor-made configs]] out there.

Feel free to consider it a jumping-off-point for your own custom
config. Just know that nothing in this config should be considered
/good practice/, it's mostly just how I (think I) like things to be.

** Try-Out

If you're interested in trying out Emacs using my config, here are the
necessary steps:

+ install Emacs if you haven't[fn:2]
+ =git clone= this repository into your =user-emacs-directory=[fn:3]
+ run =load-file= and navigate to =setup/wal-setup=, run =wal/setup=, select
  =init file= and choose =link= or =copy=
+ close and re-run Emacs which should (download and) install all[fn:4]
  packages.

If you do not wish to =clone= this repo in your =user-emacs-directory= or
use the default name, you will need to adapt the variable
=wal/emacs-config-default-path= in the example init file you just
copied.

You can then use =customize-group= to change settings for various
aspects of the config.

** Peculiarities

*** As a Daemon

This config is /daemon-ready/, i.e. if you start Emacs with the =--daemon=
flag, the config will make sure that any customization that requires a
frame will only be loaded once a frame was created.

You can install either a =systemd= service using =wal/setup= (described
above) or just execute =emacs --daemon= in a terminal or your login
shell's configuration.

In any case, an Emacs daemon will start (on start-up). To connect, you
can use, for example, =emacsclient -c -n=[fn:5].

*** Package-Like

#+BEGIN_HTML
<a href='https://coveralls.io/github/Walheimat/emacs-config?branch=trunk'>
    <img
        src='https://coveralls.io/repos/github/Walheimat/emacs-config/badge.svg?branch=trunk'
        alt='Coverage Status'
    />
</a>
#+END_HTML

Custom functions and variables use the =wal/= scope and belong to their
respective section's package. Each package/section defines a group for
customization purposes.

With a few exceptions, each package has a *Header* and a *Footer* that
contains declarations for the package, as well as either a *Packages*
section or several sections grouping packages.

Enough preambling, let's configure some Emacs. The init script will
evaluate /everything/[fn:6] that follows.

* Settings
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-settings.el" wal/emacs-config-package-path)
:END:

Set things up.

Confer also the eponymous [[*Functionality][Functionality]] sections if custom
functionality is used.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-settings.el --- Settings. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; The global settings.

;;; Code:

(eval-when-compile
  (require 'marginalia)
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wal/bytes-per-mb "wal-func.el")
(declare-function wal/create-non-existent-directory "wal-func.el")
(declare-function wal/expansion--stringify "wal-func.el")
(declare-function wal/expansion-pack--parts "wal-func.el")
(declare-function wal/insert-after "wal-func.el")
(declare-function wal/modern-emacs-p "wal-func.el")
(declare-function wal/persist-scratch "wal-key-bindings.el")
(declare-function wal/rehydrate-scratch "wal-key-bindings.el")
(declare-function wal/reset-to-standard "wal-func.el")
(declare-function wal/set-indent-defaults "wal-func.el")
(declare-function wdb/side "wal-func.el")
(declare-function wdb/pop-up "wal-func.el")

(defvar debugger-bury-or-kill)
(defvar display-time-default-load-average)
(defvar display-time-format)
(defvar native-comp-async-report-warnings-errors)
(defvar recentf-filename-handlers)
(defvar so-long-action)
(defvar use-package-defaults)
(defvar use-package-always-defer)
(defvar use-package-always-ensure)
(defvar use-package-compute-statistics)

(defgroup wal-settings nil
  "Change core settings."
  :group 'wal
  :tag "Settings")

;;;; Customization:

(defcustom wal/cache-directory (expand-file-name ".cache" user-emacs-directory)
  "The cache directory."
  :type 'string
  :group 'wal-settings)

(defcustom wal/site-lisp-directory (expand-file-name "site-lisp" user-emacs-directory)
  "Directory of site Lisp packages."
  :type 'string
  :group 'wal-settings)

(defcustom wal/org-directory (expand-file-name "org" "~")
  "Default directory for org files."
  :type 'string
  :group 'wal-settings)

(defcustom wal/agenda-tasks-directory (expand-file-name "tasks" wal/org-directory)
  "One-size-fits-all directory for agenda tasks."
  :type 'string
  :group 'wal-settings)

(defcustom wal/org-roam-directory (expand-file-name "zettelkasten" wal/org-directory)
  "Directory for Zettelkasten note-taking."
  :type 'string
  :group 'wal-settings)

(defcustom wal/indent-offset 4
  "The indent offset in spaces."
  :type 'integer
  :group 'wal-settings)

(defcustom wal/prefer-tabs nil
  "Whether tabs are preferred for indentation."
  :type 'boolean
  :group 'wal-settings)

(defcustom wal/scratch-persist-file (expand-file-name "scratch-persist" wal/cache-directory)
  "The file to persist the *scratch* buffer's content in."
  :type 'string
  :group 'wal-settings)

(defcustom wal/minimal nil
  "Whether to use a minimal configuration."
  :type 'boolean
  :group 'wal-settings)

(defcustom wal/minimal-exclude '()
  "Packages that are not part of a minimal configuration but should be installed."
  :type '(repeat symbol)
  :group 'wal-settings)

(defcustom wal/maximize-new-frames t
  "Whether to maximize new frames by default."
  :type 'boolean
  :group 'wal-settings)

(defcustom wal/ack-warnings nil
  "Acknowledge all warnings."
  :type 'boolean
  :group 'wal-settings)

(defcustom wal/idle-delay 1.6
  "The delay after which helpful information should be shown."
  :type 'float
  :group 'wal-settings)
#+END_SRC

** Personal

Set some personal info[fn:7].

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Krister Schuchardt"
      user-mail-address "krister.schuchardt@gmail.com")
#+END_SRC

** Start-Up

Customize start-up.

#+BEGIN_SRC emacs-lisp
;; Load custom file. Create it if it doesn't yet exist.

(setq-unless custom-file (expand-file-name "custom.el" user-emacs-directory))

(unless (file-exists-p custom-file)
  (write-region "" nil custom-file))
(load custom-file)

;; Maximize frame.
(setq frame-resize-pixelwise t)
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
(when wal/maximize-new-frames
  (add-to-list 'default-frame-alist '(fullscreen . maximized)))

;; No splash.
(setq inhibit-startup-message t)
(setq initial-major-mode 'fundamental-mode) ; Avoids loading `prog-mode' derivatives.

;; Accept redefinitions.
(setq ad-redefinition-action 'accept)

;; Warn Mac/Windows users.
(unless (or (eq system-type 'gnu/linux) wal/ack-warnings)
  (warn "\
     Warning: Config only tested on Linux. The configuration may
     not work correctly on your system.

     Set `wal/ack-warnings' to t to ignore this warning."))
#+END_SRC

** Command Line

#+BEGIN_SRC emacs-lisp
(wal/capture-flag doctor
  "Will set up `use-package' to collect statistics.")

(wal/capture-flag mini
  "Will packages that are part of the minimal configuration.")

(wal/capture-flag ensure
  "Will set up `use-package' to ensure packages.")
#+END_SRC

** Packages

Add MELPA to the package archives. Most (if not all) packages will be
installed from there.

#+BEGIN_SRC emacs-lisp
;; Always defer, maybe ensure.
(setq use-package-always-defer t)

(when wal/flag-ensure
  (setq use-package-always-ensure t))

(when wal/flag-doctor
  (setq use-package-compute-statistics t)
  (when (fboundp 'use-package-report)
    (add-hook 'after-init-hook #'use-package-report)))

(wal/insert-after 'use-package-keywords :bind-keymap* :wal-bind)
(wal/insert-after 'use-package-keywords :wal-bind :wal-bind-keymap)

(wal/insert-after 'use-package-keywords :pin :wal-ways)
(add-to-list 'use-package-defaults '(:wal-ways t t))
#+END_SRC

** Directories

Make sure that custom directories exist. We want:

+ A cache directory to store bookmarks etc.
+ a directory for site lisp
+ a default directory for org files
+ a default directory for agenda tasks
+ a default directory for notes.

Also create non-existing directories while finding files.

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook (lambda ()
                                (mapc (lambda (it) (make-directory it t))
                                      `(,wal/cache-directory
                                        ,wal/site-lisp-directory
                                        ,wal/org-directory
                                        ,wal/agenda-tasks-directory
                                        ,wal/org-roam-directory))))

(add-to-list 'find-file-not-found-functions #'wal/create-non-existent-directory)
#+END_SRC

** Site-Lisp

Add all sub-directories of the site lisp directory to load path (and
custom theme load path). I put non-MELPA packages here.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path wal/site-lisp-directory)

(dolist (project (directory-files wal/site-lisp-directory t "\\w+"))
  (when (file-directory-p project)
    (add-to-list 'load-path project)
    (add-to-list 'custom-theme-load-path project)))
#+END_SRC

** Saving and Backups

Don't clutter up workspaces.

#+BEGIN_SRC emacs-lisp
;; Store backups in backups folder and back up by copying.
(setq backup-directory-alist
      `(("." . ,(expand-file-name (concat user-emacs-directory "backups"))))
      backup-by-copying t)

;; Store autosaves in temp folder.
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))

;; We don't want this to mess with git.
(setq create-lockfiles nil)
#+END_SRC

** Reasonable Values

Make things shorter and snappier. These settings don't belong to
packages.

#+BEGIN_SRC emacs-lisp
(setq read-process-output-max (wal/bytes-per-mb 1)
      echo-keystrokes 0.1

      ;; Undo limits.
      undo-limit (wal/bytes-per-mb 1)
      undo-strong-limit (wal/bytes-per-mb 1.5)
      undo-outer-limit (wal/bytes-per-mb 150)

      ;; Mouse.
      mouse-yank-at-point t

      ;; Native compilation.
      package-native-compile t
      native-comp-async-report-warnings-errors 'silent

      ;; Time.
      display-time-format " %H:%M"
      display-time-default-load-average nil
      save-interprogram-paste-before-kill t

      ;; Mark ring (halve it).
      mark-ring-max 8
      global-mark-ring-max 8

      ;; Search.
      isearch-lazy-count t

      ;; Parentheses.
      show-paren-delay 0.1
      show-paren-context-when-offscreen t ; New in Emacs 29.

      ;; Editing.
      backward-delete-char-untabify-method 'hungry

      ;; Recent files.
      ;; Otherwise source `consult--source-project-recent-file' won't work.
      recentf-filename-handlers nil
      recentf-max-saved-items 100)
#+END_SRC

** Global Modes

Any mode that should be on/off no matter what.

#+BEGIN_SRC emacs-lisp
;; A bunch of useful modes.
(show-paren-mode 1)
(global-auto-revert-mode 1)
(save-place-mode 1)
(delete-selection-mode 1)
(column-number-mode 1)
(global-so-long-mode 1)
(savehist-mode 1)
(recentf-mode 1)
(repeat-mode 1)

;; No need for bars.
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)

;; Emacs 29.
(when (wal/modern-emacs-p 29)
  (pixel-scroll-precision-mode 1))
#+END_SRC

** Editing

Advise to maybe add hook to delete trailing whitespace.

#+BEGIN_SRC emacs-lisp
(defvar-local wal/delete-trailing-whitespace t
  "Whether to delete trailing whitespace.")

(defun wal/then-add-delete-trailing-whitespace-hook (&rest _args)
  "Advise to conditionally add before save hook.

When `wal/delete-trailing-whitespace' is t, trailing whitespace
is deleted."
  (when wal/delete-trailing-whitespace
    (add-hook 'before-save-hook #'delete-trailing-whitespace nil t)))

(advice-add
 'hack-local-variables :after
 #'wal/then-add-delete-trailing-whitespace-hook)
#+END_SRC

** Garbage Collection

Increase the =gc-cons-threshold= after start-up.

#+BEGIN_SRC emacs-lisp
(defun wal/increase-gc-cons-threshold ()
  "Increase `gc-cons-threshold' to maximum on minibuffer setup."
  (setq gc-cons-threshold (wal/bytes-per-mb 100)))

(add-hook 'emacs-startup-hook #'wal/increase-gc-cons-threshold)
#+END_SRC

** Indentation

Set up an easy way to switch between tabs and spaces for indentation[fn:8].

#+BEGIN_SRC emacs-lisp
(defvar wal/indent-vars '(python-indent-offset
                          js-indent-level
                          css-indent-offset
                          nxml-child-indent
                          tab-width
                          js-encoding-default-indentation
                          electric-indent-inhibit
                          indent-tabs-mode))

(defun wal/reset-indent-defaults ()
  "Reset indent defaults.
Resets all variables that were initially set by
`wal/set-indent-defaults'."
  (interactive)

  (mapc #'wal/reset-to-standard wal/indent-vars))

(add-hook 'emacs-startup-hook #'wal/set-indent-defaults)
#+END_SRC

** Scratch Buffer

Let's keep the scratch contents.

#+BEGIN_SRC emacs-lisp
;; Empty scratch message.
(setq initial-scratch-message "")

(setq wal/scratch-persist wal/scratch-persist-file)

(add-hook 'emacs-startup-hook #'wal/rehydrate-scratch)
(add-hook 'kill-emacs-hook #'wal/persist-scratch)
#+END_SRC

** Minimize Annoyances

Make never leaving Emacs a priority.

#+BEGIN_SRC emacs-lisp
(setq use-dialog-box nil
      disabled-command-function nil
      debugger-bury-or-kill 'kill
      use-short-answers t ; New in Emacs 28. Otherwise you need an alias.
      so-long-action 'so-long-minor-mode)
#+END_SRC

** Expansion Packs

Make completions look nice.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'marginalia
  (defun wal/annotate-expansion-pack (candidate)
    "Annotate CANDIDATE expansion pack."
    (let* ((item (assoc (intern candidate) wal/expansion-packs))
           (parts (wal/expansion-pack--parts item)))

      (cl-destructuring-bind (packages extras recipes docs) parts

        (marginalia--fields
         (docs :face 'marginalia-documentation :truncate 0.6)
         ((wal/expansion--stringify (append packages recipes)) :face 'marginalia-value :truncate 0.8)
         ((wal/expansion--stringify extras) :face 'marginalia-value :truncate 0.4)))))

  (add-to-list 'marginalia-annotator-registry '(expansion-pack wal/annotate-expansion-pack builtin none))
  (add-to-list 'marginalia-command-categories '(wal/install-expansion-pack . expansion-pack)))
#+END_SRC

** Buffer Display

#+BEGIN_SRC emacs-lisp
(wdb/pop-up "^\\*wal-async\\*")
(wdb/pop-up "^\\*Messages\\*")
#+END_SRC

** Key Bindings

#+BEGIN_SRC emacs-lisp
;; Create `transient' for config package.
(with-no-warnings
  (transient-define-prefix wal/config-dispatch ()
    "Facilitate the usage of or the working on Walheimat's config."
    [["Do"
      ("f" "config" wal/find-config)
      ("t" "tangle" wal/tangle-config)
      ("x" "install expansion pack" wal/install-expansion-pack)
      ("g" "customize group" wal/customize-group)
      ("d" "show diff" wal/show-config-diff-range)]
     ["Check"
      ("c d" "checkdoc" wal/checkdoc-config-packages)
      ("c f" "flycheck" wal/flycheck-config-packages)
      ("c o" "coverage" wal/check-coverage)
      ("c j" "JSON coverage" wal/create-json-coverage)]
     ["Fluff"
      ("w" "toggle animation" wal/ascii-whale-toggle-display)]])

  ;; Move similar to `xah-fly-keys'.
  (defhydra wal/fly (:hint nil :foreign-keys warn)
    "
%s`w/hew Fly: âœœ _i_ _j_ _k_ _l_ %s`w/hs â‡† _u_ _o_ %s`w/hs â‡„ _h_ _;_ %s`w/hs â‡… _,_ _._
"
    ("u" backward-word)
    ("i" previous-line)
    ("o" forward-word)
    ("j" backward-char)
    ("l" forward-char)
    ("k" next-line)

    ("h" beginning-of-line)
    (";" end-of-line)

    ("," scroll-up-command)
    ("." scroll-down-command)

    ("q" nil))

  ;; Additional `general' bindings.
  (wal/general
    "w" 'eww

    "f" '(:ignore t :wk "find")
    "fc" '(wal/find-custom-file :wk "custom")
    "fi" '(wal/find-init :wk "init")
    "fl" '(find-library :wk "library")

    "l" '(:ignore t :wk "list")
    "lp" '(list-processes :wk "processes")
    "lt" '(list-timers :wk "timers")

    "s" '(:ignore t :wk "set")
    "sT" '(wal/set-transparency :wk "transparency")
    "sc" '(wal/set-cursor-type :wk "cursor")

    "p" '(:ignore t :wk "package")
    "pf" '(package-refresh-contents :wk "refresh")
    "pi" '(package-install :wk "install")
    "pl" '(list-packages :wk "list")
    "pr" '(package-reinstall :wk "re-install")
    "pd" '(package-delete :wk "delete"))

  (global-set-key (kbd (wal/key-combo-for-leader 'wal/colonel)) #'wal/config-dispatch)

  (wal/general "n" '(display-line-numbers-mode :wk "line numbers"))

  (global-set-key (kbd (wal/key-combo-for-leader 'wal/captain)) #'wal/captain?)

  (wal/lieutenant "v" '(wal/fly/body :wk "fly"))
  (wal/lieutenant "<SPC>" '(wal/push-mark :wk "push mark"))
  (wal/lieutenant "s" '(wal/scratch-buffer :wk "scratch buffer"))

  (defvar wal/misc-map (make-sparse-keymap))
  (wal/lieutenant "," '(:keymap wal/misc-map :wk "misc"))

  (when (wal/modern-emacs-p 29)
    (wal/lieutenant "d" 'duplicate-dwim)
    (wal/lieutenant "f" 'find-sibling-file))

  (general-define-key
   :keymaps 'wal/misc-map
   :wk-full-keys nil
   "f" '(wal/find-fish-config :wk "find fish")
   "b" '(wal/kill-some-file-buffers :wk "kill file buffers")
   "d" '(wal/l :wk "dedicate window"))

  (global-set-key (kbd "C-x o") #'wal/other-window)
  (global-set-key (kbd "C-M-i") #'completion-at-point)

  ;; Replaces `kill-sexp'.
  (global-set-key (kbd "C-k") #'wal/kwim)

  ;; Replaces `save-buffers-kill-terminal'.
  (global-set-key (kbd "C-x C-c") #'wal/delete-edit-or-kill))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-settings)

;;; wal-settings.el ends here
#+END_SRC

* Key Bindings
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-key-bindings.el" wal/emacs-config-package-path)
:END:

I use many[fn:9] custom keybindings. You can find an overview [[file:docs/bindings.org][here]].

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-key-bindings.el --- Key bindings. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Key bindings package.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(defvar transient-current-command)

(declare-function wal/prefix-user-key "wal-func.el")
(declare-function transient-args "ext:transient.el")
(declare-function transient-arg-value "ext:transient.el")

(defgroup wal-key-bindings nil
  "Change key bindings settings."
  :group 'wal
  :tag "Key bindings")

;;;; Customization:

(defcustom wal/use-hyper-prefix t
  "Whether the hyper modifier should be used to prefix user keys."
  :type 'boolean
  :group 'wal-key-bindings)

(defcustom wal/key-reach '(";" "." "/" "'" ",")
  "List of keys ordered by reachability."
  :type '(list string string string string string)
  :group 'wal-key-bindings)

(defcustom wal/dwim-key "M-."
  "Key sequence used to do what I mean."
  :type 'key-sequence
  :group 'wal-key-bindings)
#+END_SRC

** Packages

*** general
:PROPERTIES:
:UNNUMBERED: t
:END:

Allows defining custom prefixes.

**** Utility

#+BEGIN_SRC emacs-lisp
(defvar wal/leaders '(wal/lieutenant wal/captain wal/major wal/colonel wal/general))
(defvar wal/general-leaders '(wal/lieutenant wal/major wal/general))

(cl-defmacro wal/create-leader-sink (name &key definer prefix)
  "Macro to create a leader sink `NAME-sink'.

NAME is the name of the macro. DEFINER is the definer to create
the sink for and PREFIX is its prefix."
  (declare (indent defun))

  (let* ((defname (symbol-name definer))
         (suffix (substring prefix -1))
         (wk (upcase (concat (substring defname 4) "!"))))

    (progn
      (general-define-key :prefix prefix suffix `(:ignore t :wk ,wk))

      `(defmacro ,name (&rest args)
         `(, ',definer ,@,`(mapcar (lambda (it)
                                     (if (stringp it)
                                         (concat ,suffix it)
                                       it))
                                   args))))))

(cl-defmacro wal/lieutenant! (key fun mfun &rest args)
  "Bind FUN to KEY, MFUN in the sink.

All ARGS are passed to both definers."
  (declare (indent defun))

  `(progn
    (wal/lieutenant ,@args ,key ,fun)
    (wal/lieutenant-sink ,@args ,key ,mfun)))

(defun wal/key-by-leader (leader)
  "Get the key for LEADER."
  (nth (seq-position wal/leaders leader) wal/key-reach))

(defun wal/key-combo-for-leader (leader &optional key in-sink)
  "Get the key combination for LEADER.

 If KEY is non-nil, append it. If IN-SINK is non-nil, infix leader key."
  (let* ((leader-key (wal/key-by-leader leader))
         (prefixed (wal/prefix-user-key leader-key)))

    (if key
        (if in-sink
            (concat prefixed " " leader-key " " key)
          (concat prefixed " " key))
      prefixed)))

(defun wal/general-create-definer (leader)
  "Create a definer for LEADER with a sink."
  (let* ((key (wal/key-combo-for-leader leader))
         (sink (intern (format "%s-sink" leader)))
         (name (substring (symbol-name leader) 4)))

    ;; Queue up `which-key' replacements.
    (eval-after-load 'which-key `(which-key-add-key-based-replacements ,key ,name))

    ;; Create the normal definer.
    (eval `(general-create-definer ,leader :prefix ,key))

    ;; Also create the sink.
    (eval `(wal/create-leader-sink ,sink :definer ,leader :prefix ,key))))

(defun wal/captain? ()
  "Show message when captain is not locally bound."
  (interactive)

  (let ((key (propertize (wal/key-combo-for-leader 'wal/captain) 'face 'success))
        (mode (propertize (symbol-name major-mode) 'face 'success)))

    (message "Captain (%s) has no binding in %s" key mode)))
#+END_SRC

*** Configuration

#+BEGIN_SRC emacs-lisp
(use-package general
  :demand t

  :config
  (seq-do #'wal/general-create-definer wal/general-leaders))
#+END_SRC

*** hydra
:PROPERTIES:
:UNNUMBERED: t
:END:

Provides a context for related commands that can be (re-)executed in
quick succession.

**** Utility

#+BEGIN_SRC emacs-lisp
(defvaralias 'w/hs 'wal/hydra-separator)
(defvar wal/hydra-separator (propertize " â‹° " 'face 'shadow))

(defvaralias 'w/hew 'wal/hydra-emoji-whale)
(defvar wal/hydra-emoji-whale "ðŸ‹")
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package hydra)
#+END_SRC

*** transient
:PROPERTIES:
:UNNUMBERED: t
:END:

Another nice way of grouping keys.

Some transients are bound directly, others are =wal/univ= variants (see
above).

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/transient-grab (arg)
  "Grab argument ARG from current command."
  (transient-arg-value
   (format "--%s=" arg)
   (transient-args transient-current-command)))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package transient
  :custom
  (transient-hide-during-minibuffer-read t)

  :config
  (bind-key wal/dwim-key 'transient-show 'transient-map)

  (with-eval-after-load 'wal-settings
    (defvar wal/idle-delay)
    (setq transient-show-popup wal/idle-delay)))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-key-bindings)

;;; wal-key-bindings.el ends here
#+END_SRC

* Functionality
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-func.el" wal/emacs-config-package-path)
:END:

Custom functionality.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-func.el --- Utilities. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provides functions and macros to simplify various configurations.

;;; Code:

(require 'compile)

(declare-function server-edit "ext:server.el")
(declare-function server-edit-abort "ext:server.el")

(defvar global-text-scale-adjust--default-height)
(defvar wal/indent-offset)
(defvar wal/prefer-tabs)
(defvar wal/scratch-persist-file)
(defvar wal/use-hyper-prefix)
#+END_SRC

** Emacs

#+BEGIN_SRC emacs-lisp
(defun wal/modern-emacs-p (&optional min-version)
  "Check if we're using a modern version of Emacs.

If MIN-VERSION is set to a number, verify that current version is
at or above it."
  (if min-version
      (if (and (numberp min-version) (>= min-version 28))
          (>= emacs-major-version min-version)
        (user-error "Provided minimum version not acceptable"))
    (>= emacs-major-version 28)))
#+END_SRC

** Directories

Finding files should =mkdir -p= its parents.

#+BEGIN_SRC emacs-lisp
;; Creating parent dirs.
(defun wal/create-non-existent-directory ()
  "Ask whether to create non-existent directory.
If a file is found in a not (yet) existing directory, ask if it
should get created."
  (let ((parent-directory (file-name-directory buffer-file-name)))

    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Create non-existing directory `%s'? " parent-directory)))
      (make-directory parent-directory t))))
#+END_SRC

** Buffer Display

Utility functions to configure displaying buffers of a certain type.

#+BEGIN_SRC emacs-lisp
(defun wal/display-buffer-condition (buffer-or-mode)
  "Get a display buffer condition for BUFFER-OR-MODE."
  (pcase buffer-or-mode
    ((pred stringp) buffer-or-mode)
    ((pred symbolp) `(major-mode . ,buffer-or-mode))
    (_ (user-error "Call with string or symbol"))))

(defun wal/display-buffer-in-pop-up (buffer &optional in-frame)
  "Display BUFFER in a pop-up.
The pop-up is a window unless IN-FRAME is t."
  (let ((condition (wal/display-buffer-condition buffer))
        (action (if in-frame
                     'display-buffer-pop-up-frame
                   'display-buffer-pop-up-window)))

    (add-to-list 'display-buffer-alist `(,condition (,action)))))

;; The next two functions make sense for `popper' buffers.

(cl-defun wal/display-buffer-in-side-window (buffer &key side loose no-other height)
  "Display BUFFER in SIDE window.

This window will be on SIDE (on the bottom by default), not
delete other windows, dedicated to the buffer (unless LOOSE),
available to `other-window' (unless NO-OTHER) 20 (or HEIGHT)
lines high and visible frames are considered reusable."
  (let ((condition (wal/display-buffer-condition buffer)))

    (add-to-list 'display-buffer-alist
                 `(,condition
                   (display-buffer-reuse-window display-buffer-in-side-window)
                   (side . ,(or side 'bottom))
                   (dedicated . ,(not loose))
                   (reusable-frames . visible)
                   (window-height . ,(or height 10))
                   (window-parameters . ((no-other-window . ,no-other)))))))

(defun wal/display-buffer-in-direction (buffer &optional direction)
  "Display BUFFER in direction.
The direction is right-most or DIRECTION."
  (let ((condition (wal/display-buffer-condition buffer)))

    (add-to-list 'display-buffer-alist
                 `(,condition
                   (display-buffer-reuse-mode-window display-buffer-in-direction)
                   (direction . ,(or direction 'rightmost))))))

(defun wal/display-buffer-ethereally (buffer)
  "Display BUFFER ethereally.

This means there is no display function used and the mode line is
removed."
  (let ((condition (wal/display-buffer-condition buffer)))

    (add-to-list 'display-buffer-alist
                 `(,condition
                   nil
                   (window-parameters (mode-line-format . none))))))

(defun wal/display-buffer-reuse-same-window (buffer)
  "Display BUFFER reusing same window."
  (let ((condition (wal/display-buffer-condition buffer)))

    (add-to-list 'display-buffer-alist
                 `(,condition
                   (display-buffer-reuse-window display-buffer-same-window)))))

;; Prefer short-hands.
(defalias 'wdb/pop-up 'wal/display-buffer-in-pop-up)
(defalias 'wdb/side 'wal/display-buffer-in-side-window)
(defalias 'wdb/direction 'wal/display-buffer-in-direction)
(defalias 'wdb/ghost 'wal/display-buffer-ethereally)
(defalias 'wdb/same 'wal/display-buffer-reuse-same-window)
#+END_SRC

** Buffer Hygiene

#+BEGIN_SRC emacs-lisp
(defun wal/kill-some-file-buffers ()
  "Kill some buffers associated with files."
  (interactive)

  (let ((file-buffers (seq-filter #'buffer-file-name (buffer-list))))

    (kill-some-buffers file-buffers)))
#+END_SRC

** Editing

More convenient editing.

#+BEGIN_SRC emacs-lisp
(defun wal/kill-ring-save-whole-buffer ()
  "Call `kill-ring-save' on the entire buffer."
  (interactive)

  (kill-ring-save (point-min) (point-max)))

(defconst wal/cursor-types '(box hollow bar hbar)
  "Cursor types that can be set using `completing-read'.")

(defun wal/set-cursor-type (&optional reset)
  "Set the `cursor-type'.

Optionally RESET the type when called with `universal-argument'."
  (interactive "P")

  (if reset
      (setq-local cursor-type t)
    (let* ((type-string (completing-read "Select cursor type: " wal/cursor-types))
           (type (intern type-string)))

      (setq-local cursor-type type))))

(defun wal/kwim ()
  "Kill what I mean.

If there's an active region, kill it.

If we're at the (actual) end or (actual) beginning of a line,
kill the whole line, otherwise kill forward.

If a whole line is killed, move to the beginning of text on the
next line."
  (interactive)

  (if (region-active-p)
      (kill-region nil nil t)
    (let ((p-before (point))
          (p-end nil)
          (p-beg nil))

      (save-excursion
        (end-of-line)
        (setq p-end (point))

        (beginning-of-line)
        (setq p-beg (point)))

      (if (and (/= p-before p-beg) (/= p-before p-end))
          (kill-line)
        (kill-whole-line)
        (beginning-of-line-text)))))
#+END_SRC

** Windows

I keep messing up, splitting vertically when I meant horizontally.
This is inspired by [[https://github.com/purcell/emacs.d/blob/master][purcell's config]].

#+BEGIN_SRC emacs-lisp
(defun wal/split-window-the-other-way ()
  "Split window the other way.
This means if horizontally split, split vertically; if vertically
split, split horizontally."
  (interactive)

  (let* ((other-buffer (and (next-window) (window-buffer (next-window))))
         (win (selected-window))
         (split-direction (cond ((or (windows-sharing-edge win 'above)
                                     (windows-sharing-edge win 'below))
                                 'vert)
                                ((or (windows-sharing-edge win 'right)
                                     (windows-sharing-edge win 'left))
                                 'hori)
                                (t nil))))

    (delete-other-windows)

    (pcase split-direction
      ('vert (split-window-horizontally))
      ('hori (split-window-vertically))
      (_ nil))

    (when other-buffer
      (set-window-buffer (next-window) other-buffer))))

(defun wal/other-window (&optional prefer-frame)
  "Switch to other window.

If the minibuffer is active, switch to that. If there's another
frame, switch to that if PREFER-FRAME is true. Otherwise switch
to next buffer."
  (interactive "P")

  (cond
   ((active-minibuffer-window)
    (switch-to-minibuffer))
   ((and (not (equal (next-frame) (selected-frame)))
         (or prefer-frame (one-window-p)))
    (other-frame 1))
   ((one-window-p)
    (switch-to-buffer nil))
   (t
    (other-window 1))))

(defun wal/l (&optional reverse)
  "Dedicate the window to the current buffer.

Un-dedicates if REVERSE is t."
  (interactive "P")

  (let ((window (selected-window))
        (buffer (current-buffer)))

    (if reverse
        (progn
         (set-window-dedicated-p window nil)
         (message "Window no longer dedicated to %s" buffer))
    (set-window-dedicated-p window buffer)
    (message "Dedicating window to %s" buffer))))
#+END_SRC

** Files

Handling of files.

#+BEGIN_SRC emacs-lisp
(defun wal/find-custom-file ()
  "Find the custom file."
  (interactive)

  (switch-to-buffer (find-file-noselect (file-truename custom-file))))

(defun wal/find-init ()
  "Find and switch to the `user-init-file'."
  (interactive)

  (switch-to-buffer (find-file-noselect (file-truename user-init-file))))

(defconst wal/fish-config-locations '("~/.config/fish/config.fish"
                                      "~/.config/omf"))

(defun wal/find-fish-config ()
  "Find the fish shell config file."
  (interactive)

  (let* ((files wal/fish-config-locations)
         (init-file (cl-find-if
                     'file-exists-p
                     (mapcar 'expand-file-name files))))

    (if init-file
        (switch-to-buffer (find-file-noselect (file-truename init-file)))
      (user-error "Couldn't find fish config file"))))
#+END_SRC

** Command Line

Capture custom command line flags.

#+BEGIN_SRC emacs-lisp
(defvar wal/flag-doctor nil)
(defvar wal/flag-mini nil)
(defvar wal/flag-ensure nil)

(defconst wal/custom-flags '((doctor . "--doctor")
                             (mini . "--mini")
                             (ensure . "--ensure"))
  "Alist of custom flags that can be passed to Emacs.")

(defmacro wal/capture-flag (flag docs)
  "Check for custom FLAG.

DOCS will be passed on to `message'.

This will delete the flag from the command line arguments and set
the associated variable."
  (declare (indent defun) (doc-string 2))

  `(when-let* ((flags wal/custom-flags)
               (dash-flag (cdr (assoc ',flag flags)))
               (found (member dash-flag command-line-args)))

     (message ,docs)

     (setq command-line-args (delete dash-flag command-line-args))
     (setq ,(intern (concat "wal/flag-" (symbol-name flag))) t)))
#+END_SRC

** Lists

Manipulating lists.

#+BEGIN_SRC emacs-lisp
(defun wal/append (target seq)
  "Set TARGET to it with SEQ appended.

Duplicate items are removed."
  (let ((val (symbol-value target)))

    (set target (delq nil (delete-dups (append val seq))))))

(defun wal/replace-in-alist (target values)
  "Edit TARGET alist in-place using VALUES."
  (let ((val (symbol-value target)))

    (if (seq-every-p (lambda (it) (assoc (car it) val)) values)
        (seq-each (lambda (it) (map-put! val (car it) (cdr it))) values)
      (let ((keys (mapcar #'car values)))

        (user-error "All keys %s must already be present in %s" keys target)))))

(defun wal/insert-after (target preceding item &optional no-duplicates)
  "Insert ITEM in TARGET after PRECEDING.

If NO-DUPLICATES is t, trying to re-add an existing item will
raise an error."
  (let ((val (symbol-value target)))

    (when (and no-duplicates (memq item val))
      (user-error "Can't insert after %s: %s is already in target %s" preceding item target))

    (if (memq preceding val)
        (let* ((remainder (nthcdr (cl-position preceding val) val)))

          (setcdr remainder (cons item (cdr remainder))))
      (user-error "Can't insert after %s as it is not in %s" preceding target))))

(defun wal/list-from (target item)
  "Create a list from TARGET appending ITEM.

If TARGET already is a list ITEM is appended. Duplicates are
removed."
  (let ((val (symbol-value target)))

    (cond
     ((listp val)
      (delq nil (delete-dups (append val `(,item)))))
     (t
      (list val item)))))
#+END_SRC

** Commands

Make function calls even more versatile.

#+BEGIN_SRC emacs-lisp
(cl-defmacro wal/univ (a b)
  "Define a prefix-modified function for A.

It will call B instead if the default `universal-argument' is
present. It will again call A with `universal-argument' if the
function is called with two `C-u' or more.

Both functions will be called interactively."
  (declare (indent defun))

  (let ((a-name (symbol-name a))
        (b-name (symbol-name b)))

    `(defun ,(intern (concat "wal/univ-" a-name)) (&optional call-other)
       ,(concat (format "Call `%s' or `%s' depending on prefix argument."
                        a-name
                        b-name)
                "\n"
                "No argument means: call the prior. "
                "A single `C-u' means: call the latter. "
                "Two or more `C-u' means: call the prior with `universal-argument'.")
       (interactive "P")
       (if (> (prefix-numeric-value call-other) 4)
           (call-interactively ',a)
         (setq current-prefix-arg nil)
         (prefix-command-update)

         (if call-other
             (call-interactively ',b)
           (call-interactively ',a))))))
#+END_SRC

** Scratch Buffer

Make the scratch buffer contents persist between sessions.

#+BEGIN_SRC emacs-lisp
(defun wal/scratch-buffer (&optional session)
  "Switch to the scratch buffer.

If SESSION is non-nil, switch to (or create) it."
  (interactive "P")

  (let* ((name "*scratch*")
         (buf (cond ((numberp session)
                     (get-buffer-create (format "%s<%d>" name session)))
                    (session
                     (generate-new-buffer name))
                    (t
                     (get-buffer-create name)))))

    (pop-to-buffer buf '(display-buffer-same-window))))

(defvar wal/scratch-persist nil)

(defun wal/persist-scratch ()
  "Persist contents of *scratch* buffer.

The contents are stored in `wal/scratch-persist' if non-nil."
  (when wal/scratch-persist
   (with-current-buffer (get-buffer-create "*scratch*")
     (write-region (point-min) (point-max) wal/scratch-persist))))

(defun wal/rehydrate-scratch ()
  "Re-hydrate scratch buffer (if persisted).

This overrides the scratch buffer with the content stored in
`wal/scratch-persist' if non-nil."
  (when (file-exists-p wal/scratch-persist)
    (with-current-buffer (get-buffer "*scratch*")
      (delete-region (point-min) (point-max))
      (insert-file-contents wal/scratch-persist))))
#+END_SRC

** Indentation

Toggle indentation, allow for automatic activation from local
variables.

#+BEGIN_SRC emacs-lisp
(defun wal/disable-tabs ()
  "Disable tabs.

Sets variable `indent-tabs-mode' to nil."
  (interactive "p")

  (setq indent-tabs-mode nil))

(defun wal/enable-tabs ()
  "Enable tabs.

Sets tab variable `indent-tabs-mode' to t."
  (interactive)

  (setq indent-tabs-mode t))

(cl-defun wal/maybe-enable-tabs (&key indent-with)
  "Maybe enable tabs.

Optionally set `indent-line-function' to INDENT-WITH."
  (when indent-with
    (setq-local indent-line-function indent-with))

  (if wal/prefer-tabs
      (wal/enable-tabs)
    (wal/disable-tabs)))

(defun wal/set-indent-defaults (&optional num)
  "Set indent defaults.
All offsets are set to `wal/indent-offset' or optionally to NUM."
  (interactive "nSet tab width to: ")

  (let ((offset (or num wal/indent-offset)))

    (setq-default python-indent-offset offset
                  js-indent-level offset
                  css-indent-offset offset
                  nxml-child-indent offset
                  tab-width offset
                  json-encoding-default-indentation (make-string offset ? )
                  electric-indent-inhibit t
                  indent-tabs-mode wal/prefer-tabs)))
#+END_SRC

** Helpers

Some more helper functions.

#+BEGIN_SRC emacs-lisp
(defun wal/biased-random (limit &optional bias-low throws)
  "Return a biased random number using LIMIT.

The bias is the high end unless BIAS-LOW is passed. The number of
throws are 3 or THROWS."
  (let ((results (list))
        (throws (or throws 3)))

    (dotimes (_i throws)
      (push (random limit) results))

    (if bias-low
        (seq-min results)
      (seq-max results))))

(defun wal/bytes-per-mb (num)
  "Return the integer value of NUM megabytes in bytes.

This function may be used to set variables that expect bytes."
  (floor (* 1024 1024 num)))

(defun wal/maybe-intern (symbol?)
  "Maybe `intern' SYMBOL? if it's not a symbol."
  (if (symbolp symbol?)
      symbol?
    (intern symbol?)))

(defun wal/truncate (text &optional max-len)
  "Truncate TEXT if longer than MAX-LEN.

Truncates to 8 characters if no MAX-LEN is provided."
  (let ((len (or max-len 8)))

    (if (> (length text) len)
        (concat (substring text 0 (max (- len 3) 1)) "...")
      text)))

(defun wal/pad-string (string &optional right)
  "Advise to pad STRING.

Padding is on the left unless RIGHT is t."
  (let ((trimmed (string-trim string))
        (padding " "))

    (if right
        (concat trimmed padding)
      (concat padding trimmed))))

(defun wal/univ-p ()
  "Check if the `current-prefix-arg' is the `universal-argument'.

This is mainly useful for non-interactive functions."
  (equal current-prefix-arg '(4)))

(defun wal/reset-to-standard (sym &optional locally)
  "Reset symbol SYM to its standard value.
If LOCALLY is t, the local variable is killed while its global
value is left untouched."
  (if locally
      (if (local-variable-p sym)
          (kill-local-variable sym)
        (user-error "'%s' has no local binding" sym))
    (set-default sym (eval (car (get sym 'standard-value))))))

(defmacro wal/try (package &rest body)
  "Exceute BODY if PACKAGE can be required."
  (declare (indent 1))

  `(when (require ',package nil :no-error) ,@body))

(defun wal/server-edit-p ()
  "Check if we're (likely) editing from outside of Emacs.

We also make sure we're not in `with-editor-mode' as to not to
intefere with `magit' and friends."
  (and (bound-and-true-p server-buffer-clients)
       (not (bound-and-true-p with-editor-mode))))

(defun wal/delete-edit-or-kill (&optional abort)
  "Delete frame, be done (or ABORT) or kill Emacs."
  (interactive "P")

  (cond
   ((wal/server-edit-p)
    (if abort (server-edit-abort) (server-edit)))
   ((daemonp)
    (delete-frame))
   (t
    (save-buffers-kill-terminal))))

(defun wal/dead-shell-p ()
  "Check if the current buffer is a shell or comint buffer with no process."
  (let ((buffer (current-buffer)))

    (with-current-buffer buffer
      (and (derived-mode-p 'comint-mode)
           (not (comint-check-proc buffer))))))

(defun wal/prefix-user-key (user-key)
  "Prefix USER-KEY.

The default prefix is the hyper key unless Emacs is not running
in GUI mode or `wal/use-hyper-prefix' is nil."
  (let ((prefix (if (and wal/use-hyper-prefix
                         (or (daemonp) (display-graphic-p)))
                    "H-"
                  "C-c w ")))

    (concat prefix user-key)))

(defmacro wal/on-boot (name &rest body)
  "Only expand BODY in NAME on boot."
  (declare (indent defun))

  (if (bound-and-true-p wal/booting)
      `(progn ,@body)
    `(message "Ignoring statements in '%s'" ',name)))

(defvar wal/transient-may-redefine nil)

(defmacro wal/transient-define-prefix-once (name arglist &rest args)
  "Make sure that prefix NAME called with ARGLIST and ARGS is only defined once."
  (declare (debug (&define name lambda-list
                           [&optional lambda-doc]
                           [&rest keywordp sexp]
                           [&rest vectorp]
                           [&optional ("interactive" interactive) def-body]))
           (indent defun)
           (doc-string 3))
  (unless (and (fboundp name) (not wal/transient-may-redefine))
    `(transient-define-prefix ,name ,arglist ,@args)))

(defmacro setq-unless (&rest pairs)
  "Set variable/value PAIRS if they're currently nil."
  (declare (debug setq))

  (let ((exps nil))

    (while pairs
      (let ((sym (car pairs)))

        (if (and (boundp sym) (symbol-value sym))
            (progn
              (pop pairs)
              (pop pairs))
          (push `(setq ,(pop pairs) ,(pop pairs)) exps))))
    `(progn . ,(nreverse exps))))
#+END_SRC

** Setup

Allow differentiating between initial and repeated setups.

#+BEGIN_SRC emacs-lisp
(defmacro wal/when-ready (&rest body)
  "Execute BODY when Emacs is ready."
  (if (daemonp)
      `(add-hook 'server-after-make-frame-hook (lambda () ,@body))
    `(add-hook 'emacs-startup-hook (lambda () ,@body))))

(defvar wal/setup-list '()
  "List of already performed setups.")

(cl-defmacro wal/define-init-setup (name docs &key initial always immediately)
  "Define an initial setup for NAME documented by DOCS.

The INITIAL setup is only run once. The ALWAYS one on every call.

In daemon-mode the function may be called IMMEDIATELY. An
appropriate hook is chosen for the original call."
  (declare (indent defun) (doc-string 2))

  (let ((func-name (intern (concat "wal/init-setup-" (symbol-name name)))))

    `(progn
       (defun ,func-name ()
         ,(format "Do base setup for %s. Do minimal setup on repeats.\n%s" name docs)
         (unless (memq ',name wal/setup-list)
           (progn
             (message "Initial setup of '%s'" ,(symbol-name name))
             ,@initial
             (add-to-list 'wal/setup-list ',name)))
         ,@always)
       (if (daemonp)
           (progn
             (when ,immediately
               (funcall ',func-name))
             (add-hook 'server-after-make-frame-hook #',func-name))
         (add-hook 'emacs-startup-hook #',func-name)))))
#+END_SRC

** Regions

Act on regions.

#+BEGIN_SRC emacs-lisp
(defun wal/duck-duck-go-region ()
  "Query duckduckgo with active region."
  (interactive)

  (if mark-active
      (let* ((beg (region-beginning))
             (end (region-end))
             (str (buffer-substring-no-properties beg end))
             (hex-str (url-hexify-string str)))

        (browse-url
         (concat "https://duckduckgo.com/html/?q=" hex-str)))
    (user-error "No active region")))
#+END_SRC

** Messages

Show messages without cluttering.

#+BEGIN_SRC emacs-lisp
(defconst wal/ascii-cachalot-whale (propertize "}< ,.__)" 'face 'mode-line-emphasis)
  "A small, highlighted ASCII cachalot whale.")

(defconst wal/ascii-blue-whale (propertize "}    , ï¬ž   âŽ " 'face 'mode-line-emphasis)
  "A small, highlighted ASCII blue whale.")

(defun wal/message-in-a-bottle (bottle &optional whale)
  "Randomly display a message from the given BOTTLE.

That bottle is just an array of strings.

WHALE is the string used to prefix the message with or the blue
whale by default."
  (let* ((message-log-max nil) ; Don't clutter.
         (message (nth (wal/biased-random (length bottle)) bottle))
         (whale (or whale wal/ascii-blue-whale)))

    (message (concat
              whale
              " "
              (propertize message 'face 'italic)))))
#+END_SRC

** Expansion Packs

Some packages are opt-in (will not be ensured) and belong to one or
several so-called expansion packs[fn:10].

#+BEGIN_SRC emacs-lisp
(defvar wal/expansion-packs nil
  "Packs of expansion packages to be installed using `wal/install-expansion-pack'.

Individual languages build this list using macro
`wal/define-expansion-pack'.")

(cl-defun wal/install-packages (packages &key delete-windows)
  "Install all PACKAGES unless already installed.

Returns the number of newly installed packages.

Calls `delete-other-windows' if DELETE-WINDOWS is t."
  (let ((new-packages (seq-filter
                       (lambda (it) (not (package-installed-p it)))
                       packages)))

    (mapc #'package-install new-packages)

    (when delete-windows
      (delete-other-windows))

    (length new-packages)))

(defun wal/install-recipes (recipes)
  "Install packages from RECIPES using `quelpa'.

Returns the number of newly installed packages."
  (let* ((new-packages (seq-filter
                        (lambda (it) (not (package-installed-p (car it))))
                        recipes)))

    (mapc (lambda (it) (quelpa it)) new-packages)

    (length new-packages)))

(cl-defmacro wal/define-expansion-pack (name docs &key packages extras recipes)
  "Define an expansion pack of PACKAGES under NAME.

Documented using DOCS.

Optionally provide `quelpa' RECIPES."
  (declare (indent defun) (doc-string 2))

  `(add-to-list
    'wal/expansion-packs
    '(,name . (:packages ,packages :extras ,extras :docs ,docs :recipes ,recipes))))

(defun wal/expansion-pack--parts (pack)
  "Get the parts from expansion pack PACK.

Returns a list of (PACKAGES EXTRAS RECIPES DOCS)."
  (let ((p (cdr pack)))

    (list
     (plist-get p :packages)
     (plist-get p :extras)
     (mapcar #'car (plist-get p :recipes))
     (plist-get p :docs))))

(wal/expansion-pack--parts (nth 5 wal/expansion-packs))

(defun wal/expansion-packs ()
  "Get a list of all expansion packs."
  (seq-reduce
   (lambda (acc it)
     (cl-destructuring-bind
         (packages extras recipes _)
         (wal/expansion-pack--parts it)
       (append acc packages extras recipes)))
   wal/expansion-packs '()))

(defun wal/expansion-pack-p (pack)
  "Check if PACK is an expansion pack package."
  (memq pack (wal/expansion-packs)))

(defun wal/install-expansion-pack-extra (pack)
  "Install an or all extras of an expansion for PACK."
  (let* ((extras (plist-get (cdr pack) :extras))
         (selection (wal/maybe-intern
                     (completing-read
                      "Select extra to install: " (append extras '(all))))))

    (pcase selection
      ('all
       (wal/install-packages extras)
       (message "Installed all extras."))
      (_
       (wal/install-packages (list selection))
       (message (format "Installed extra '%s'." selection))))))

(defun wal/install-expansion-pack (pack)
  "Install the given expansion PACK."
  (interactive
   (list (completing-read "Select pack to install: "
                          (mapcar (lambda (pack) (car pack)) wal/expansion-packs))))

  (let* ((sym (wal/maybe-intern pack))
         (item (assoc sym wal/expansion-packs)))

    (cl-destructuring-bind
        (packages extras recipes _)
        (wal/expansion-pack--parts item)

      (if (not item)
          (user-error "Unknown pack '%s', check `wal/expansion-packs'" sym)
        (let* ((installed-packages (wal/install-packages packages :delete-windows t))
               (installed-recipes (wal/install-recipes recipes)))

          ;; Notify about what happened.
          (if (= 0 (+ installed-packages installed-recipes))
              (message "All core packages/recipes already installed.")
            (message "Installed expansion pack '%s'" pack))

          (when (and extras (yes-or-no-p "Want to install an extras?"))
            (wal/install-expansion-pack-extra item)))))))

(defun wal/expansion--stringify (package-list)
  "Stringify PACKAGE-LIST."
  (if package-list
      (mapconcat (lambda (it) (format "%s" it)) package-list ", ")
    ""))
#+END_SRC

** Hooks

#+BEGIN_SRC emacs-lisp
(defvar prog-like-hook nil
  "Commands that should be run for prog-like modes.")

(defun wal/prog-like ()
  "Run `prog-like-hook' functions."
  (run-hooks 'prog-like-hook))

(cl-defmacro wal/hook
    (name
     docs
     &body body
     &key messages lsp lsp-ignores tabs prog-like captain corfu shallow
     &allow-other-keys)
  "Hook into major mode NAME, describe with DOCS.

MESSAGES is a list of strings to randomly choose from and
display.

LSP is either t or nil. LSP-IGNORES are additional paths to add
to variable `lsp-file-watch-ignored-directories'.

TABS is either nil, t or a symbol. Unless the symbol is `always',
tabs are enabled using `wal/maybe-enable-tabs', passing it to the
function as an indentation function.

CAPTAIN is either t or nil. If it is t, a prefixed function
will be mapped to the captain key.

CORFU is a list of (IDLE-DELAY PREFIX-LENGTH).

SHALLOW is either t or nil. If it is t, no indentation-related
values will be set.

The rest of the BODY will be spliced into the lambda."
  (declare (indent defun) (doc-string 2))

  (let ((target (intern (concat (symbol-name name) "-hook")))
        (safe-body (cl-loop for (key val) on body by 'cddr
                            unless (memq key '(:messages :lsp :lsp-ignores :tabs :prog-like :captain :corfu :shallow))
                            collect key
                            and collect val))
        (func-name (intern (concat "wal/" (symbol-name name) "-hook")))
        (include (not shallow))
        (captain-name (intern (concat "wal/" (symbol-name name) "-dispatch"))))

    `(progn
       ,@(delete
          nil
          `((defun ,func-name ()
              ,docs
              ,@(delete
                 nil
                 `(,(when messages
                      `(wal/message-in-a-bottle ,messages))
                   ,(and include '(hack-local-variables))
                   ,(and include (cond ((equal 'always tabs)
                                        `(wal/enable-tabs))
                                       ((equal t tabs)
                                        `(wal/maybe-enable-tabs))
                                       ((not tabs)
                                        '(wal/disable-tabs))
                                       (t `(wal/maybe-enable-tabs :indent-with ,tabs))))
                   ,@safe-body
                   ,(when lsp
                     '(wal/lsp))
                   ,(when corfu
                      `(wal/corfu-auto ',corfu))
                   ,(when prog-like
                      '(run-hooks 'prog-like-hook))
                   ,(when captain
                      `(local-set-key (kbd (wal/key-combo-for-leader 'wal/captain)) ',captain-name)))))

            ,(when (and lsp lsp-ignores)
               `(with-eval-after-load 'lsp-mode
                  (wal/append 'lsp-file-watch-ignored-directories ,lsp-ignores)))

            (add-hook
             ',target
             ',func-name))))))
#+END_SRC

** Additional Mode Controls

Turning on/off certain major modes switching between =major-mode= and
=fundamental-mode=.

#+BEGIN_SRC emacs-lisp
(defvar-local wal/before-fundamental-mode nil
  "The major mode before fundamental was engaged.")

(defun wal/fundamental-mode ()
  "Switch from `major-mode' to `fundamental-mode' and back."
  (interactive)

  (let ((m-mode major-mode))

    (if wal/before-fundamental-mode
        (progn
          (funcall wal/before-fundamental-mode)
          (setq-local wal/before-fundamental-mode nil))
      (fundamental-mode)
      (setq-local wal/before-fundamental-mode m-mode))))
#+END_SRC

** Shell Commands

#+BEGIN_SRC emacs-lisp
(defun wal/async-process (command callback error-callback &optional interrupt)
  "Start async process COMMAND with CALLBACK and ERROR-CALLBACK.

Optonally, interrupt any running process if INTERRUPT is t."
  (when interrupt (wal/async-process--maybe-interrupt))

  (let ((finalizer (wal/async-process--finalize callback error-callback)))

    (with-current-buffer (compilation-start
                          command t
                          #'wal/async-process--buffer-name)
      (view-mode 1)
      (add-hook 'compilation-finish-functions finalizer nil t))))

(defun wal/async-process--maybe-interrupt ()
  "Interrupt process without erroring."
  (when-let* ((comp-buffer (compilation-find-buffer))
              (proc (get-buffer-process comp-buffer)))
    (interrupt-process proc)))

(defun wal/async-process--buffer-name (_mode-name)
  "Generate a buffer name for MODE-NAME."
  (generate-new-buffer-name "*wal-async*"))

(defun wal/async-process--finalize (callback error-callback)
  "Get finalizer that will call CALLBACK or ERROR-CALLBACK."
  (lambda (buf status)
       (if (string= "finished\n" status)
           (condition-case err
               (funcall callback)
             (error
              (funcall error-callback (concat
                                       (error-message-string err)
                                       (buffer-name buf)))))
         (funcall error-callback (string-trim status)))))

(defun wal/kill-async-process-buffers ()
  "Kill all async process buffers."
  (interactive)

  (dolist (buf (buffer-list))
    (with-current-buffer buf
      (when (string-match "^\\*wal-async" (buffer-name))
        (when-let ((window (get-buffer-window buf)))
          (delete-window window))
        (kill-buffer buf)))))
#+END_SRC

** Strings

#+BEGIN_SRC emacs-lisp
(defun wal/matches-in-string (regexp str)
  "Return all matches of REGEXP in STR."
  (let ((matches nil))

    (with-temp-buffer
      (insert str)
      (goto-char (point-min))
      (while (re-search-forward regexp nil t)
        (push (match-string 1) matches)))
    matches))
#+END_SRC

** Advice

#+begin_src emacs-lisp
(defun wal/advise-many (advice combinator advised)
  "Advise ADVISED using ADVICE and COMBINATOR."
  (mapc (lambda (it) (advice-add it combinator advice)) advised))
#+end_src

** Mark

#+BEGIN_SRC emacs-lisp
(defun wal/push-mark (&optional clear-marks)
  "Set mark at where point is without activating it.
If CLEAR-MARKS is t, clear the mark ring."
  (interactive "P")

  (let ((mark (mark t)))

    (when (or (null mark) (/= mark (point)))
      (when clear-marks
        (setq-local mark-ring nil))

      (push-mark)
      (message "Mark set"))))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-func)

;;; wal-func.el ends here
#+END_SRC

* Look
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-look.el" wal/emacs-config-package-path)
:END:

Make frame transparent and set themes. [[https://peach-melpa.org/][PeachMelpa]] has more themes.

#+BEGIN_SRC emacs-lisp
;;; wal-look.el --- Look.

;;; Commentary:
;;
;; Provide packages for the look of the config.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wal/modern-emacs-p "wal-func.el")

(defgroup wal-look nil
  "Change the look."
  :group 'wal
  :tag "Look")

;;;; Customization:

(defcustom wal/transparency 90
  "The default frame transparency."
  :type 'integer
  :group 'wal-look)

(defcustom wal/theme nil
  "The theme."
  :type '(choice symbol (const nil))
  :group 'wal-look)

(defcustom wal/hidpi nil
  "Whether the display is considered HiDPI."
  :type 'boolean
  :group 'wal-look)

(defun wal/transparency--param ()
  "Get the transparency parameter for this Emacs version."
  (if (wal/modern-emacs-p 29)
      'alpha-background
    'alpha))

(defun wal/set-transparency (&optional value)
  "Set the transparency of the frame to VALUE.

1 being (almost) completely transparent, 100 being opaque.

This also updates variable `wal/transparency' for the duration of
the session."
  (interactive
   (list
    (read-number (format "Set transparency (currently %s%%): " wal/transparency))))

  (let ((transparency (min (max (or value wal/transparency) 1) 100))
        (param (wal/transparency--param)))

    (setq wal/transparency transparency)

    (modify-all-frames-parameters `((,param . ,transparency)))))

(defvar wal/active-theme nil)

(defvar wal/theme-hook nil)

(defun wal/load-active-theme ()
  "Load the currently active theme."
  (interactive)

  (when wal/active-theme
    (load-theme wal/active-theme t)
    (run-hooks 'wal/theme-hook)
    t))

(wal/on-boot visuals
  ;; Some themes require configuration, so we only load after initialization.
  (wal/define-init-setup visuals
    "Set up visual frills like theme and transparency."
    :initial
    ((add-to-list 'default-frame-alist `(,(wal/transparency--param) . ,wal/transparency))

     (when wal/theme
       (setq wal/active-theme wal/theme)
       (wal/load-active-theme))

     (when wal/hidpi
       (set-fringe-mode 18)))
    :always
    ((wal/set-transparency)
     (wal/load-active-theme))
    :immediately t)

  ;; Mix of old and new.
  (setq frame-title-format '(multiple-frames "%b" ("%b@" system-name))))

(provide 'wal-look)

;;; wal-look.el ends here
#+END_SRC

* Fonts
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-fonts.el" wal/emacs-config-package-path)
:END:

Set fonts (with preference). To get support for ligatures, install the
symbol font from [[https://github.com/tonsky/FiraCode/files/412440/FiraCode-Regular-Symbol.zip][here]].

#+BEGIN_SRC emacs-lisp
;;; wal-fonts.el --- Fonts.

;;; Commentary:
;;
;; Provide font setup and configuration.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(defgroup wal-fonts nil
  "Change fonts and font sizes."
  :group 'wal
  :tag "Fonts")

;;;; Customization:

(defcustom wal/fixed-fonts
  '("JetBrains Mono"
    "Iosevka"
    "Fira Code"
    "mononoki"
    "Input Mono"
    "Source Code Pro"
    "DejaVu Sans Mono")
  "Fixed fonts ordered by preference."
  :type '(repeat string)
  :group 'wal-fonts)

(defcustom wal/variable-fonts
  '("DeJa Vu Sans"
    "Liberation Serif"
    "Ubuntu")
  "Variable fonts ordered by preference."
  :type '(repeat string)
  :group 'wal-fonts)

(defcustom wal/preferred-fonts nil
  "List of (fixed and variable width) font names that should be preferred."
  :type '(choice (repeat string) (const nil))
  :group 'wal-fonts)

(defcustom wal/fixed-font-height 120
  "The font height for fixed fonts.
The default value is 98."
  :type 'integer
  :group 'wal-fonts)

(defcustom wal/variable-font-height 140
  "The font height for variable fonts.
This has no default value."
  :type 'integer
  :group 'wal-fonts)

(defvar wal/fonts-updated-hook nil
  "Functions to run when fonts were updated.")

(defun wal/font-update (attribute value faces)
  "Set ATTRIBUTE to VALUE for FACES.

This returns the made updates."
  (mapc (lambda (it)
          (when (internal-lisp-face-p it)
            (set-face-attribute it nil attribute value)))
        faces)

  (run-hooks 'wal/fonts-updated-hook))

(defun wal/read-sensible-font-height (type)
  "Read a sensible font height for TYPE."
  (let* ((prev (symbol-value (intern (format "wal/%s-font-height" type))))
         (num (read-number (format "Set %s font (currently: %s): " type prev))))

    (list (max (min num 300) 80))))

(defun wal/available-fonts (fonts)
  "Filter FONTS down to available fonts."
  (seq-filter (lambda (it) (find-font (font-spec :name it))) fonts))

(defun wal/read-font (type)
  "Read a font for TYPE."
  (let* ((name (intern (format "%s-pitch" type)))
         (prev (face-attribute name :family))
         (fonts (symbol-value (intern (format "wal/%s-fonts" type))))
         (font (completing-read (format "Select %s font (current: %s) " type prev) (wal/available-fonts fonts))))
    (list font)))

(defun wal/select-fixed-font (font)
  "Select fixed (available) FONT."
  (interactive (wal/read-font 'fixed))

  (wal/font-update :font font '(default fixed-pitch)))

(defun wal/select-variable-font (font)
  "Select variable (available) FONT."
  (interactive (wal/read-font 'variable))

  (wal/font-update :font font '(variable-pitch)))

(defun wal/set-fixed-font-height (&optional height)
  "Set the HEIGHT for fixed fonts."
  (interactive (wal/read-sensible-font-height 'fixed))

  (setq wal/fixed-font-height height)
  (wal/font-update :height height '(default fixed-pitch)))

(defun wal/set-variable-font-height (&optional height)
  "Set the HEIGHT for variable fonts."
  (interactive (wal/read-sensible-font-height 'variable))

  (setq wal/variable-font-height height)
  (wal/font-update :height height '(variable-pitch)))

(defun wal/preferred-fonts (fonts)
  "Filter FONTS down to preferred fonts."
  (seq-filter (lambda (it) (member it wal/preferred-fonts)) fonts))

(defun wal/fonts-candidate (fonts &optional prefer)
  "Return the first available font from a list of FONTS.
If PREFER is true, variable `wal/preferred-fonts' is not nil and
preferred fonts are available, return the first of those
instead."
  (let* ((available-fonts (wal/available-fonts fonts))
         (preferred (and prefer (wal/preferred-fonts available-fonts))))

    (if preferred
        (car preferred)
      (car available-fonts))))

;; Slanted and enchanted.
(defun wal/font-lock ()
  "Set comment face to italic and keyword face to bold."
  (set-face-attribute 'font-lock-comment-face nil :slant 'italic :weight 'normal)
  (set-face-attribute 'font-lock-keyword-face nil :weight 'bold))

(wal/on-boot fonts
 (wal/define-init-setup fonts
   "Set up fonts for GUI Emacs.

This sets `default' and `fixed-pitch' fonts to the first
available candidate from `wal/fixed-fonts'. Does the same for
`variable-pitch' using `wal/variable-fonts'."
   :initial
   ((when (or (daemonp) (display-graphic-p))
      (mapc (lambda (it)
              (when (internal-lisp-face-p it)
                (set-face-attribute it nil
                                    :font (wal/fonts-candidate wal/fixed-fonts t)
                                    :height wal/fixed-font-height)))
            '(default fixed-pitch))
      (mapc (lambda (it)
              (when (internal-lisp-face-p it)
                (set-face-attribute it nil :inherit 'mode-line)))
            '(mode-line-active mode-line-inactive))

      ;; Variable pitch face.
      (set-face-attribute 'variable-pitch nil
                          :font (wal/fonts-candidate wal/variable-fonts t)
                          :height wal/variable-font-height)))
   :always
   ((run-hooks 'wal/fonts-updated-hook)))

 (wal/general
   "sf" '(wal/set-fixed-font-height :wk "fixed height")
   "sv" '(wal/set-variable-font-height :wk "variable height")
   "sF" '(wal/select-fixed-font :wk "fixed family")
   "sV" '(wal/select-variable-font :wk "variable family"))

 (add-hook 'font-lock-mode-hook #'wal/font-lock))

(provide 'wal-fonts)

;;; wal-fonts.el ends here
#+END_SRC

* External Packages
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-external.el" wal/emacs-config-package-path)
:END:

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-external.el --- External packages -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Set up installing external packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wal/expansion-pack-p "wal-func.el")
(declare-function wal/prefix-user-key "wal-func.el")

(defvar wal/minimal)
(defvar wal/minimal-exclude)
#+END_SRC

** Packages

*** use-package
:PROPERTIES:
:UNNUMBERED: t
:END:

Before =use-package= macro can be used to configure other packages it
needs to be installed. We also install optional dependencies to
diminish and delight minor modes.

#+BEGIN_SRC emacs-lisp
(defconst wal/core-packages '(diminish
                              delight
                              use-package)
  "Packages to install before using `use-package'.
Such as package `use-package'.")

(wal/on-boot external
  (require 'package)

  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)

  ;; Try to install. On fail refresh and install again.
  (condition-case nil
      (wal/install-packages wal/core-packages :delete-windows t)
    (error
     (package-refresh-contents)
     (wal/install-packages wal/core-packages :delete-windows t)))

  (eval-when-compile
    (require 'use-package nil t)))
#+END_SRC

*** Extensions

**** use-package/:wal-bind

We'll add keyword =:wal-bind= to =use-package= in order to create bindings
prefixed by =wal/prefix-user-key=.

#+BEGIN_SRC emacs-lisp
(defun wal/use-package-normalize-binder (name keyword args)
  "Normalize NAME, KEYWORD, ARGS.

This normalizer is a copy of the normalizer for `:bind'. There
are two differences:

1. It prefixes the key strings with `wal/prefix-user-key'.
2. On recursion it calls this normalizer."
  (let ((arg args)
        args*)
    (while arg
      (let ((x (car arg)))
        (cond
         ((and (consp x)
               (or (stringp (car x))
                   (vectorp (car x)))
               (fboundp 'use-package-recognize-function)
               (or (use-package-recognize-function (cdr x) t #'stringp)))
          ;; This is where we deviate from the `:bind' normalizer.
          (setq args* (nconc args* (list (cons (wal/prefix-user-key (car x)) (cdr x)))))
          (setq arg (cdr arg)))
         ((or (and (eq x :map) (symbolp (cadr arg)))
              (and (eq x :prefix) (stringp (cadr arg)))
              (and (eq x :prefix-map) (symbolp (cadr arg)))
              (and (eq x :prefix-docstring) (stringp (cadr arg)))
              (eq x :filter)
              (and (eq x :menu-name) (stringp (cadr arg)))
              (and (eq x :package) (symbolp (cadr arg))))
          (setq args* (nconc args* (list x (cadr arg))))
          (setq arg (cddr arg)))
         ((listp x)
          (setq args*
                (nconc args* (use-package-normalize/:wal-bind name keyword x)))
          (setq arg (cdr arg)))
         (t
          (when (fboundp 'use-package-error)
            (use-package-error
             (concat (symbol-name name)
                     " wants arguments acceptable to the `bind-keys' macro,"
                     " or a list of such values")))))))
    args*))

(defalias 'use-package-normalize/:wal-bind 'wal/use-package-normalize-binder)
(defalias 'use-package-normalize/:wal-bind-keymap 'wal/use-package-normalize-binder)

;; We can use the same handler as `:bind' and `:bind-keymap'.
(defalias 'use-package-handler/:wal-bind 'use-package-handler/:bind)
(defalias 'use-package-handler/:wal-bind-keymap 'use-package-handler/:bind-keymap)

;; Make sure that functions are autoloaded.
(defalias 'use-package-autoloads/:wal-bind 'use-package-autoloads-mode)
#+END_SRC

**** use-package/:wal-ways

Certain packages do not belong to a minimal setup, these are tagged
with =:wal-ways nil=.

#+BEGIN_SRC emacs-lisp
(defalias 'use-package-normalize/:wal-ways 'use-package-normalize-predicate)

(defun use-package-handler/:wal-ways (name _keyword pred rest state)
  "Only expand conditionally.

The conditions for normal packages are: (1) the PRED is t, (2)
`wal/minimal' is nil or (3) NAME is never excluded.

If NAME is an expansion pack package, the conditions are: (1) the
PRED is t or (2) NAME is installed.

The STATE is updated as well before parsing REST if we want to
use the result further down the line."
  (when (and (fboundp 'use-package-process-keywords)
             (fboundp 'use-package-plist-maybe-put))
    (let* ((active (or pred
                       (if (wal/expansion-pack-p name)
                           (not (null (package-installed-p name)))
                         (or (not (or wal/minimal wal/flag-mini))
                             (not (null (memq name wal/minimal-exclude)))))))

           (body (use-package-process-keywords
                   name
                   rest
                   (use-package-plist-maybe-put state :wal-ways active))))

      `((when ,active
          ,@body)))))
#+END_SRC

** quelpa
:PROPERTIES:
:UNNUMBERED: t
:END:

Allows installing from other sources (like GitHub) using recipes.

#+BEGIN_SRC emacs-lisp
(use-package quelpa
  :custom
  (quelpa-update-melpa-p nil))
#+END_SRC

** quelpa-use-package
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
;; NOTE: This package seems no longer maintained.
(use-package quelpa-use-package
  :init
  (setq quelpa-use-package-inhibit-loading-quelpa t)

  :config
  (when (fboundp 'quelpa-use-package-activate-advice)
    (quelpa-use-package-activate-advice)))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-external)

;;; wal-external.el ends here
#+END_SRC

* Emacs
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-emacs.el" wal/emacs-config-package-path)
:END:

Everything that has to do with Emacs-y stuff.

This is a combination of configurations for built-in packages some
external ones.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-emacs.el --- Emacs. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide Emacs settings/configurations.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function wal/modern-emacs-p "wal-func.el")
(declare-function wdb/pop-up "wal-func.el")
(declare-function wdb/side "wal-func.el")

(defvar wal/misc-map)

(wal/on-boot emacs
  (wdb/pop-up 'help-mode)
  (wdb/pop-up 'shortdoc-mode)
  (wdb/side 'debug-mode :no-other t))
#+END_SRC

** Improved Editing

Sometimes I need to see whitespace chars.

*** text-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

No double spaces in sentences.

#+BEGIN_SRC emacs-lisp
(use-package text-mode
  :ensure nil

  :init
  (wal/hook text-mode
    "Hook into `text-mode'."
    :shallow t

    ;; Activate `flyspell-mode' when editing commit messages.
    (when (string-match "COMMIT_EDITMSG" (buffer-name))
      (flyspell-mode)))

  :custom
  (sentence-end-double-space nil))
#+END_SRC

*** abbrev
:PROPERTIES:
:UNNUMBERED: t
:END:

Automatic quick expansion.

#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :ensure nil

  :custom
  (save-abbrevs t)

  :delight " abb")
#+END_SRC

*** follow-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Follow me around.

#+begin_src emacs-lisp
(use-package follow-mode
  :ensure nil

  :custom
  (follow-mode-line-text " flw"))
#+end_src

*** diff-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Effing diffing.

#+BEGIN_SRC emacs-lisp
(use-package diff-mode
  :ensure nil

  :config
  ;; Removes `diff-goto-source'.
  (define-key diff-mode-shared-map (kbd "o") nil))
#+END_SRC

*** tabulated-list
:PROPERTIES:
:UNNUMBERED: t
:END:

According to my tabulations, your columns are too small.

#+BEGIN_SRC emacs-lisp
(use-package tabulated-list
  :ensure nil

  :bind
  (:map tabulated-list-mode-map
   ("M-b" . tabulated-list-previous-column)
   ("M-f" . tabulated-list-next-column)
   ("M-w" . tabulated-list-widen-current-column)
   ("M-n" . tabulated-list-narrow-current-column)))
#+END_SRC

*** hideshow
:PROPERTIES:
:UNNUMBERED: t
:END:

Hide blocks.

#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :ensure nil

  :general
  (wal/major :keymaps 'hs-minor-mode-map
    "h" '(hs-toggle-hiding :wk "toggle hiding")))
#+END_SRC

*** kmacro
:PROPERTIES:
:UNNUMBERED: t
:END:

Some people need macros, okay?

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/kmacro (arg)
  "Toggle kmacro recording with ARG."
  (interactive "P")

  (cond
   (defining-kbd-macro (kmacro-end-macro arg))
   (t (kmacro-start-macro arg))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package kmacro
  :ensure nil

  :config
  (with-eval-after-load 'which-key
    (which-key-add-key-based-replacements "C-c k" "kmacro"))

  :bind
  (:map wal/misc-map
   ("k" . wal/kmacro))

  :bind-keymap
  (("C-c k" . kmacro-keymap)))
#+END_SRC

*** register
:PROPERTIES:
:UNNUMBERED: t
:END:

No offender.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/clear-registers ()
  "Clear all registers."
  (interactive)

  (setq register-alist nil))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package register
  :ensure nil

  :custom
  (register-preview-delay wal/idle-delay)

  :bind
  (:map wal/misc-map
   ("r" . wal/clear-registers))

  :bind-keymap
  (("C-c r" . ctl-x-r-map)))
#+END_SRC

*** pulse
:PROPERTIES:
:UNNUMBERED: t
:END:

Highlight lines.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/lighthouse ()
  "Do a heavy `pulse-momentary-highlight-one-line'.

This just means increasing duration, delay, size and brightness."
  (interactive)

  (defvar pulse-iterations)
  (let ((pulse-iterations 30))

    (pulse-momentary-highlight-one-line (point) 'cursor)))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package pulse
  :ensure nil

  :bind
  ("C-c p" . wal/lighthouse))
#+END_SRC

** Dealing With Emacs

Allow restoring window configurations when Emacs decided they should
be gone.

*** winner
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure nil

  :defer 2

  :config
  ;; Allow for quicker un- and redoing.
  (defhydra wal/winner (:hint nil)
    "
%s`w/hew Window layout: _u_ndo or _r_edo
"
    ("u" winner-undo)
    ("r" winner-redo)
    ("q" nil))

  (winner-mode 1)

  :custom
  (winner-dont-bind-my-keys t)

  :general
  (wal/general "o" '(wal/winner/body :wk "winner")))
#+END_SRC

*** async
:PROPERTIES:
:UNNUMBERED: t
:END:

Execute IO actions asynchronously.

#+BEGIN_SRC emacs-lisp
(use-package async
  :defer 2
  :after dired

  :config
  (dired-async-mode 1)

  :diminish 'dired-async-mode)
#+END_SRC

*** shell
:PROPERTIES:
:UNNUMBERED: t
:END:

I'd like to kill shells without a process quickly.

#+BEGIN_SRC emacs-lisp
(use-package shell
  :ensure nil

  :general
  (general-define-key
   :keymaps '(shell-mode-map comint-mode-map)
   :predicate '(wal/dead-shell-p)
   "k" 'kill-buffer-and-window))
#+END_SRC

*** compile
:PROPERTIES:
:UNNUMBERED: t
:END:

Show compilations in a pop-up and scroll output.

#+BEGIN_SRC emacs-lisp
(use-package compile
  :ensure nil

  :hook
  (compilation-filter . ansi-color-compilation-filter)

  :config
  (wdb/pop-up "\\*compilation")

  :custom
  (compilation-scroll-output t))
#+END_SRC

** Help

*** helpful
:PROPERTIES:
:UNNUMBERED: t
:END:

Let's try to be even more =helpful=.

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :defer 1
  :after elisp-mode

  :config
  (wdb/pop-up 'helpful-mode)

  :bind
  (([remap describe-command] . helpful-command)
   ([remap describe-function] . helpful-function)
   ([remap describe-key] . helpful-key)
   ([remap describe-variable] . helpful-variable)
   ([remap describe-symbol] . helpful-symbol)

   :map help-map
   ("M" . helpful-macro)
   ("C-x" . helpful-kill-buffers)

   :map helpful-mode-map
   ("k" . kill-buffer-and-window)))
#+END_SRC

** Look-Up

*** bookmark
:PROPERTIES:
:UNNUMBERED: t
:END:

Leave a bookmark why don't you.

#+BEGIN_SRC emacs-lisp
(use-package bookmark
  :ensure nil

  :config
  (wdb/side "\\*Bookmark Annotation\\*" :side 'left :no-other t)

  (with-eval-after-load 'bookmark
    (which-key-add-key-based-replacements "C-c m" "bookmark"))

  :custom
  (bookmark-use-annotations t)
  (bookmark-menu-confirm-deletion t)

  :bind-keymap
  (("C-c m" . bookmark-map))

  :bind
  (:map bookmark-map
   ("l" . bookmark-bmenu-list)
   ("L" . bookmark-load)))
#+END_SRC

*** calc
:PROPERTIES:
:UNNUMBERED: t
:END:

Quick calculations.

#+BEGIN_SRC emacs-lisp
(use-package calc
  :ensure nil

  :bind
  ("C-c q" . quick-calc))
#+END_SRC

*** dictionary
:PROPERTIES:
:UNNUMBERED: t
:END:

Look up words in a word book.

#+BEGIN_SRC emacs-lisp
(use-package dictionary
  :ensure nil

  :config
  (wdb/pop-up "^\\*Dictionary")

  :custom
  (dictionary-server "dict.org")

  :general
  (wal/general "d" '(dictionary-lookup-definition :wk "dict")))
#+END_SRC

** Additional Info Display

*** eldoc
:PROPERTIES:
:UNNUMBERED: t
:END:

Contextual information. Package =lsp-mode= use =eldoc= extensively.

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :ensure nil

  :custom
  (eldoc-idle-delay 0.2)
  (eldoc-echo-area-prefer-doc-buffer 'maybe)
  (eldoc-echo-area-display-truncation-message nil)

  :delight " eld")
#+END_SRC

*** hl-line
:PROPERTIES:
:UNNUMBERED: t
:END:

Highlighting the current line.

#+BEGIN_SRC emacs-lisp
(use-package hl-line
  :ensure nil

  :hook
  ((tablist-minor-mode
    tabulated-list-mode
    dired-mode
    dashboard-mode) . hl-line-mode))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-emacs)

;;; wal-emacs.el ends here
#+END_SRC

* Editing
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-edit.el" wal/emacs-config-package-path)
:END:

It's fun to edit things /quickly/.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-edit.el --- Editing. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide editing packages.

;;; Code:

(declare-function wal/list-from "wal-func.el")

(defvar corfu-mode)
(defvar wal/emacs-config-default-path)
(defvar wal/use-hyper-prefix)
#+END_SRC

** Packages

*** multiple-cursors
:PROPERTIES:
:UNNUMBERED: t
:END:

Don't you want to edit your buffer in multiple places at once?

**** Utility

#+BEGIN_SRC emacs-lisp
(defvar wal/mc-conflicting-modes '(puni-mode corfu-mode)
  "Modes that are in conflict with `multiple-cursors-mode'.")

(defvar-local wal/mc-disabled nil
  "Modes that were disabled before entering `multiple-cursors-mode'.")

(defun wal/before-mc ()
  "Disable conflicting modes before entering mode."
  (seq-each
   (lambda (it)
     (when (and (boundp it) (symbol-value it))
       (setq wal/mc-disabled (append wal/mc-disabled `(,it)))
       (eval `(,it -1))))
   wal/mc-conflicting-modes))

(defun wal/after-mc ()
  "Re-enable modes that were disabled before exiting."
  (seq-each (lambda (it) (eval `(,it 1))) wal/mc-disabled)
  (setq wal/mc-disabled nil))

#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :init
  ;; Since the map is `nil', using `:bind' would fail.
  (setq mc/keymap (make-sparse-keymap))

  :hook
  ((multiple-cursors-mode-enabled . wal/before-mc)
   (multiple-cursors-mode-disabled . wal/after-mc))

  :bind
  (("C-." . mc/mark-next-like-this)

   :map mc/keymap
   ("C-," . mc/unmark-next-like-this)
   ("C-/" . mc/skip-to-next-like-this)

   ;; Keep the first two bindings from the default map.
   ("C-g" . mc/keyboard-quit)
   ("C-'" . mc-hide-unmatched-lines-mode))

  :wal-bind
  ("<mouse-3>" . mc/add-cursor-on-click)

  :general
  (wal/lieutenant! "." 'mc/mark-all-like-this  'mc/edit-ends-of-lines))
#+END_SRC

*** iedit
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package iedit
  :bind
  (("C-;" . iedit-mode)

   :map iedit-mode-keymap
   ("C-." . iedit-switch-to-mc-mode)))
#+END_SRC

*** expand-region
:PROPERTIES:
:UNNUMBERED: t
:END:

One thing that can be a bit tricky is selecting regions, not anymore.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind
  (("C->" . er/expand-region)
   ("C-<" . er/contract-region)))
#+END_SRC

*** tempel
:PROPERTIES:
:UNNUMBERED: t
:END:

Don't reduce the boilerplate, reduce your involvement in it with
snippets.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/tempel-setup-capf ()
  "Prepend `tempel-complete'."
  (let* ((current completion-at-point-functions)
         (prepended (cons #'tempel-complete current)))

     (setq-local completion-at-point-functions prepended)))

(defun wal/tempel-comment (elt)
  "Comment the element ELT according to mode."
  (when (eq (car-safe elt) 'c)
    (let ((cs (if (derived-mode-p 'emacs-lisp-mode) ";; " comment-start)))

      (concat cs (cadr elt)))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package tempel
  :hook ((prog-mode prog-like org-mode) . wal/tempel-setup-capf)

  :config
  (setq tempel-path (wal/list-from
                     'tempel-path
                     (expand-file-name
                      "templates/tempel.eld"
                      wal/emacs-config-default-path)))

  :custom
  (tempel-user-elements '(wal/tempel-comment))
  (tempel-trigger-prefix ",,")
  (tempel-mark (propertize "â–‘" 'face 'mode-line-highlight))

  :bind
  (:map tempel-map
   ("M-k" . tempel-kill)
   ("M-a" . tempel-beginning)
   ("M-e" . tempel-end)
   ("M-n" . tempel-next)
   ("M-p" . tempel-previous)))
#+END_SRC

*** elec-pair
:PROPERTIES:
:UNNUMBERED: t
:END:

Less intrusive pairing mode than =smartparens=.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/in-case-of-mc-mode-do-not-default (&rest _args)
  "Advise to inhibit if `multiple-cursors-mode' is t."
  (bound-and-true-p multiple-cursors-mode))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package elec-pair
  :ensure nil

  :hook ((prog-mode prog-like) . electric-pair-local-mode)

  :init
  (advice-add
   'electric-pair-default-inhibit :before-until
   #'wal/in-case-of-mc-mode-do-not-default))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-edit)

;;; wal-edit.el ends here
#+END_SRC

* Visuals
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-visuals.el" wal/emacs-config-package-path)
:END:

I like nice-looking things.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-visuals.el --- Visuals. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide visual packages.

;;; Code:

(declare-function dashboard-insert-startupify-lists "ext:dashboard.el")
(declare-function wal/biased-random "wal-func.el")

(defvar dashboard-footer-messages)
(defvar wal/ascii-cachalot-whale)
(defvar wal/emacs-config-default-path)

(defgroup wal-visuals nil
  "Change settings used for visual packages."
  :group 'wal
  :tag "Visuals")

;;;; Customization:

(defcustom wal/major-delight t
  "Whether some major modes are delighted beyond reason."
  :type 'boolean
  :group 'wal-visuals)

(defcustom wal/zone-when-idle nil
  "Determine whether to zone out when idling."
  :type 'boolean
  :group 'wal-visuals)

(defcustom wal/zone-timer (* 5 60)
  "The time in seconds when we will zone out."
  :type 'integer
  :group 'wal-visuals)
#+END_SRC

** Dashboard

*** dashboard
:PROPERTIES:
:UNNUMBERED: t
:END:

Let's have a dash of board.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/with-recent-files-excluded (fun &rest args)
  "Advise FUN to ignore certain directories, applying ARGS."
  (defvar recentf-exclude)

  (let ((recentf-exclude '("bookmarks\\'" "zettelkasten")))

    (apply fun args)))

(defun wal/instead-show-biased-random (&rest _args)
  "Advise to use biased random footer message."
  (nth (wal/biased-random (length dashboard-footer-messages)) dashboard-footer-messages))

(defun wal/in-case-of-daemonp-add-different-hook ()
  "Setup the dashboard in a daemon-friendly way."
  (require 'all-the-icons nil t)
  (when (daemonp)
    (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))

    (add-hook
     'server-after-make-frame-hook
     #'dashboard-insert-startupify-lists)))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :wal-ways nil

  :hook (after-init . dashboard-setup-startup-hook)

  :init
  (advice-add
   'dashboard-insert-startupify-lists :around
   #'wal/with-recent-files-excluded)
  (advice-add
   'dashboard-random-footer :override
   #'wal/instead-show-biased-random)
  (advice-add
   'dashboard-setup-startup-hook :before-until
   #'wal/in-case-of-daemonp-add-different-hook)

  :config
  (setq dashboard-banner-logo-title (wal/describe-config-version))

  :custom
  (dashboard-items '((recents . 5)
                     (projects . 3)
                     (bookmarks . 3)))
  (dashboard-projects-backend 'project-el)

  (dashboard-image-banner-max-height (if wal/hidpi 0 300))
  (dashboard-startup-banner (let ((ext (if (or (daemonp) (display-graphic-p))
                                           ".png"
                                         ".txt")))

                              (expand-file-name
                               (concat "assets/logo" ext)
                               wal/emacs-config-default-path)))

  (dashboard-footer-icon (if (or (daemonp) (display-graphic-p))
                             ":whale:"
                           wal/ascii-cachaolot-whale))
  (dashboard-footer-messages '("breaching your favorite stupid framework"
                               "I propel myself forward on nothing but flukes"
                               "devout and up the spout"
                               "krill, filter feeders and hit sulphur bottom"
                               "the founder of retiring gentlemen"
                               "the loud keyboard shall vanquish the muscular mouse"
                               "answering all C-calls in sweeping, overflowing song"
                               "infinite whale loop"
                               "from echo location to perimeter expansion"
                               "a mystic of profounder divings"
                               "superior, clear and fine code; but there's little of it"
                               "formed by intertwisting, slanting folds"
                               "a register for distant jets"
                               "the most majestic in affect, the most valuable in commiseration"
                               "unshared, sourceless immensities"))

  (dashboard-week-agenda nil)
  (dashboard-agenda-time-string-format "%d/%m/%y")
  (dashboard-agenda-release-buffers t)

  (dashboard-center-content t)
  (dashboard-set-file-icons t)
  (dashboard-set-navigator t)
  (dashboard-path-style 'truncate-beginning)

  :bind
  (("C-c d" . dashboard-refresh-buffer)))
#+END_SRC

** Themes

*** doom-themes
:PROPERTIES:
:UNNUMBERED: t
:END:

The nicest theme packages out there. It supports many, many packages'
=face= variants.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :wal-ways nil

  :config
  (doom-themes-org-config))
#+END_SRC

*** kaolin-themes
:PROPERTIES:
:UNNUMBERED: t
:END:

Another collection of beautiful themes, but it doesn't color every
=face=.

#+BEGIN_SRC emacs-lisp
(use-package kaolin-themes
  :wal-ways nil

  :config
  (kaolin-treemacs-theme)

  :custom
  (kaolin-themes-italic-comments t)
  (kaolin-themes-git-gutter-solid t)
  (kaolin-themes-modeline-border nil)
  (kaolin-themes-distinct-fringe t)
  (kaolin-themes-org-scale-headings nil))
#+END_SRC

*** modus-themes
:PROPERTIES:
:UNNUMBERED: t
:END:

Protesilaos' super configurable themes.

#+BEGIN_SRC emacs-lisp
(use-package modus-themes
  :ensure nil

  :custom
  (modus-themes-slanted-constructs t)
  (modus-themes-bold-constructs t)
  (modus-themes-mode-line '(borderless))
  (modus-themes-org-blocks 'tinted-background))
#+END_SRC

*** ef-themes
:PROPERTIES:
:UNNUMBERED: t
:END:

Color over configuration from the same author.

#+BEGIN_SRC emacs-lisp
(use-package ef-themes
  :wal-ways nil)
#+END_SRC

*** base16-themes
:PROPERTIES:
:UNNUMBERED: t
:END:

Check out the [[https://base16-project.github.io/base16-gallery/][gallery]].

#+BEGIN_SRC emacs-lisp
(use-package base16-theme
  :wal-ways nil

  :custom
  (base16-theme-distinct-fringe-background nil))
#+END_SRC

** Highlighting

*** diff-hl
:PROPERTIES:
:UNNUMBERED:
:END:

Show diffs in the fringe (also in =dired= buffers).

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :defer 1

  :hook
  ((magit-post-refresh . diff-hl-magit-post-refresh)
   (dired-mode . diff-hl-dired-mode))

  :config
  (global-diff-hl-mode))
#+END_SRC

*** hl-todo
:PROPERTIES:
:UNNUMBERED: t
:END:

Highlight =TODO=, =FIXME= etc. in =prog= modes.

#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :wal-ways nil

  :hook ((prog-mode prog-like) . hl-todo-mode)

  :custom
  (hl-todo-highlight-punctuation ":")
  (hl-todo-require-punctuation t))
#+END_SRC

*** rainbow-delimiters
:PROPERTIES:
:UNNUMBERED: t
:END:

Make delimiters stand out.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :wal-ways nil

  :hook ((prog-mode prog-like) . rainbow-delimiters-mode))
#+END_SRC

*** rainbow-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Show colors colorfully.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :wal-ways nil

  :delight " rbm")
#+END_SRC

** Where Am I?

*** which-key
:PROPERTIES:
:UNNUMBERED: t
:END:

Show the next possible key presses towards a command.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :wal-ways nil

  :defer 2

  :config
  (which-key-mode 1)

  :custom
  (which-key-idle-delay wal/idle-delay)
  (which-key-lighter " wk?")
  (which-key-sort-uppercase-first nil)
  (which-key-show-docstrings t)
  (which-key-preserve-window-configuration t)
  (which-key-show-early-on-C-h t))
#+END_SRC

*** goggles
:PROPERTIES:
:UNNUMBERED: t
:END:

Pulse on region edits.

#+BEGIN_SRC emacs-lisp
(use-package goggles
  :wal-ways nil

  :hook ((prog-mode text-mode) . goggles-mode)

  :custom
  (goggles-pulse-iterations 20)

  :delight " ggl")
#+END_SRC

** Modeline

Minor modes are white-listed, hidden, delighted and diminished.
Meaning that, if not white-listed, they are not shown, if they are
shown, they are delighted unless they were diminished.

*** wal-line
:PROPERTIES:
:UNNUMBERED: t
:END:

My own mode line.

#+BEGIN_SRC emacs-lisp
(use-package wal-line
  :wal-ways nil
  :quelpa (wal-line :fetcher github :repo "Walheimat/wal-line")

  :defer 1

  :config
  (wal-line-mode 1)

  :custom
  (wal-line-icons-prettify-buffer-status t)
  (wal-line-animation-key-frames wal/ascii-blue-whale-key-frames))
#+END_SRC

*** delight
:PROPERTIES:
:UNNUMBERED: t
:END:

Refine a couple of major and minor mode names.

#+BEGIN_SRC emacs-lisp
(use-package delight
  :config
  (delight 'dired-mode "Dired" :major)
  (delight 'emacs-lisp-mode "Elisp" :major)
  (delight 'lisp-interaction-mode "Elisp?" :major)
  (delight 'wdired-mode "DirEd" :major)
  (delight 'c++-mode "CPP" :major)
  (delight 'compilation-shell-minor-mode " csh" "compile")
  (delight 'auto-fill-function " aff" t)
  (delight 'with-editor-mode " w/e" "with-editor")

  ;; Only confuse/delight if allowed.
  (when wal/major-delight
    (delight 'elixir-mode "Homebrew" :major)
    (delight 'c++-mode "*&" :major)
    (delight 'python-mode "Snake" :major)
    (delight 'js-mode "NaNsense" :major)
    (delight 'inferior-python-mode "Bite" :major)))
#+END_SRC

*** diminish
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package diminish)
#+END_SRC

*** minions
:PROPERTIES:
:UNNUMBERED: t
:END:

Sometimes the list of minor modes overcrowds the modeline.

#+BEGIN_SRC emacs-lisp
(use-package minions
  :wal-ways nil

  :defer 3

  :config
  (minions-mode 1)

  :custom
  (minions-prominent-modes '(smerge-mode
                             git-timemachine-mode
                             vterm-copy-mode
                             with-editor-mode
                             typo-mode
                             auto-fill-function
                             flyspell-mode
                             org-tree-slide-mode
                             wal/config-mode
                             verb-mode
                             verb-response-body-mode
                             puni-mode
                             pet-mode)))
#+END_SRC

** Ligatures

Font *JetBrains Mono* has the best support for ligatures.

*** ligature
:PROPERTIES:
:UNNUMBERED: t
:END:

**** Utility

#+BEGIN_SRC emacs-lisp
(defconst wal/common-ligatures
  '(
    "==" "!=" ">=" "<="        ; Comparison.
    "+=" "-=" "/=" "%=" "*="   ; Assignment.
    "||" "&&"                  ; Logical.
    "/*" "*/" "//" "/**" "**/" ; Comments.
    "++" "--"                  ; Increment/decrement.
    ">>=" "<<=" "&=" "|=" "^=" ; Bitwise assignments.
    "<<" ">>"                  ; Bitwise shifts.
    "..."                      ; Spread.
    )
  "A list of ligatures available in all programming modes.")

(defun wal/with-common-ligatures (fun &rest args)
  "Advise FUN to append common ligatures.

ARGS is a list containing modes and additional ligatures."
  (cl-destructuring-bind (modes ligatures) args
    (apply fun `(,modes ,(append ligatures wal/common-ligatures)))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package ligature
  :wal-ways nil

  :hook ((prog-mode prog-like) . ligature-mode)

  :config
  (advice-add
   'ligature-set-ligatures :around
   #'wal/with-common-ligatures))
#+END_SRC

** Icons

*** all-the-icons
:PROPERTIES:
:UNNUMBERED: t
:END:

You need to install the icons yourself[fn:11].

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :wal-ways nil)
#+END_SRC

*** emojify
:PROPERTIES:
:UNNUMBERED: t
:END:

Display emojis[fn:12].

#+BEGIN_SRC emacs-lisp
(use-package emojify
  :wal-ways nil

  :hook (dashboard-mode . emojify-mode))
#+END_SRC

** Screen-Saver

*** zone
:PROPERTIES:
:UNNUMBERED: t
:END:

Screen saver, CPU devourer.

#+BEGIN_SRC emacs-lisp
(use-package zone
  :ensure nil

  :config
  (setq zone-programs [zone-pgm-drip
                       zone-pgm-jitter
                       zone-pgm-dissolve
                       zone-pgm-rat-race
                       zone-pgm-whack-chars])

  (when (and (fboundp 'zone-when-idle) wal/zone-when-idle)
    (zone-when-idle wal/zone-timer))

  :general
  (wal/general "0" 'zone))
#+END_SRC

** Other

*** mixed-pitch
:PROPERTIES:
:UNNUMBERED: t
:END:

Allow using variable and fixed fonts in the same buffer.

#+BEGIN_SRC emacs-lisp
(use-package mixed-pitch
  :wal-ways nil

  :config
  (add-to-list 'mixed-pitch-fixed-pitch-faces 'markdown-pre)

  :custom
  (mixed-pitch-variable-pitch-cursor nil)

  :delight " mpm")
#+END_SRC

*** visual-fill-column
:PROPERTIES:
:UNNUMBERED: t
:END:

Allow padding and centering text.

#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :wal-ways nil)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-visuals)

;;; wal-visuals.el ends here
#+END_SRC

* Windows
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-windows.el" wal/emacs-config-package-path)
:END:

Everything that has to do with windows.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-windows.el --- Windows. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide window packages.

;;; Code:

(declare-function aw-delete-window "ext:ace-window.el")

(defvar popper-buried-popup-alist)
(defvar popper-group-function)
#+END_SRC

** Packages

*** ace-window
:PROPERTIES:
:UNNUMBERED: t
:END:

Ace interacting with (multiple) windows.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/aw-delete-window-kill-buffer (window)
  "Call `aw-delete-window' on WINDOW requesting buffer kill."
  (aw-delete-window window t))

(defun wal/instead-call-consult-buffer (&rest _args)
  "Advise `aw--switch-buffer' to use `consult-buffer'."
  (call-interactively 'consult-buffer))

(defun wal/aw-delete-other-windows (window)
  "Delete windows other than WINDOW."
  (defvar ignore-window-parameters)

  (let ((ignore-window-parameters t))

    (delete-other-windows window)))
#+END_SRC

*** Configuration

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :config
  ;; We want to switch buffers using `consult'.
  (advice-add
   'aw--switch-buffer :override
   #'wal/instead-call-consult-buffer)

  ;; We update the dispatch list after the package is loaded.
  (setq aw-dispatch-alist '((?h aw-split-window-horz "horizontal split")
                            (?v aw-split-window-vert "vertical split")
                            (?f aw-split-window-fair "fair split")
                            (?d aw-delete-window "delete")
                            (?x wal/aw-delete-window-kill-buffer "kill")
                            (?o wal/aw-delete-other-windows "delete other")
                            (?c aw-copy-window "copy")
                            (?s aw-swap-window "swap")
                            (?b aw-switch-buffer-in-window "buffer")
                            ;; If this has a description, it doesn't work.
                            (?? aw-show-dispatch-help)))

  :custom
  (aw-dispatch-always t)
  (aw-keys '(?j ?k ?l ?\; ?u ?i ?o ?p))
  (aw-fair-aspect-ratio 3)

  :custom-face
  (aw-leading-char-face
   ((t :foreground unspecified
       :background unspecified
       :weight bold
       :height 1.6
       :inherit mode-line-emphasis)))

  :wal-bind
  ("o" . ace-window)

  :delight " ace")
#+END_SRC

*** popper
:PROPERTIES:
:UNNUMBERED: t
:END:

Treat certain buffers and their windows as pop-ups.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/popper-echo-replace (regexp buffer-name &optional prefix)
  "Search for REGEXP in BUFFER-NAME.

If no PREFIX is given, a slash is pre-pended to the first match."
  (let ((prefix (or prefix "/")))

    (with-temp-buffer
      (insert buffer-name)
      (goto-char (point-min))
      (re-search-forward regexp nil t)
      (concat
       (if (match-string 2) (match-string 2) "")
       prefix
       (if (match-string 1) (match-string 1) "")))))

(defvar wal/pe-helpful-re "\\*helpful \\w+\: ")
(defvar wal/pe-dc-re "\\* docker-compose \\(?1:up\\|run\\|build\\)\\( --rm\\)?\\ \\(?2:\\w+\\)")
(defvar wal/pe-cont-re "\\* docker container \\(?1:logs\\|stop\\)?\\ ?\\(--tail [[:digit:]]+\\)?\\ \\(?2:\\w+_\\w+_[[:digit:]]+\\)\\ \\*")

(defun wal/popper-echo-transform (buffer-name)
  "Transform BUFFER-NAME by truncating certain prefixes."
  (cond
   ((string-match wal/pe-helpful-re buffer-name)
    (concat
     (substring (replace-regexp-in-string wal/pe-helpful-re "" buffer-name) 0 -1)
     "/help"))
   ((string-match wal/pe-dc-re buffer-name)
    (wal/popper-echo-replace wal/pe-dc-re buffer-name "/dc-"))
   ((string-match wal/pe-cont-re buffer-name)
    (wal/popper-echo-replace wal/pe-cont-re buffer-name))
   (t buffer-name)))

(defvar wal/spared-popups '("\\*Messages\\*"))

(defun wal/popper--spared-p (buffer)
  "Check if BUFFER should be spared."
  (let* ((name (buffer-name buffer))
         (spared (seq-some (lambda (it) (string-match-p it name)) wal/spared-popups)))

    spared))

(defun wal/kill-some-popups ()
  "Query for killing some popups."
  (interactive)

  (let* ((group (when popper-group-function
                  (funcall popper-group-function)))
         (buried (thread-last (alist-get group popper-buried-popup-alist nil nil 'equal)
                              (mapcar #'cdr)
                              (cl-remove-if-not #'buffer-live-p)
                              (cl-remove-if #'wal/popper--spared-p)
                              (delete-dups))))

    (when buried
      (kill-some-buffers buried))

    (setf (alist-get group popper-buried-popup-alist nil nil 'equal)
          (cl-remove-if-not
           (lambda (it) (buffer-live-p (cdr it)))
           (alist-get group popper-buried-popup-alist nil nil 'equal)))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package popper
  :wal-ways nil

  :demand
  :after winner

  :config
  (with-eval-after-load 'all-the-icons
    (defvar wal/popper-mode-line-icon (concat
                                       " "
                                       (all-the-icons-faicon "fort-awesome"
                                                             :face 'all-the-icons-dsilver
                                                             :height 0.9
                                                             :v-adjust 0.0)
                                       " "))
    (setq popper-mode-line '(:eval wal/popper-mode-line-icon)))

  (popper-mode 1)
  (popper-echo-mode 1)

  :custom
  (popper-display-control 'user)

  (popper-reference-buffers '(
                              ;; Info(-like).
                              docker-container-mode
                              "\\*Bookmark Annotation\\*"
                              "\\*org-roam\\*"

                              ;; Compilation(-like).
                              compilation-mode
                              comint-mode
                              "^\\*docker-compose"
                              "^\\* docker-compose \\(up\\|run\\|build\\)"
                              "^\\*wal-async\\*"
                              "\\*rg\\*\\'"

                              ;; REPL(-like).
                              dap-ui-repl-mode
                              cider-repl-mode
                              inferior-python-mode
                              python-pytest-mode

                              ;; Log(-like).
                              "server log\\*$"
                              "\\*\\(.+\\)out\\*"
                              "^\\* docker container"
                              "\\*Messages\\*"
                              "\\*Flycheck Errors\\*"

                              ;; Debug(-like).
                              debugger-mode

                              ;; Help(-like).
                              helpful-mode
                              help-mode
                              dictionary-mode
                              shortdoc-mode))

  (popper-echo-dispatch-persist nil)
  (popper-echo-dispatch-keys '(?a ?s ?d ?f ?g ?q ?w ?e ?r ?t))
  (popper-echo-lines 1)
  (popper-echo-transform-function #'wal/popper-echo-transform)

  :wal-bind
  (:map popper-mode-map
   ("\\" . popper-toggle-latest)
   ("|" . popper-cycle))

  :general
  (general-define-key :keymaps 'wal/misc-map :wk-full-keys nil
   "\\" '(wal/kill-some-popups :wk "kill popups")))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-windows)

;;; wal-windows.el ends here
#+END_SRC

* Movement
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-movement.el" wal/emacs-config-package-path)
:END:

Moving around should be fun.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-movement.el --- Movement. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide movement packages.

;;; Code:

(eval-when-compile
  (require 'avy nil t))

(declare-function avy--line "ext:avy.el")
(declare-function avy-jump "ext:avy.el")
(declare-function org-at-heading-p "ext:org.el")
(declare-function wal/univ-p "wal-func.el")
#+END_SRC

** Packages

*** avy
:PROPERTIES:
:UNNUMBERED: t
:END:

Who needs a mouse.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/avy-goto-word (&optional scope)
  "Jump to a word.

SCOPE will consume `universal-argument' to determine whether to
jump to a word in the buffer or anywhere.n"
  (interactive "P")

  (if scope
      (let ((flip (> 5 (prefix-numeric-value scope))))

        (setq current-prefix-arg nil)
        (avy-goto-word-0 flip))
    (avy-with avy-goto-word-0
      (avy-jump avy-goto-word-0-regexp
                :beg (line-beginning-position)
                :end (line-end-position)
                :window-flip t))))

(defun wal/avy-goto-line (&optional beginning)
  "Go to line or BEGINNING of line."
  (interactive "P")

  (if beginning
      (progn
        (avy-goto-line)
        (beginning-of-line-text))
    (avy-goto-end-of-line)))

(defun wal/avy-mark-region ()
  "Select two lines and mark the region between them."
  (interactive)

  (avy-with wal/avy-mark-region
    (let* ((beg (avy--line))
           (end (avy--line)))

      (when (> beg end)
        (cl-rotatef beg end))

      (set-mark beg)
      (goto-char end)
      (forward-visible-line 1)
      (point))))

(defun avy-action-zip-to-char (pt)
  "Zip (just mark) from current point up to PT."
  (set-mark (point))
  (goto-char pt))

(defun wal/then-goto-beginning-for-org-headings (&rest _args)
  "Advise `avy-goto-end-of-line' to go to beginning for `org' headings.

When called with `universal-argument', this also goes to the
beginning."
  (when (or (wal/univ-p)
            (and (eq major-mode 'org-mode) (org-at-heading-p)))
    (goto-char (line-beginning-position))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package avy
  :commands (avy-with)

  :config
  ;; Extend the dispatch with a way to delete up to a char.
  (add-to-list 'avy-dispatch-alist '(?q . avy-action-zip-to-char))

  ;; Make sure we go to the start of the line for org headings.
  (advice-add
   'avy-goto-end-of-line :after
   #'wal/then-goto-beginning-for-org-headings)

  :custom
  (avy-background t)

  :bind
  (:map wal/misc-map
   ("c" . avy-goto-char)
   ("w" . avy-goto-whitespace-end))

  :wal-bind
  ("l" . wal/avy-goto-line)
  ("u" . wal/avy-goto-word)

  :general
  ;; Lines.
  (wal/lieutenant! "c" 'avy-copy-line 'avy-copy-region)
  (wal/lieutenant! "x" 'avy-kill-whole-line 'avy-kill-region)
  (wal/lieutenant! "m" 'avy-move-line 'avy-move-region)
  (wal/lieutenant! "w"
    'avy-kill-ring-save-whole-line
    'avy-kill-ring-save-region))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-movement)

;;; wal-movement.el ends here
#+END_SRC

* Finding Things
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-find.el" wal/emacs-config-package-path)
:END:

I mostly search.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-find.el --- Finding things. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide packages to find things.

;;; Code:
#+END_SRC

** Packages

*** rg
:PROPERTIES:
:UNNUMBERED: t
:END:

You can get the =ripgrep= binary from [[https://github.com/BurntSushi/ripgrep][here]].

#+BEGIN_SRC emacs-lisp
(use-package rg
  :commands (wal/univ-rg-project rg-menu rg-read-pattern)

  :init
  (wal/univ rg-project rg-menu)

  :config
  (wdb/pop-up "\\*rg\\*\\'")

  :wal-bind
  ("n" . wal/univ-rg-project))
#+END_SRC

*** dumb-jump
:PROPERTIES:
:UNNUMBERED: t
:END:

Look up definitions when no LSP is already doing it. Jumping is done
using =xref-find-definitions= (=M-.=).

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :init
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)

  :custom
  (dumb-jump-force-searcher 'rg)
  (dumb-jump-selector 'completing-read))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-find)

;;; wal-find.el ends here
#+END_SRC

* Completion
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-complete.el" wal/emacs-config-package-path)
:END:

Complete commands and code.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-complete.el --- Completion. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide Emacs completion packages.

;;; Code:

(eval-when-compile
  (require 'transient))

(declare-function org-clock-in "ext:org-clock.el")
(declare-function wal/append "wal-func.el")

(defvar consult-register--narrow)
(defvar savehist-additional-variables)
(defvar wal/active-theme)
(defvar wal/dwim-key)

;;; Customization:

(defgroup wal-complete nil
  "Change completion settings."
  :group 'wal
  :tag "Completion")
#+END_SRC

** Inline Completion

*** corfu
:PROPERTIES:
:UNNUMBERED: t
:END:

Alternative.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/corfu-enable-in-minibuffer ()
  "Enable Corfu in the minibuffer if `completion-at-point' is bound."
  (when (where-is-internal #'completion-at-point (list (current-local-map)))
    (corfu-mode 1)))

(defun wal/corfu-auto (values)
  "Set delay and minimum prefix using VALUES.

This a list of (DELAY PREFIX-LENGTH)."
  (cl-destructuring-bind (delay prefix) values
    (setq-local corfu-auto-delay delay
                corfu-auto-prefix prefix)))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package corfu
  :hook
  (((org-mode prog-mode prog-like eshell-mode) . corfu-mode)
   (minibuffer-setup . wal/corfu-enable-in-minibuffer))

  :custom
  (corfu-auto t)
  (corfu-cycle t))
#+END_SRC

*** corfu-quick
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package corfu-quick
  :ensure nil

  :demand
  :after corfu

  :config
  (bind-key wal/dwim-key 'corfu-quick-complete 'corfu-map))
#+END_SRC

*** corfu-history
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package corfu-history
  :ensure nil

  :demand
  :after corfu

  :config
  (add-to-list 'savehist-additional-variables 'corfu-history)
  (corfu-history-mode)

  :custom
  (corfu-history-length 200))
#+END_SRC

*** corfu-doc
:PROPERTIES:
:UNNUMBERED: t
:END:

Show docs while selecting.

#+BEGIN_SRC emacs-lisp
(use-package corfu-doc
  :after corfu

  :bind
  (:map corfu-map
   ("M-p" . corfu-doc-scroll-down)
   ("M-n" . corfu-doc-scroll-up)
   ("M-d" . corfu-doc-toggle)))
#+END_SRC

** Minibuffer Completion

*** vertico
:PROPERTIES:
:UNNUMBERED: t
:END:

Provide global option narrowing using the =vertico= family of products.

#+BEGIN_SRC emacs-lisp
(use-package vertico
  :defer 1

  :config
  ;; Set up minibuffer.
  (setq read-extended-command-predicate #'command-completion-default-include-p
        minibuffer-prompt-properties '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  (vertico-mode)

  :custom
  (vertico-cycle t)
  (vertico-sort-function #'vertico-sort-history-alpha))
#+END_SRC

*** vertico-directory
:PROPERTIES:
:UNNUMBERED: t
:END:

**** Utility

#+BEGIN_SRC emacs-lisp
(defvar-local wal/command nil
  "Command that started completion session.")

(defun wal/record-this-command ()
  "Record the command which opened the minibuffer."
  (setq-local wal/command this-command))

(defun wal/with-dired-goto-file-ignored (fun &rest args)
  "Advise FUN using ARGS to exit if we came from `dired-goto-file'."
  (unless (and (eq (car args) 'category)
               (eq wal/command 'dired-goto-file))
    (apply fun args)))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package vertico-directory
  :ensure nil

  :demand
  :after vertico

  :hook
  ((rfn-eshadow-update-overlay . vertico-directory-tidy)
   (minibuffer-setup . wal/record-this-command))

  :config
  ;; We don't want to enter directories when we go to file with Dired.
  (advice-add
   'vertico--metadata-get :around
   #'wal/with-dired-goto-file-ignored)

  :bind
  (:map vertico-map
   ("RET" . vertico-directory-enter)
   ("DEL" . vertico-directory-delete-char)
   ("M-DEL" . vertico-directory-delete-word)))
#+END_SRC

*** vertico-quick
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package vertico-quick
  :ensure nil

  :demand
  :after vertico

  :bind
  (:map vertico-map
   ("M-q" . vertico-quick-exit)
   ("C-q" . vertico-quick-insert)))
#+END_SRC

*** orderless
:PROPERTIES:
:UNNUMBERED: t
:END:

Fuzzy matches.

#+BEGIN_SRC emacs-lisp
(use-package orderless
  :demand
  :after vertico

  :config
  ;; Setup basic completion and category defaults/overrides.
  (setq completion-styles '(orderless partial-completion basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+END_SRC

*** marginalia
:PROPERTIES:
:UNNUMBERED: t
:END:

Contextual information during completion, partial completion and
completion actions.

#+BEGIN_SRC emacs-lisp
(use-package marginalia
  :demand
  :after vertico

  :config
  (marginalia-mode)
  (bind-key wal/dwim-key 'marginalia-cycle 'minibuffer-local-map))
#+END_SRC

*** embark
:PROPERTIES:
:UNNUMBERED: t
:END:

Act upon =thing-at-point=, be it in a buffer or minibuffer.

#+BEGIN_SRC emacs-lisp
(use-package embark
  :after vertico

  :commands (wal/univ-embark-act)

  :init
  (wal/univ embark-act embark-dwim)

  :config
  ;; No mode-line for collections and completions.
  (wdb/ghost "\\`\\*Embark Collect \\(Live\\|Completions\\)\\*")

  ;; Search using region.
  (define-key embark-region-map
              (kbd "g")
              #'wal/duck-duck-go-region)

  :custom
  (embark-mixed-indicator-delay wal/idle-delay)
  (embark-cycle-key (kbd wal/dwim-key))

  :wal-bind
  ("k" . wal/univ-embark-act))
#+END_SRC

*** embark-consult
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package embark-consult
  :demand
  :after (embark consult)

  :hook (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC

*** consult
:PROPERTIES:
:UNNUMBERED: t
:END:

Heavy lifting with =consult=.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/consult-ripgrep-ignored (&optional dir initial)
  "Search for regexp with rg in DIR with INITIAL input.
Do not ignore hidden files."
  (interactive "P")

  (let ((consult-ripgrep-args
         (concat (substring consult-ripgrep-args 0 -1) "--no-ignore .")))

    (when (and (fboundp 'consult--grep)
               (fboundp 'consult--ripgrep-builder))
      (consult--grep "Ripgrep (ignored)" #'consult--ripgrep-builder dir initial))))

(defun wal/consult-unregister ()
  "Remove KEY from the register."
  (interactive)

  (let ((key (with-no-warnings
               (consult--read
                (consult-register--candidates)
                :prompt "Unregister: "
                :category 'multi-category
                :group (consult--type-group consult-register--narrow)
                :narrow (consult--type-narrow consult-register--narrow)
                :sort nil
                :require-match t
                :history t ;; disable history
                :lookup #'consult--lookup-candidate))))

    (setq register-alist (assoc-delete-all key register-alist))))

(defun wal/consult-line (&optional not-at-point)
  "Call `consult-line' using `thing-at-point'.

If NOT-AT-POINT is t, call `consult-line' normally."
  (interactive "P")

  (if not-at-point
      (consult-line)
    (consult-line (thing-at-point 'symbol))))

(defun wal/consult-clock-in ()
  "Clock into an Org agenda heading."
  (interactive)

  (save-window-excursion
    (consult-org-agenda)
    (org-clock-in)))

(defun wal/then-set-active-theme (theme)
  "Advise to set `wal/active-theme' to THEME."
  (setq wal/active-theme theme)
  (run-hooks 'wal/theme-hook))

(defun wal/with-big-vertico (fun &rest args)
  "Call FUN with ARGS but increase the `vertico-count'."
  (defvar vertico-count)
  (let ((vertico-count 20))

    (apply fun args)))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package consult
  :commands
  (wal/consult-line
   wal/consult-clock-in
   wal/univ-consult-mark
   wal/consult-unregister)

  :init
  (wal/univ consult-mark consult-global-mark)

  (defvar wal/consult-map (make-sparse-keymap))

  :config
  ;; Integrate with `xref'.
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Customize sources.
  (consult-customize
   consult--source-recent-file
   consult--source-project-recent-file
   consult--source-bookmark
   :preview-key (kbd wal/dwim-key)
   consult--source-project-recent-file
   :narrow ?r
   wal/consult-clock-in
   :prompt "Clock in: "
   :preview-key (kbd wal/dwim-key))

  ;; Be sure to set the active them after switching.
  (advice-add 'consult-theme :after #'wal/then-set-active-theme)

  ;; Use a bigger `vertico' when grepping.
  (advice-add 'consult-ripgrep :around #'wal/with-big-vertico)

  (with-eval-after-load 'which-key
    (which-key-add-key-based-replacements
      (wal/prefix-user-key "[")
      '(nil . "consult")))

  (with-eval-after-load 'org-keys
    (wal/replace-in-alist
     'org-speed-commands
     '(("j" . consult-org-heading))))

  :custom
  (consult-buffer-filter (list "\\` " "\\`\\*" "\\`magit"))

  :bind
  (:map wal/consult-map
   ("c" . wal/consult-clock-in)
   ("f" . consult-focus-lines)
   ("g" . consult-goto-line)
   ("h" . consult-org-heading)
   ("i" . wal/consult-line)
   ("k" . consult-kmacro)
   ("l" . consult-locate)
   ("m" . consult-bookmark)
   ("n" . consult-ripgrep)
   ("r" . consult-register)
   ("t" . consult-theme)
   ("u" . wal/consult-unregister)
   ("<SPC>" . wal/univ-consult-mark)
   ("C-f" . consult-recent-file)
   ("+" . consult-mode-command)
   ("-" . consult-minor-mode-menu))

  :wal-bind
  (("j" . consult-buffer)
   ("y" . consult-register-store)
   ("i" . consult-register-load))

  :wal-bind-keymap
  (("[" . wal/consult-map)))
   #+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-complete)

;;; wal-complete.el ends here
#+END_SRC

* Workspace
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-workspace.el" wal/emacs-config-package-path)
:END:

Keep order.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-workspace.el --- Workspace. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide workspace packages.

;;; Code:

(declare-function consult--buffer-query "ext:consult.el")
(declare-function project-buffers "ext:project.el")
(declare-function project-name "ext:project.el")
(declare-function project-root "ext:project.el")
(declare-function rg-read-files "ext:rg.el")
(declare-function rg-run "ext:rg.el")
(declare-function rg-read-pattern "ext:rg.el")
(declare-function ring-elements "ext:ring.el")
(declare-function ring-empty-p "ext:ring.el")
(declare-function ring-insert "ext:ring.el")
(declare-function ring-ref "ext:ring.el")
(declare-function wal/univ-p "wal-func.el")

(defvar compilation-save-buffers-predicate)
(defvar org-agenda-files)

(defgroup wal-workspace nil
  "Change settings used for workspace packages."
  :group 'wal
  :tag "Workspace")
#+END_SRC

** Packages

*** project
:PROPERTIES:
:UNNUMBERED: t
:END:

Built-in project management.

**** Utility

#+BEGIN_SRC emacs-lisp
(defvar wal/project-commands `(compile ,(make-hash-table :test 'equal)
                               test ,(make-hash-table :test 'equal)
                               install ,(make-hash-table :test 'equal))
  "Hash maps for compilation commands.")

;; Set these as dir locals.
(defvar-local wal/project-compile-default-cmd nil)
(defvar-local wal/project-test-default-cmd nil)
(defvar-local wal/project-install-default-cmd nil)

(defvar wal/project-current-command nil)
(defvar wal/project-command-history nil)
(defconst wal/project-command-history-length 5)

(defun wal/project-command--buffer-name (_major-mode)
  "Get the buffer name for the current command."
  (if wal/project-current-command
      (concat "*" "project-" wal/project-current-command "*")
    "*project-compile*"))

(defun wal/project-command (cmd)
  "Run CMD for the current project.

Each command will be stored in a per-project history."
  (let* ((current (project-current t))
         (root (project-root current))
         (name (project-name current))

         (table (plist-get wal/project-commands cmd))
         (default-cmd (or (symbol-value
                           (intern (format "wal/project-%s-default-cmd" cmd)))
                          ""))
         (history (gethash root table (make-ring wal/project-command-history-length)))
         (wal/project-command-history (ring-elements history))

         (initial (if (ring-empty-p history)
                      default-cmd
                    (ring-ref history 0)))
         (wal/project-current-command (symbol-name cmd))
         (prompt (concat (capitalize wal/project-current-command) " project (" name "): "))
         (command (read-shell-command prompt initial 'wal/project-command-history))

         (default-directory (project-root current))
         (compilation-buffer-name-function 'wal/project-command--buffer-name))

    ;; Store the entered command.
    (ring-insert history command)
    (puthash root history table)

    (compile command)))

(defun wal/project-compile ()
  "Compile the current project."
  (interactive)

  (wal/project-command 'compile))

(defun wal/project-test ()
  "Test the current project."
  (interactive)

  (wal/project-command 'test))

(defun wal/project-install ()
  "Install the current project."
  (interactive)

  (wal/project-command 'install))

(defun wal/with-project-bounded-compilation (fun &rest args)
  "Run FUN applying ARGS.

Makes sure this is done with `compilation-save-buffers-predicate'
set to filter by project buffers."
  (let* ((buffers (project-buffers (project-current)))
         (pred (lambda () (memq (current-buffer) buffers)))
         (compilation-save-buffers-predicate pred))

    (apply fun args)))

(defun wal/project-find-rg (query files)
  "Run `rg' in project.

Will search using QUERY in FILES."
  (interactive
   (list
    (rg-read-pattern nil)
    (rg-read-files)))

  (let ((dir (project-root (project-current t)))
        (flags (funcall rg-command-line-flags-function 'nil)))

      (rg-run query files dir nil nil flags)))

(defun wal/project-consult-buffer ()
  "Find an open project buffer using `consult-buffer'."
  (interactive)

  (defvar consult-project-buffer-sources)
  (let ((confirm-nonexistent-file-or-buffer t))

    (consult-buffer consult-project-buffer-sources)))

(defun wal/project-magit-status ()
  "Show `magit-status' for the current project."
  (interactive)

  (if-let* ((current (project-current t))
            (root (project-root current))
            (is-vc (cadr current)))
      (magit-status root)
    (message "Project at '%s' is not version-controlled" root)))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package project
  :ensure nil

  :init
  (wal/advise-many
   'wal/with-project-bounded-compilation :around
   '(project-compile
     wal/project-test
     wal/project-install
     wal/project-compile
     recompile))

  :custom
  (project-vc-extra-root-markers '("pom.xml"
                                   "package.json"
                                   "project.godot"
                                   ".project-marker"))

  (project-switch-commands '((project-find-file "Find file" ?f)
                             (project-find-dir "Find dir" ?d)
                             (wal/project-magit-status "Magit" ?m)
                             (project-eshell "Eshell" ?e)
                             (wal/project-consult-buffer "Consult buffer" ?j)
                             (wal/project-find-rg "Find rg" ?n)))

  (project-vc-ignores '("node_modules/"
                        "build/"
                        "android/"
                        "*.lock"
                        "bundle.js"
                        "*.min.js"
                        "*.js.map"
                        "coverage/"))

  :bind
  (:map project-prefix-map
   ("c" . wal/project-compile)
   ("t" . wal/project-test)
   ("i" . wal/project-install))

  :wal-bind
  (("h" . project-find-file)
   ("p" . project-switch-project)))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-workspace)

;;; wal-workspace.el ends here
#+END_SRC

* Org Mode
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-org.el" wal/emacs-config-package-path)
:END:

The best thing about Emacs. Check out the [[https://orgmode.org/manual/][manual]] or run =org-info=.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-org.el --- Org. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide org packages/configurations.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function org-roam-buffer-p "ext:org-roam.el")
(declare-function project-root "ext:project.el")
(declare-function wal/append "wal-func.el")
(declare-function wal/replace-in-alist "wal-fun.el")
(declare-function wal/truncate "wal-func.el")
(declare-function wal/univ-p "wal-func.el")

(defvar text-scale-mode-step)
(defvar visual-fill-column-width)
(defvar visual-fill-column-center-text)
(defvar wal/agenda-tasks-directory)
(defvar wal/misc-map)

(defgroup wal-org nil
  "Change settings used for org packages."
  :group 'wal
  :tag "Org")

(defcustom wal/org-agenda-register-char ?a
  "The char used to store the agenda window configuration."
  :group 'wal-org
  :type 'integer)
#+END_SRC

** The Mode Itself

*** org
:PROPERTIES:
:UNNUMBERED: t
:END:

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/first-require-ox-md (&rest _args)
  "Advise to require `ox-md' before export dispatch."
  (unless (featurep 'ox-md)
    (require 'ox-md nil t)))

(defun wal/org-content (level)
  "Show up to given LEVEL.
This calls `org-content' interactively."
  (interactive "nShow content up to level: ")

  (when (fboundp 'org-content)
    (org-content level)))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil

  :commands (org-add-note)

  :hook (org-mode . auto-fill-mode)

  :init
  (wal/hook org-mode
    "Hook into `org-mode'."
    :messages '("Organize! Seize the means of production!")
    :captain t)

  :config
  ;; TEMP: Getting missing face errors otherwise.
  (require 'org-indent)

  ;; Require `ox-md' before calling dispatch as it might not be loaded.
  (advice-add
   'org-export-dispatch :before
   #'wal/first-require-ox-md)

  (with-no-warnings
    (wal/transient-define-prefix-once wal/org-mode-dispatch ()
      "Access `org-mode' commands."
      [["Commands"
        ("n" "add note" org-add-note)
        ("t" "toggle timestamp" org-toggle-timestamp-type
         :inapt-if-not (lambda () (org-at-timestamp-p 'inactive)))
        ("o" "order list" org-sort
         :inapt-if-not org-at-item-p)
        ("h" "open info (for node)" org-info-find-node)]
       ["Subtrees"
        ("s w" "cut" org-cut-subtree
         :inapt-if-not org-at-heading-p)
        ("s y" "paste" org-paste-subtree)]
       ["Visibility"
        ("v a" "show all" org-show-all)
        ("v l" "up to level" wal/org-content)]
       ["Footnotes"
        ("f a" "add" org-footnote-new
         :inapt-if org-in-src-block-p)
        ("f d" "dwim" org-footnote-action
         :inapt-if org-in-src-block-p)
        ("f n" "normalize" org-footnote-normalize)]]))

  :custom
  ;; Make it look nice and tidy.
  (org-adapt-indentation nil)
  (org-ellipsis "â†·")
  (org-hide-emphasis-markers t)
  (org-startup-with-inline-images t)
  (org-startup-folded 'overview)
  (org-cycle-separator-lines 1)

  ;; Logging.
  (org-log-done 'time)
  (org-log-note-clock-out t)
  (org-log-into-drawer t)

  ;; Set up directories.
  (org-directory wal/org-directory)
  (org-default-notes-file (concat org-directory "/notes.org"))
  (org-agenda-files `(,wal/agenda-tasks-directory))

  ;; Be sure to add archive tag with `org-toggle-archive-tag'.
  (org-archive-location "::* Archived")

  ;; Adapt keywords, tags and speed commands.
  (org-todo-keywords
   '((sequence "TODO(t)" "IN PROGRESS(p)" "WAITING(w)" "BLOCKED(b)" "|" "DONE(d)" "CANCELED(c)")))
  (org-tag-alist
   '(;; Depth.
     ("@immersive" . ?i)
     ("@process" . ?p)
     ;; Context.
     ("@work" . ?w)
     ("@home" . ?h)
     ("@away" . ?a)
     ("@repeated" . ?r)
     ("@unbillable" . ?u)
     ("@intermittent" . ?m)
     ;; Energy.
     ("@easy" . ?1)
     ("@average" . ?2)
     ("@challenge" . ?3)
     ;; Category.
     ("@development" . ?d)
     ("@talk" . ?t)
     ("@contribution" . ?c)
     ("@growth" . ?g)
     ("@education" . ?e)
     ("@chore" . ?o)))

  ;; Warn late about upcoming deadlines.
  (org-deadline-warning-days 2)

  :bind
  (:map org-mode-map
   ("M-p" . org-previous-visible-heading)
   ("M-n" . org-next-visible-heading)))
#+END_SRC

** Agendas

*** org-agenda
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package org-agenda
  :ensure nil

  :config
  (wal/replace-in-alist 'org-agenda-prefix-format '((agenda . "  %?-12t%? c%s%b")))

  :custom
  (org-agenda-hide-tags-regexp "^@")
  (org-agenda-span 'day)
  (org-agenda-restore-windows-after-quit t)
  (org-agenda-time-leading-zero t)
  (org-agenda-log-mode-items '(clock))
  (org-agenda-start-with-clockreport-mode t)
  (org-agenda-start-with-log-mode t)
  (org-agenda-clockreport-parameter-plist
   '(:link t
     :maxlevel 3
     :fileskip0 t
     :emphasize t
     :match "-@unbillable"))

  :bind
  ("C-c a" . org-agenda))
#+END_SRC

*** org-habit
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package org-habit
  :ensure nil

  :custom
  (org-habit-show-habits-only-for-today nil)
  (org-habit-graph-column 50))
#+END_SRC

*** org-super-agenda
:PROPERTIES:
:UNNUMBERED: t
:END:

Allow for better grouping.

#+BEGIN_SRC emacs-lisp
(use-package org-super-agenda
  :wal-ways nil

  :demand
  :after org-agenda

  :config
  (org-super-agenda-mode)

  :custom
  (org-super-agenda-groups
   '((:name "Schedule" :time-grid t)
     (:name "Unscheduled"
      :and (:scheduled nil
            :not (:tag "@intermittent" :todo "BLOCKED")))
     (:name "Leftovers"
      :and (:todo ("IN PROGRESS" "WAITING")
            :scheduled past
            :not (:tag "@repeated" :tag "@education")))
     (:name "Blocked" :todo "BLOCKED")
     (:name "Education" :and (:habit t :tag "@education"))

     ;; Habits.
     (:name "Contribution"
      :and (:habit t
            :tag "@contribution"))
     (:name "Growth"
      :and (:habit t
            :tag "@growth"))
     (:name "Chores"
      :and (:habit t
            :tag "@chore"))
     (:name "Other habits"
            :habit t)

     ;; Discard the rest.
     (:discard (:anything t))))
  (org-super-agenda-final-group-separator "\n"))
#+END_SRC

** Zettelkasten

Trying to organize my thoughts using ZettelkÃ¤sten.

/Note/ that you will need to install =sqlite3= manually.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack org-roam
  "Note rhizome."
  :packages (org-roam)
  :extras (org-roam-ui))
#+END_SRC

*** org-roam
:PROPERTIES:
:UNNUMBERED: t
:END:

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/maybe-org-roam-refile (&rest args)
  "Refile using ARGS, but use `org-roam-refile' for its buffers.

If called with `universal-argument', default to `org-roam' in any
case."
  (interactive)

  (declare-function org-refile "ext:org.el")
  (defvar org-roam-directory)

  (if (and (org-roam-buffer-p) (not (wal/univ-p)))
      (let ((org-agenda-files (list org-roam-directory)))

        (org-refile args))
    (org-refile args)))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package org-roam
  :if (executable-find "sqlite3")
  :wal-ways nil

  :ensure nil

  :commands
  (wal/org-roam
   org-roam-buffer-display-dedicated
   org-roam-capture
   org-roam-node-create
   org-roam-node-find
   org-roam-node-read)

  :init
  (setq org-roam-v2-ack t)

  :config
  ;; Show roam buffer on the right.
  (wdb/side org-roam-buffer :side 'right :no-other t)

  ;; Refile differently for these files.
  (wal/replace-in-alist 'org-speed-commands '(("w" . wal/maybe-org-roam-refile)))

  (wal/transient-define-prefix-once wal/org-roam-dispatch ()
    "Run `org-roam' commands."
    [["Capture"
      ("c" "capture" org-roam-capture)
      ("t" "today" org-roam-dailies-capture-today)
      ("o" "normal" org-capture)]
     ["Find"
      ("f" "find" org-roam-node-find)
      ("d" "find daily" org-roam-dailies-goto-date)
      ("D" "find daily directory" org-roam-dailies-find-directory)]
     ["Actions"
      ("b" "buffer" org-roam-buffer-toggle)
      ("w" "refile" org-roam-refile
       :inapt-if-not-mode 'org-mode)
      ("i" "insert" org-roam-node-insert
       :inapt-if-not-mode 'org-mode)
      ("@" "tag" org-roam-tag-add
       :inapt-if-not-mode 'org-mode)]
     ["Visualization"
      ("g" "graph" org-roam-graph)]])

  (org-roam-db-autosync-enable)

  :custom
  ;; Setup directories and file names.
  (org-roam-directory wal/org-roam-directory)
  (org-roam-dailies-directory (expand-file-name "tagebuch/" wal/org-roam-directory))
  (org-roam-extract-new-file-path "${slug}.org")

  ;; Simple capture templates.
  (org-roam-capture-templates
   '(("d" "default" plain "%?"
      :target (file+head "${slug}.org"
                         "#+title: ${title}\n")
      :unnarrowed t)))
  (org-roam-dailies-capture-templates
   '(("d" "default" entry
      "* %?\n:PROPERTIES:\n:CREATED_AT: %U\n:TASK: %k\n:END:"
      :target (file+head "%<%Y-%m-%d>.org"
                         "#+title: %<%Y-%m-%d>\n")
      :empty-lines 1)))

  :wal-bind
  ("]" . wal/org-roam-dispatch))
#+END_SRC

*** org-roam-ui
:PROPERTIES:
:UNNUMBERED: t
:END:

Fancy UI.

#+BEGIN_SRC emacs-lisp
(use-package org-roam-ui
  :wal-ways nil

  :defer 3
  :after org-roam

  :config
  (transient-append-suffix 'wal/org-roam-dispatch '(0 3 0)
    '("u" "ui" org-roam-ui-mode))

  :ensure nil)
#+END_SRC

** Presentations

*** org-tree-slide
:PROPERTIES:
:UNNUMBERED: t
:END:

Turn any =org-mode= buffer into a presentation.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/relative-column-width (&optional target-width)
  "Get the relative column width of TARGET-WIDTH."
  (let ((width (or target-width 160))
        (scale (if (and (boundp 'text-scale-mode-amount)
                        (numberp text-scale-mode-amount))
                   (expt text-scale-mode-step text-scale-mode-amount)
                 1)))

    (ceiling (/ width scale))))

(defun wal/org-tree-slide-toggle-visibility ()
  "Toggle visibility of cursor."
  (interactive)

  (if cursor-type
      (setq cursor-type nil)
    (setq cursor-type t)))

(defvar wal/org-tree-slide-disabled-modes '())

(defun wal/org-tree-slide-play ()
  "Hook into `org-tree-slide-play'."
  (setq visual-fill-column-width (wal/relative-column-width 160)
        visual-fill-column-center-text t
        cursor-type nil)
  (visual-fill-column-mode 1)

  (mixed-pitch-mode 1))

(defun wal/org-tree-slide-stop ()
  "Hook into `org-tree-slide-stop'."
  (setq visual-fill-column-width nil
        visual-fill-column-center-text nil
        cursor-type t)
  (visual-fill-column-mode -1)

  (when (fboundp 'outline-show-all)
    (outline-show-all))

  (setq wal/org-tree-slide-disabled-modes '())

  (mixed-pitch-mode -1))

(defun wal/org-tree-slide-text-scale ()
  "Hook into `text-scale-mode-hook' for `org-tree-slide'."
  (when (and (boundp 'org-tree-slide-mode) org-tree-slide-mode)
    (wal/org-tree-slide-play)))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package org-tree-slide
  :wal-ways nil

  :after org

  :hook
  ((org-tree-slide-play . wal/org-tree-slide-play)
   (org-tree-slide-stop . wal/org-tree-slide-stop)
   (text-scale-mode . wal/org-tree-slide-text-scale))

  :init
  ;; Insert new group after "Visibility".
  (transient-append-suffix 'wal/org-mode-dispatch '(0 2)
    ["Presentation"
     ("p" "present" org-tree-slide-mode)
     ("i" "indent" org-indent-mode)])

  :custom
  (org-tree-slide-never-touch-face t)
  (org-tree-slide-cursor-init nil)
  (org-tree-slide-activate-message "We're on a road to nowhere")
  (org-tree-slide-deactivate-message "Take you here, take you there")
  (org-tree-slide-indicator '(:next "   >>>" :previous "<<<" :content "< Here is where time is on our side >"))

  :bind
  (:map org-tree-slide-mode-map
   ("q" . org-tree-slide-mode) ; To close it again.
   ("n" . org-tree-slide-move-next-tree)
   ("p" . org-tree-slide-move-previous-tree)
   ("i" . text-scale-increase)
   ("d" . text-scale-decrease)
   ("v" . wal/org-tree-slide-toggle-visibility))

  :diminish buffer-face-mode)
#+END_SRC

** Editing

*** org-src
:PROPERTIES:
:UNNUMBERED: t
:END:

Editing source blocks.

#+BEGIN_SRC emacs-lisp
(use-package org-src
  :ensure nil

  :after org

  :init
  (wal/hook org-src-mode ()
    "Hook into function `org-src-mode'."
    (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

  :config
  (wal/append
   'org-src-lang-modes
   '(("dockerfile" . dockerfile)
     ("conf" . conf)
     ("markdown" . markdown)
     ("fish" . fish)))

  (transient-append-suffix 'wal/org-mode-dispatch '(0 0 1)
    '("e" "edit source" org-edit-src-code
      :inapt-if-not org-in-src-block-p))

  :custom
  (org-src-tab-acts-natively nil)
  (org-edit-src-content-indentation 0)
  (org-src-window-setup 'split-window-below)

  :bind
  (:map org-src-mode-map
   ("C-c C-c" . org-edit-src-exit))

  :delight " osc")
#+END_SRC

*** org-capture
:PROPERTIES:
:UNNUMBERED: t
:END:

Capture templates.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/org-capture-find-project-tasks ()
  "Find a project's tasks file.

If the project root cannot be determined, use
`wal/org-directory'. as destination."
  (let ((proj-root (when-let ((current (project-current)))
                     (project-root current))))

    (expand-file-name "tasks.org" (or proj-root org-directory))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package org-capture
  :ensure nil

  :custom
  (org-capture-templates
   `(("c" "current task" plain
      (clock)
      "\n%?\n"
      :empty-lines-before 1)
     ("d" "daily" plain
      (file+olp+datetree ,(concat org-directory "/dailies.org"))
      "%i\n%?")
     ("p" "project task" entry
      (file+headline wal/org-capture-find-project-tasks "Tasks")
      "* TODO %?\n\n%F\n\n%i"
      :empty-lines-before 1)))
  (org-capture-bookmark nil) ; Prevents countless edit buffers since we annotate bookmarks.

  :delight " cap")
#+END_SRC

*** org-refile
:PROPERTIES:
:UNNUMBERED: t
:END:

Configure refiling headings.

#+BEGIN_SRC emacs-lisp
(use-package org-refile
  :ensure nil

  :custom
  ;; Allow refiling in same file up to level 3.
  (org-refile-targets
   '((nil . (:maxlevel . 3))
     (org-agenda-files . (:maxlevel . 2)))))
#+END_SRC

** Other

*** org-babel
:PROPERTIES:
:UNNUMBERED: t
:END:

Convenient (and less safe) source block interaction.

#+BEGIN_SRC emacs-lisp
(use-package ob
  :ensure nil

  :config
  ;; Load a few more languages.
  (wal/append
   'org-babel-load-languages
   '((shell . t)
     (python . t)
     (latex . t)
     (js . t)))

  :custom
  (org-confirm-babel-evalute nil))
#+end_src

*** org-clock
:PROPERTIES:
:UNNUMBERED: t
:END:

You know the drill. Clock in, clock out.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/org-clock-in-switch-to-state (todo-state)
  "Only switch state to IN PROGRESS if TODO-STATE was given."
  (when todo-state
    "IN PROGRESS"))

(defun wal/org-clock-heading ()
  "Render a truncated heading for modeline."
  (when (and (fboundp 'org-link-display-format) (fboundp 'org-get-heading))
    (let ((heading (org-link-display-format
	                (org-no-properties (org-get-heading t t t t)))))

      (wal/truncate heading 12))))

(defun wal/org-clock-in-from-now ()
  "Force `org-clock-in' without continuous logging."
  (defvar org-clock-continuously)
  (let ((org-clock-continuously nil))

    (when (fboundp 'org-clock-in)
      (org-clock-in))))

(defun wal/org-clock-take-note ()
  "Take a note for the currently clocked-in entry."
  (interactive)

  (save-window-excursion
    (org-clock-goto)
    (org-add-note)))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package org-clock
  :ensure nil

  :after org

  :init
  (add-to-list 'org-speed-commands '("N" . wal/org-clock-in-from-now))

  :config
  (with-eval-after-load 'which-key
    (which-key-add-key-based-replacements
      (wal/key-combo-for-leader 'wal/lieutenant ", t")
      "take note"))

  :custom
  ;; We want a continuous, persistent clock.
  (org-clock-idle-time 60)
  (org-clock-continuously t)
  (org-clock-persist t)
  (org-clock-in-switch-to-state 'wal/org-clock-in-switch-to-state)
  (org-clock-in-resume t)
  (org-clock-report-include-clocking-task t)
  (org-clock-out-remove-zero-time-clocks t)

  ;; Truncate overly long tasks.
  (org-clock-heading-function #'wal/org-clock-heading)

  :bind
  (:map wal/misc-map
   ("t" . org-clock-goto)
   ("n" . wal/org-clock-take-note)))
#+END_SRC

*** org-duration
:PROPERTIES:
:UNNUMBERED: t
:END:

Set up durations for a 40-hour week.

#+BEGIN_SRC emacs-lisp
(use-package org-duration
  :ensure nil

  :after org

  :config
  ;; 40h working week, one month of vacation.
  (wal/replace-in-alist
    'org-duration-units
    `(("d" . ,(* 60 8))
      ("w" . ,(* 60 8 5))
      ("m" . ,(* 60 8 5 4))
      ("y" . ,(* 60 8 5 4 11)))))
#+END_SRC

*** org-keys
:PROPERTIES:
:UNNUMBERED: t
:END:

Add some user speed commands.

#+BEGIN_SRC emacs-lisp
(use-package org-keys
  :ensure nil

  :after org

  :custom
  (org-use-speed-commands t)
  (org-return-follows-link t))
#+END_SRC

*** org-modern
:PROPERTIES:
:UNNUMBERED: t
:END:

Modern look.

#+begin_src emacs-lisp
(use-package org-modern
  :wal-ways nil

  :ensure nil

  :hook (org-mode . org-modern-mode)

  :custom
  (org-modern-hide-stars " ")
  (org-modern-star '("â—†" "â—ˆ" "â–º" "â–»" "â–¸" "â–¹" "â€¢")))
#+end_src

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-org)

;;; wal-org.el ends here
#+END_SRC

* Dired
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-dired.el" wal/emacs-config-package-path)
:END:

Run =dired= with =C-x d=.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-dired.el --- Dired. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide Dired packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function dired-read-dir-and-switches "ext:dired.el")
(declare-function consult--buffer-query "ext:consult.el")
(declare-function consult--buffer-state "ext:consult.el")
(declare-function wal/insert-after "wal-func.el")
#+END_SRC

** Packages

*** dired
:PROPERTIES:
:UNNUMBERED: t
:END:

The mother of all buffers. You don't need no tree views.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/dired-from-home (dirname &optional switches)
  "Find DIRNAME local to HOME directory.
Uses the same optional SWITCHES."
  (interactive
    (let ((default-directory (expand-file-name "~/")))

      (dired-read-dir-and-switches "")))

  (pop-to-buffer-same-window (dired-noselect dirname switches)))

(defun wal/image-dired ()
  "Run `image-dired' in the `default-directory'."
  (interactive)

  (image-dired (expand-file-name default-directory)))

(defun wal/dired-buffer-p (buffer)
  "Check if buffer BUFFER is a Dired buffer."
  (with-current-buffer buffer
    (derived-mode-p 'dired-mode)))

(defun wal/consult-dired-buffer--query ()
  "Get Dired buffer names."
  (consult--buffer-query
   :sort 'visibility
   :as #'buffer-name
   :predicate #'wal/dired-buffer-p))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil

  :init
  (wal/hook dired-mode
    "Hook into `dired-mode'."
    :captain t)

  :config
  ;; We aren't scared of finding alternate files.
  (put 'dired-find-alternate-file 'disabled nil)

  (wal/transient-define-prefix-once wal/dired-mode-dispatch ()
    "Access Dired commands."
    [["Utility"
      ("q" "query replace" dired-do-query-replace-regexp)
      ("t" "create empty file" dired-create-empty-file)]
     ["Other"
      ("v" "show images" wal/image-dired)]])

  (with-eval-after-load 'consult
    (defvar wal/consult--source-dired-buffer
      (list :name "Dired Buffer"
            :narrow ?d
            :category 'buffer
            :state #'consult--buffer-state
            :history 'buffer-name-history
            :face 'font-lock-keyword-face
            :items #'wal/consult-dired-buffer--query))

    (wal/insert-after
     'consult-buffer-sources
     'consult--source-buffer
     wal/consult--source-dired-buffer))

  :custom
  (dired-listing-switches "-lah --group-directories-first")
  (dired-auto-revert-buffer t)
  (dired-kill-when-opening-new-dired-buffer t))
#+END_SRC

*** dired-filter
:PROPERTIES:
:UNNUMBERED: t
:END:

Hit =/= to filter in dired buffers.

#+BEGIN_SRC emacs-lisp
(use-package dired-filter
  :defer 1
  :after dired

  :delight " drf")
#+END_SRC

*** diredfl
:PROPERTIES:
:UNNUMBERED: t
:END:

Highlighting in dired buffers.

#+BEGIN_SRC emacs-lisp
(use-package diredfl
  :wal-ways nil

  :defer 1
  :after dired

  :config
  (diredfl-global-mode))
#+END_SRC

*** wdired
:PROPERTIES:
:UNNUMBERED: t
:END:

Did you know you can edit =dired= buffers using =C-x C-q=?

#+BEGIN_SRC emacs-lisp
(use-package wdired
  :ensure nil

  :custom
  (wdired-allow-to-change-permissions t)

  :bind
  (:map wdired-mode-map
   ("C-c C-k" . wdired-abort-changes)))
#+END_SRC

*** all-the-icons-dired
:PROPERTIES:
:UNNUMBERED: t
:END:

Show file icons.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :wal-ways nil

  :after all-the-icons

  :hook (dired-mode . all-the-icons-dired-mode)

  :custom
  (all-the-icons-dired-monochrome nil)

  :diminish)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-dired)

;;; wal-dired.el ends here
#+END_SRC

* Terminal
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-terminal.el" wal/emacs-config-package-path)
:END:

#+BEGIN_QUOTE
I am convinced that we are in a terminal process.
â€” E. P. Thompson
#+END_QUOTE

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-terminal.el --- Terminal. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide terminal packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function project-buffers "ext:project.el")
(declare-function vterm-mode "ext:vterm.el")
(declare-function vterm-send-return "ext:vterm.el")
(declare-function vterm-send-string "ext:vterm.el")
#+END_SRC

** Packages

*** with-editor
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package with-editor
  :custom
  (with-editor-mode-lighter " w/e"))
#+END_SRC

*** vterm
:PROPERTIES:
:UNNUMBERED: t
:END:

If you want a fully-fledged terminal emulator[fn:13].

Some commands require an additional =C-c=:

+ =C-c C-c= to send =C-c=.
+ =C-c C-g= to send =C-g=.
+ =C-c C-u= to send =C-u=.
+ =C-c C-t= to enter/exit =copy-mode=.

**** Utility

#+BEGIN_SRC emacs-lisp
(defconst wal/vterm-prefix "VTerm")

(defun wal/vterm-run (cmd &optional action)
  "Run CMD in `vterm' terminal and switch to it.

Optionally, a buffer display action ACTION can be passed of the
form (FUNCTIONS . ALIST). See `display-buffer' for more
information."
  (interactive "sEnter command: ")

  (unless (executable-find (car (split-string-shell-command cmd)))
    (user-error (format "Unknown command '%s'" cmd)))

  (let* ((buffer (seq-find
                  (lambda (it)
                    (string-match cmd (buffer-name it)))
                  (buffer-list))))

    (if buffer
        (display-buffer buffer action)
      (with-current-buffer (get-buffer-create (format "*vterm-run-%s*" cmd))
        (vterm-mode)
        (vterm-send-string cmd)
        (vterm-send-return)
        (display-buffer (current-buffer) action)))))

(defun wal/vterm (&optional force-new)
  "Get a `vterm' buffer.

If called from a project buffer, this only creates a `vterm'
buffer if one doesn't exist yet (unless called with
FORCE-NEW/`universal-argument')."
  (interactive "P")

  (if-let* ((cont (and (not force-new)
                       (project-current)))
            (buffers (project-buffers (project-current)))
            (project-vterm
             (cl-find-if
              #'(lambda (it)
                  (and (provided-mode-derived-p
                        (buffer-local-value 'major-mode it)
                        'vterm-mode)
                       (string-match-p
                        wal/vterm-prefix
                        (buffer-name it))))
              buffers)))
      (switch-to-buffer project-vterm)
    (vterm)))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package vterm
  :wal-ways nil

  :hook
  (vterm-mode . with-editor-export-git-editor)

  :init
  (wal/hook vterm-mode ()
    "Hook into `vterm-mode'.

  This sets the query on exit flag to nil for the vterm process."
    (when-let* ((buf (current-buffer))
                (proc (get-buffer-process buf)))

      (set-process-query-on-exit-flag proc nil)))

  :custom
  (vterm-buffer-name-string (concat wal/vterm-prefix ": %s"))
  (vterm-max-scrollback 10000)

  :general
  (wal/major "t" '(wal/vterm :wk "vterm"))

  :delight
  (vterm-copy-mode " vcp"))
#+END_SRC

** Eshell

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack eshell
  "Make eshell feel like a feature-complete shell."
  :packages (eshell-syntax-highlighting))
#+END_SRC

*** eshell
:PROPERTIES:
:UNNUMBERED: t
:END:

Set up =eshell=. I like the idea of it but I don't really use it.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/instead-truncate-buffer (&rest _r)
  "Advise to truncate buffer."
  (defvar eshell-buffer-maximum-lines)
  (let ((eshell-buffer-maximum-lines 0))

    (when (fboundp 'eshell-truncate-buffer)
      (eshell-truncate-buffer))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package eshell
  :ensure nil

  :hook
  ((eshell-mode . with-editor-export-editor)
   (eshell-mode . with-editor-export-git-editor))

  :config
  (advice-add
   'eshell/clear :override
   #'wal/instead-truncate-buffer)

  :general
  (wal/general "e" '(eshell :wk "eshell")))
#+END_SRC

*** eshell-syntax-highlighting
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package eshell-syntax-highlighting
  :wal-ways nil

  :ensure nil

  :hook (eshell-mode . eshell-syntax-highlighting-mode))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-terminal)

;;; wal-terminal.el ends here
#+END_SRC

* Version Control
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-vc.el" wal/emacs-config-package-path)
:END:

I'm becoming an old git.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-vc.el --- Version control. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide version control packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))
#+END_SRC

** Magit

Forget remembering =git= commands, use =transient=.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack magit
  "Support pull requests and code reviews."
  :packages (forge code-review))
#+END_SRC

*** magit
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands (wal/magit-dispatch wal/univ-magit-status)

  :init
  (wal/univ magit-status wal/magit-dispatch)

  :config
  (wal/transient-define-prefix-once wal/magit-dispatch ()
    "Call `magit' commands in a `magit'-y way."
    [["Core"
      ("m" "status" magit-status)
      ("q" "status (quick)" magit-status-quick)
      ("b" "blame" magit-blame)]
     ["Files"
      ("f" "find" magit-find-file)
      ("o" "find other window" magit-find-file-other-window)]
     ["Diff"
      ("d" "file" magit-diff-buffer-file)
      ("r" "range" magit-diff-range)]
     ["Other"
      ("x" "run" magit-run)
      ("c" "clone" magit-clone)]])

  :wal-bind
  ("m" . wal/univ-magit-status)

  :custom
  (magit-blame-mode-lighter " mbl")
  (magit-bury-buffer-function 'magit-restore-window-configuration))
#+END_SRC

*** forge
:PROPERTIES:
:UNNUMBERED: t
:END:

Deal with pull/merge requests.

#+BEGIN_SRC emacs-lisp
(use-package forge
  :wal-ways nil

  :ensure nil

  :demand
  :after magit)
#+END_SRC

*** code-review
:PROPERTIES:
:UNNUMBERED: t
:END:

Review pull/merge requests.

#+BEGIN_SRC emacs-lisp
(use-package code-review
  :wal-ways nil

  :ensure nil

  :demand
  :after forge)
#+END_SRC

** Other

*** git-timemachine
:PROPERTIES:
:UNNUMBERED: t
:END:

If you want to go back in time and point fingers at the progenitors of
doom.

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :wal-ways nil

  :config
  (transient-append-suffix 'wal/magit-dispatch #'magit-clone
    '("t" "time machine" git-timemachine-toggle))

  :defer 2
  :after magit

  :delight " gtm")
#+END_SRC

*** git-modes
:PROPERTIES:
:UNNUMBERED: t
:END:

Syntax highlighting.

#+BEGIN_SRC emacs-lisp
(use-package git-modes
  :mode (("/\\.npmignore\\'" . gitignore-mode)
         ("/\\.dockerignore" . gitignore-mode))

  :init
  (wal/hook gitignore-mode
    "Hook into `gitignore-mode'."
    :messages '("I don't think I know you")))
#+END_SRC

*** smerge-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

When resolving conflicts, using =ours= and =theirs= should be easy.

#+BEGIN_SRC emacs-lisp
(use-package smerge-mode
  :ensure nil

  :config
  (with-no-warnings
    (defhydra wal/smerge (:hint nil :foreign-keys warn)
      "
%s`w/hew Resolve conflict: _u_pper, _l_ower or _a_ll %s`w/hs _n_ext or _p_revious
"
      ("p" smerge-prev)
      ("n" smerge-next)
      ("u" smerge-keep-upper)
      ("l" smerge-keep-lower)
      ("a" smerge-keep-all)
      ("q" nil)))

  (with-eval-after-load 'which-key
    (which-key-add-key-based-replacements "C-c g" "smerge"))

  :bind
  (:map smerge-basic-map
   ("g" . wal/smerge/body))

  :bind-keymap
  (("C-c g" . smerge-basic-map))

  :delight " smg")
#+END_SRC

*** ediff
:PROPERTIES:
:UNNUMBERED: t
:END:

Use a single frame and split horizontally when diffing.

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :ensure nil

  :custom
  (ediff-window-setup-function #'ediff-setup-windows-plain) ; Single frame.
  (ediff-split-window-function #'split-window-horizontally))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-vc)

;;; wal-vc.el ends here
#+END_SRC

* Languages
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-lang.el" wal/emacs-config-package-path)
:END:

Let's greet the world.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-lang.el --- Languages. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide Emacs settings/configurations.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function prettier--quit-all-processes "ext:prettier.el")
(declare-function wal/transient-grab "wal-key-bindings.el")
(declare-function wdb/side "wal-func.el")

(defvar prettier-processes)

(defgroup wal-lang nil
  "Change language-specific settings."
  :group 'wal
  :tag "Langauge")
#+END_SRC

** Elixir

Bitches brew.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack elixir
  "For Elixir developers."
  :packages (elixir-mode))
#+END_SRC

*** elixir-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package elixir-mode
  :wal-ways nil

  :ensure nil

  :hook (elixir-mode . abbrev-mode)

  :init
  (wal/hook elixir-mode
    "Hook into `elixir-mode'."
    :lsp t
    :messages '("Mixin' potions" "A hex on you"))

  :config
  (define-abbrev-table 'elixir-mode-abbrev-table '(("p" "|>")))

  (ligature-set-ligatures 'elixir-mode '("|>" "->" "<-" "=>"
                                         "::" "<>" "#{" "\\\\"
                                         "===" "!==" "..")))
#+END_SRC

** C/C++

I want to be ready for =jai=.

*** c++-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package cc-mode
  :ensure nil

  ;; I don't use C, no need to (often incorrectly) guess.
  :mode ("\\.h\\'" . c++-mode)

  :init
  (wal/hook c++-mode
    "Hook into `c++-mode'."
    :lsp t
    :captain t
    :messages '("Make tidy! Make clean!" "Serenity now!"))

  :config
  ;; Eliminate conflicts with `delight'.
  (advice-add 'c-update-modeline :override #'ignore)

  (wal/transient-define-prefix-once wal/c++-mode-dispatch ()
    "Access `c++-mode' commands."
    [["Style"
      ("s" "set" c-set-style)
      ("g" "guess (using buffer)" c-guess-buffer)]])

  (ligature-set-ligatures 'c++-mode '("::" "->"))
  (ligature-set-ligatures 'c-mode '("->")))
#+END_SRC

** Rust

Consider the lobster.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack rust
  "For Rust developers."
  :packages (rust-mode cargo))
#+END_SRC

*** rust-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Follow [[https://rust-analyzer.github.io/manual.html#rust-analyzer-language-server-binary][these instructions]] to download the =rust-analyzer= binary.

#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :if (executable-find "cargo")
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook rust-mode
    "Hook into `rust-mode'."
    :lsp t
    :captain t
    :messages '("Consider the lobster"))

  :config
  (wal/transient-define-prefix-once wal/rust-mode-dispatch ()
    "Access `rust-mode' commands."
    [["Commands"
      ("c" "compile" rust-compile)
      ("r" "run" rust-run)]
     ["Test"
      ("t a" "test all" rust-test)
      ("t c" "current" cargo-process-current-test)
      ("t f" "file" cargo-process-current-file-tests)]])

  (ligature-set-ligatures 'rust-mode '("///" "->" "=>" "::"
                                       ".." "#[")))
#+END_SRC

*** cargo
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package cargo
  :wal-ways nil

  :ensure nil

  :demand
  :after rust-mode)
#+END_SRC

** Python

Hide those details from me.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack python
  "Virtual environment, isort, poetry and notebook support."
  :packages (pet python-isort python-black)
  :extras (lsp-pyright ein poetry))
#+END_SRC

*** python
:PROPERTIES:
:UNNUMBERED: t
:END:

Use snake when you can't =make=.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/in-python-project-p (&optional marker-file)
  "Check if we're currently in a Python project.

Unless another MARKER-FILE is provided, this will use the usual
TOML."
  (and-let* ((marker (or marker-file "pyproject.toml"))
             (current default-directory)
             (project-directory (locate-dominating-file current marker)))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package python
  :ensure nil

  :init
  (wal/hook python-mode
    "Hook into `python-mode'."
    :captain t
    :lsp t
    :corfu (0.1 1)
    :lsp-ignores
    '("[/\\\\]\\.pytype\\'"
      "[/\\\\]__pycache__\\'"
      "[/\\\\]\\.pytest_cache\\'")
    :messages '("Watch out for snakes!" "Vegetation, aggravation")

    (setq-local comment-inline-offset 2))

  :config
  ;; Load default `dap-mode' templates.
  (with-eval-after-load 'dap-mode
    (require 'dap-python))

  ;; Show inferior shell at the bottom.
  (wdb/side 'inferior-python-mode)

  (wal/transient-define-prefix-once wal/python-mode-dispatch ()
    "Access `python-mode' commands."
    [["Inferior shell"
      ("i r" "send region" python-shell-send-region)
      ("i b" "send buffer" python-shell-send-buffer)
      ("i f" "send file" python-shell-send-file)]
     ["Commands"
      ("r" "run shell" run-python)]])

  (ligature-set-ligatures 'python-mode '("->" "__"))

  :custom
  (python-indent-guess-indent-offset nil))
#+END_SRC

*** lsp-pyright
:PROPERTIES:
:UNNUMBERED: t
:END:

Did Microsoft do the right thing?

*** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/lsp-pyright-install-stubs ()
  "Install the pyright stubs."
  (interactive)

  (unless (wal/in-python-project-p)
    (user-error "You're not in a Python project!"))

  (when-let* ((cur (project-current))
              (dir (project-root cur))
              (stub-dir (expand-file-name "typings" dir)))

    (if (file-directory-p stub-dir)
        (user-error "Stubs directory already exists!")
      (make-directory stub-dir))

    (let ((cmd (concat "git clone https://github.com/microsoft/python-type-stubs "
                       stub-dir))
          (buffer (get-buffer-create "*Pyright Stubs*")))

      (display-buffer-in-side-window buffer '((side . bottom)))
      (async-shell-command cmd buffer))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package lsp-pyright
  :wal-ways nil

  :ensure nil

  :demand
  :after python)
#+END_SRC

*** python-isort
:PROPERTIES:
:UNNUMBERED: t
:END:

Sort with =isort=.

#+begin_src emacs-lisp
(use-package python-isort
  :wal-ways nil

  :ensure nil

  :after python

  :init
  (transient-append-suffix 'wal/python-mode-dispatch '(0 1 -1)
    '("s" "isort" python-isort-buffer)))
#+end_src

*** python-black
:PROPERTIES:
:UNNUMBERED: t
:END:

Blacken buffers.

#+BEGIN_SRC emacs-lisp
(use-package python-black
  :wal-ways nil

  :ensure nil

  :after python

  :init
  (transient-append-suffix 'wal/python-mode-dispatch '(0 1 -1)
    '("b" "black" python-black-buffer)))
#+END_SRC

*** ein
:PROPERTIES:
:UNNUMBERED: t
:END:

Work with Jupyter notebooks.

#+BEGIN_SRC emacs-lisp
(use-package ein
  :wal-ways nil

  :ensure nil

  :after python

  :init
  (transient-append-suffix 'wal/python-mode-dispatch '(0 1 -1)
    '("e" "ein" ein:run)))
#+END_SRC

*** Virtual Envs

It takes more than one environment to make sense of Python code.

**** pet
:PROPERTIES:
:UNNUMBERED: t
:END:

Takes care[fn:14] of all your virtual environment needs.

***** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/otherwise-return-argument (arg)
  "Return ARG if original function returned nil."
  arg)
#+END_SRC

***** Configuration

#+BEGIN_SRC emacs-lisp
(use-package pet
  :if (and (executable-find "dasel")
           (executable-find "sqlite3"))

  :wal-ways nil

  :ensure nil

  :hook (python-mode . pet-mode)

  :config
  (advice-add
   'pet-executable-find :after-until
   #'wal/otherwise-return-argument)

  :delight " pet")
#+END_SRC

**** poetry
:PROPERTIES:
:UNNUMBERED: t
:END:

=poetry= is like =npm= for Python, it's why it rhymes.

#+BEGIN_SRC emacs-lisp
(use-package poetry
  :wal-ways nil

  :ensure nil

  :after python

  :init
  (transient-append-suffix 'wal/python-mode-dispatch '(0 1 -1)
    '("p" "poetry" poetry)))
#+END_SRC

**** pyvenv

#+BEGIN_SRC emacs-lisp
(use-package pyvenv
  :wal-ways nil

  :ensure nil

  :after python

  :init
  (transient-append-suffix 'wal/python-mode-dispatch '(0 1 -1)
    '("v" "activate venv" pyvenv-activate)))
#+END_SRC

** Lisp

The philosopher's choice.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack lisp
  "For (common-) Lisp developers using sbcl."
  :packages (puni)
  :extras (slime))

(wal/define-expansion-pack clojure
  "For Clojure developers using cider with lein."
  :packages (clojure-mode cider))
#+END_SRC

*** puni
:PROPERTIES:
:UNNUMBERED: t
:END:

Deal with the parens.

#+BEGIN_SRC emacs-lisp
(use-package puni
  :wal-ways nil

  :ensure nil

  :hook (lisp-data-mode . puni-mode)

  :init
  ;; This package doesn't have a lighter.
  (add-to-list 'minor-mode-alist (list 'puni-mode " pni"))

  :bind
  (:map puni-mode-map
   ("C-M-." . puni-barf-forward)
   ("C-M-," . puni-barf-backward)

   ("C-M-'" . puni-slurp-forward)
   ("C-M-;" . puni-slurp-backward)

   ("C-M-<" . puni-squeeze)
   ("C-M->" . puni-splice)

   ("C-M-/" . puni-convolute)

   ("C-M-(" . puni-wrap-round)
   ("C-M-[" . puni-wrap-angle)
   ("C-M-{" . puni-wrap-curly)))
#+END_SRC

*** elisp-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package elisp-mode
  :ensure nil

  :init
  (wal/hook emacs-lisp-mode
    "Hook into `emacs-lisp-mode'."
    :captain t
    :messages '("So it's just a bunch of lists?" "List your lambdas")

    (prettify-symbols-mode)
    (flycheck-mode 1))

  :config
  (wal/transient-define-prefix-once wal/emacs-lisp-mode-dispatch ()
    "Access `elisp' commands."
    [["Utility"
      ("p" "check parens" check-parens)
      ("d" "edebug function" edebug-defun)
      ("h" "helpful" helpful-at-point)
      ("m" "expand macro" emacs-lisp-macroexpand)]])

  (with-eval-after-load 'puni
    (transient-append-suffix 'wal/emacs-lisp-mode-dispatch '(0 0 -1)
      '("p" "puni" puni-mode))))
#+END_SRC

*** lisp-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package lisp-mode
  :ensure nil

  :init
  (wal/hook common-lisp-mode
    "hook into `common-lisp-mode'."
    :captain t)

  (wal/hook lisp-data-mode
    "Hook into `lisp-data-mode."
    :shallow t
    :corfu (0.1 1))

  :config
  (with-eval-after-load 'slime
    (wal/transient-define-prefix-once wal/common-lisp-mode-dispatch ()
      "Access `slime' actions."
      [["Slime"
        ("s" "slime" slime-mode)
        ("r" "open REPL" slime)]]))

  (ligature-set-ligatures 'lisp-data-mode '(";;")))
#+END_SRC

*** clojure-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Get some closure.

#+begin_src emacs-lisp
(use-package clojure-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook clojure-mode
    "Hook into `clojure-mode'."
    :lsp t
    :captain t
    :messages '("Cider brew"))

  :config
  (with-eval-after-load 'cider
    (wal/transient-define-prefix-once wal/clojure-mode-dispatch ()
      "Access `clojure-mode' commands."
      [["Cider"
        ("r" "repl" cider-jack-in)
        ("n" "set namespace" cider-repl-set-ns)]]))

  (ligature-set-ligatures 'clojure-mode '(";;" "->" "->>")))
#+end_src

*** cider
:PROPERTIES:
:UNNUMBERED: t
:END:

Can't have closure without REPL.

#+begin_src emacs-lisp
(use-package cider
  :wal-ways nil

  :ensure nil

  :demand
  :after clojure-mode

  :config
  (wdb/side 'cider-repl-mode)

  :custom
  (cider-jack-in-default 'lein))
#+end_src

*** slime
:PROPERTIES:
:UNNUMBERED: t
:END:

Check out the [[https://lispcookbook.github.io/cl-cookbook/getting-started.html][lisp cookbook]] for =slime=.

#+BEGIN_SRC emacs-lisp
(use-package slime
  :wal-ways nil

  :ensure nil

  :demand
  :after lisp-mode

  :config
  (when (executable-find "sbcl")
    (setq inferior-lisp-program "sbcl"))

  (slime-setup '(slime-fancy slime-quicklisp slime-asdf))

  :delight " slm")
#+END_SRC

** JavaScript

Can we have =deno= instead of =node=?

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack javascript
  "For Node.js developers."
  :packages (add-node-modules-path prettier)
  :extras (typescript-mode))
#+END_SRC

*** js
:PROPERTIES:
:UNNUMBERED: t
:END:

**** Utility

#+BEGIN_SRC emacs-lisp
(defvar wal/jest-compilation-error-regexp
  '(jest
    "^[[:blank:]]+at [^\n\r]+ (\\([^\n\r]+\\(?:.spec\\|.test\\)?.\\(?:js\\|jsx\\)\\):\\([0-9]+\\):\\([0-9]+\\))$"
    1 2 3)
  "Regular expression used for jest errors.")
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package js
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook js-mode
    "Hook into `js-mode'."
    :messages '("NaN !== NaN" "Null falsy values or undefined")
    :captain t
    :tabs t
    :lsp t
    :corfu (0.1 2)

    (setq-local compilation-error-screen-columns nil)

    (when (fboundp 'add-node-modules-path)
      (add-node-modules-path))

    (prettier-mode))

  :config
  ;; Load default `dap-mode' templates.
  (with-eval-after-load 'dap-mode
    (require 'dap-node))

  (wal/transient-define-prefix-once wal/js-mode-dispatch ()
    "Access JS commands."
    [["Actions"
      ("c" "context" js-syntactic-context)]])

  (ligature-set-ligatures 'js-mode '("=>" "!==" "===" "!!"))

  ;; Add regular expression for jest errors.
  (add-to-list 'compilation-error-regexp-alist 'jest)
  (add-to-list
   'compilation-error-regexp-alist-alist
   wal/jest-compilation-error-regexp)

  :bind
  (:map js-mode-map
   ("M-." . nil)))
#+END_SRC

*** typescript-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Please use TypeScript.

#+BEGIN_SRC emacs-lisp
(use-package typescript-mode
  :wal-ways nil

  :ensure nil

  :mode "\\.ts\\(x\\)?\\'"

  :init
  (wal/hook typescript-mode
    "Hook into `typescript-mode'."
    :lsp t
    :tabs t
    :messages '("This is any, that is any, everything is any!")

    (add-node-modules-path)))
#+END_SRC

*** add-node-modules-path
:PROPERTIES:
:UNNUMBERED: t
:END:

Allow accessing a project's =node_modules=.

#+BEGIN_SRC emacs-lisp
(use-package add-node-modules-path
  :wal-ways nil

  :ensure nil)
#+END_SRC

*** prettier
:PROPERTIES:
:UNNUMBERED: t
:END:

Prettify your ugly JavaScript.

**** Utility

#+BEGIN_SRC emacs-lisp
(defvar wal/prettier-timer nil)

(defun wal/prettier-refresh ()
  "Force re-loading configuration and apply."
  (interactive)

  (when wal/prettier-timer
    (user-error "Refresh timer already running"))

  (prettier--quit-all-processes)

  (setq wal/prettier-timer
        (run-with-timer 0.1 0.1
                        (lambda ()
                          (when (zerop (hash-table-count prettier-processes))
                            (cancel-timer wal/prettier-timer)
                            (setq wal/prettier-timer nil)
                            (prettier-prettify)
                            (message "Refresh done"))))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package prettier
  :wal-ways nil

  :ensure nil

  :defer 1
  :after js

  :config
  (transient-append-suffix 'wal/js-mode-dispatch '(0 0 0)
    '("p" "prettier" prettier-prettify)))
#+END_SRC

** Go

Ogling new languages.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack go
  "For Go developers."
  :packages (go-mode))
#+END_SRC

*** go-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Setup for LSP.

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook go-mode
    "Hook into `go-mode'."
    :lsp t
    :messages '("What does Sonic say?" "Put a golang under your tongue")))
#+END_SRC

** Scripting

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack fish
  "For fish shell users."
  :packages (fish-mode))

(wal/define-expansion-pack cli
  "For CLI power users."
  :packages (crontab-mode))
#+END_SRC

*** sh-script
:PROPERTIES:
:UNNUMBERED: t
:END:

Bash your head in!

#+BEGIN_SRC emacs-lisp
(use-package sh-script
  :ensure nil

  :init
  (wal/hook sh-mode
    "Hook into `sh-mode'."
    :messages '("Sh..sh..h.." "Bash your head in"))

  :custom
  (sh-basic-offset 2)
  (sh-indent-after-continuation nil))
#+END_SRC

*** crontab-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Sometimes you have to deal with things at their time.

#+BEGIN_SRC emacs-lisp
(use-package crontab-mode
  :wal-ways nil

  :ensure nil)
#+END_SRC

*** fish-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Support =fish= functions.

#+BEGIN_SRC emacs-lisp
(use-package fish-mode
  :wal-ways nil

  :ensure nil

  :custom
  (fish-indent-offset 2))
#+END_SRC

*** conf-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package conf-mode
  :ensure nil

  :hook (conf-mode . wal/prog-like))
#+END_SRC

** Markup

Sometimes things that don't do things need to look nice.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack markdown
  "For MD users."
  :packages (markdown-mode))
#+END_SRC

*** markdown-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/markdown-view ()
  "Toggle between different markdown views."
  (interactive)

  (cond
   ((eq major-mode 'markdown-mode)
    (markdown-view-mode)
    (mixed-pitch-mode 1))
   ((eq major-mode 'markdown-view-mode)
    (markdown-mode)
    (mixed-pitch-mode -1))
   (t
    (error "Can't change view outside of markdown modes"))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook markdown-mode
    "Hook into `markdown-mode'."
    :captain t)

  :config
  (wal/transient-define-prefix-once wal/markdown-mode-dispatch ()
    "Access `markdown-mode' commands."
    [["View"
      ("v" "toggle view" wal/markdown-view)]])

  :bind
  (:map markdown-mode-map
   ("M-<up>" . markdown-move-list-item-up)
   ("M-<down>" . markdown-move-list-item-down)))
#+END_SRC

** Flutter

Yes, you need to install *Android Studio* for some reason.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack flutter
  "Dart major mode and LSP package."
  :packages (dart-mode lsp-dart))
#+END_SRC

*** dart-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package dart-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook dart-mode
    "Hook into `dart-mode'."
    :lsp t
    :captain t
    :messages '("Bull's eye!"))

  :config
  (ligature-set-ligatures 'dart-mode '("=>" "///" ".?" "??"
                                       "??=" "..")))
#+END_SRC

*** lsp-dart
:PROPERTIES:
:UNNUMBERED: t
:END:

LSP support for Dart.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/find-dart-flutter-sdk-dir ()
  "Find the Dart Flutter SDK directory."
  (when-let* ((flutter-bin (executable-find "flutter"))
              (sdk-dir (string-trim (shell-command-to-string "flutter sdk-path"))))

    sdk-dir))

(defun wal/find-dart-sdk-dir ()
  "Find the Dart SDK directory."
  (when-let* ((flutter-sdk-dir (wal/find-dart-flutter-sdk-dir)))

    (expand-file-name "bin/cache/dart-sdk" flutter-sdk-dir)))

(defun wal/lsp-dart-set-process-query-on-exit-flag ()
  "Set the query-on-exit flag to nil for the Dart language server."
  (defvar lsp-dart-flutter-daemon-buffer-name)
  (when-let (proc (get-buffer-process lsp-dart-flutter-daemon-buffer-name))

    (set-process-query-on-exit-flag proc nil)))

(defun wal/lsp-dart-service-uri ()
  "Get the service URI (needed for devtools)."
  (interactive)

  (condition-case err
      (when (fboundp 'lsp-workspace-get-metadata)
        (let ((uri (lsp-workspace-get-metadata "devtools-vm-service-uri")))

          (kill-new uri)
          (message "Service URI (%s) copied to kill ring" uri)))
    (error
      (message "Couldn't get service URI: %s" (error-message-string err)))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package lsp-dart
  :if (or (executable-find "flutter") (executable-find "dart"))
  :wal-ways nil

  :ensure nil

  :after lsp-mode

  :config
  ;; Kill process without a prompt.
  (add-hook
   'lsp-after-initialize-hook
   #'wal/lsp-dart-set-process-query-on-exit-flag)

  ;; Display at the bottom.
  (wdb/side "\\*Flutter")

  (wal/transient-define-prefix-once wal/dart-mode-dispatch ()
    "Access flutter commands."
    [["Hot-reloading"
      ("R" "restart" lsp-dart-dap-flutter-hot-restart)
      ("r" "reload" lsp-dart-dap-flutter-hot-reload)]
     ["Test"
      ("t c" "current" lsp-dart-run-test-at-point)
      ("t a" "all" lsp-dart-run-all-tests)]
     ["Devtools"
      ("d" "open" lsp-dart-open-devtools)
      ("u" "get service URI" wal/lsp-dart-service-uri)]])

  :custom
  (lsp-dart-flutter-sdk-dir (wal/find-dart-flutter-sdk-dir))
  (lsp-dart-sdk-dir (wal/find-dart-sdk-dir))
  ;; Run `lsp-dart-dap-setup' once to install debugger.
  (lsp-dart-dap-use-sdk-debugger nil))
#+END_SRC

** Java

It's a =JavaEmacsPackageConfigurationSectionFactory=, mate.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack java
  "Java expansions."
  :packages (lsp-java log4j-mode))
#+END_SRC

*** java-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

For some reason, this is also defined in =cc-mode=.

#+BEGIN_SRC emacs-lisp
(use-package cc-mode
  :ensure nil

  :init
  (wal/hook java-mode
    "Hook into `java-mode'."
    :lsp t
    :lsp-ignores '("[/\\\\]\\.gradle\\'")
    :captain t
    :messages '("Mmmh ... maven"))

  :config
  (ligature-set-ligatures 'java-mode '("::" "->")))
#+END_SRC

*** lsp-java
:PROPERTIES:
:UNNUMBERED: t
:END:

LSP integration.

**** Utility

#+begin_src emacs-lisp
(defun wal/with-bash-shell (fun &rest args)
  "Run FUN with ARGS in bash shell."
  (let ((shell-file-name "/bin/bash"))

    (apply fun args)))

(defun wal/java-test-dwim ()
  "Run or debug test or class depending on ARGS."
  (interactive)

  (let* ((mode (wal/transient-grab "mode"))
         (scope (wal/transient-grab "scope"))
         (fun (intern (format "dap-java-%s-test-%s" mode scope))))

    (transient-set)

    (call-interactively fun)))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package lsp-java
  :wal-ways nil

  :ensure nil

  :config
  (require 'dap-java)

  ;; Use bash shell for JUnit commands.
  (wal/advise-many
   'wal/with-bash-shell :around
   '(dap-java-debug-test-class
     dap-java-debug-test-method
     dap-java-run-test-class
     dap-java-run-test-method))

  (wal/transient-define-prefix-once wal/java-mode-dispatch ()
    "Access `java-mode' commands."
    :value '("--mode=run" "--scope=method")

    ["Test"
     ("m" "mode" "--mode=" :choices (run debug) :always-read t)
     ("s" "scope" "--scope=" :choices (class method) :always-read t)
     ""
     ("t" "test" wal/java-test-dwim)])

  :custom
  (lsp-java-format-on-type-enabled nil) ; Suggested fix for failing completion.
  (lsp-java-references-code-lens-enabled t)
  (lsp-java-implementations-code-lens-enabled t)
  (lsp-java-signature-help-enabled nil))
#+end_src

*** log4j-mode

#+BEGIN_SRC emacs-lisp
(use-package log4j-mode
  :wal-ways nil

  :ensure nil

  :mode ("\\.log\\'" . log4j-mode)

  :custom-face
  (log4j-font-lock-debug-face ((t (:foreground unspecified :inherit (shadow)))))
  (log4j-font-lock-info-face ((t (:foreground unspecified :inherit (success)))))
  (log4j-font-lock-error-face ((t (:foreground unspecified :inherit (error)))))
  (log4j-font-lock-warn-face ((t (:foreground unspecified :inherit (warning))))))
#+END_SRC

** PHP

The elephant in the room.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack php
  "Major mode and web mode for templates."
  :packages (php-mode))
#+END_SRC

*** php-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package php-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook php-mode
    "Hook into `php-mode'."
    :lsp t
    :messages '("Stampy, no!"))

  :config
  (require 'dap-php) ; Run `dap-php-setup'.

  (wdb/side "\\*Php SOE")

  (ligature-set-ligatures 'php-mode '("::" "=>" "->" "??"
                                      "__" "<>" "!==" "<=>"
                                      "===")))
#+END_SRC

** Web

Does anyone actually like web development?

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack web
  "For web developers."
  :packages (yaml-mode jsonian)
  :extras (pug-mode po-mode web-mode))
#+END_SRC

*** jsonian
:PROPERTIES:
:UNNUMBERED: t
:END:

The only way to store strings, JSON.

#+BEGIN_SRC emacs-lisp
(use-package jsonian
  :wal-ways nil

  :ensure nil

  :after so-long

  :mode (("\\.arb\\'" . jsonian-mode)
         ("\\.\\([a-zA-Z]\\)+rc\\'" . jsonian-mode))

  :init
  (wal/hook jsonian-mode
    "Hook into `jsonian-mode'."
    :tabs t
    :captain t
    :messages '("JSON ...? JSON?! JSON!!")

    (flycheck-mode 1))

  :config
  ;; Integrate with `flycheck' and `so-long-mode'.
  (jsonian-no-so-long-mode)
  (with-eval-after-load 'flycheck
    (jsonian-enable-flycheck))

  (wal/transient-define-prefix-once wal/jsonian-mode-dispatch ()
    "Access `jsonian-mode' commands."
    [["Jsonian"
      ("f" "find" jsonian-find)
      ("e" "edit" jsonian-edit-string)]]))
#+END_SRC

*** mhtml-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package mhtml-mode
  :ensure nil

  :init
  (wal/hook mhtml-mode
    "Hook into `mhtml-mode'."
    :lsp t
    :messages '("Hodge-podge mark-up language"))

  :config
  (ligature-set-ligatures 'html-mode '("<!--" "-->" "</" "/>")))
#+END_SRC

*** nxml-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+begin_src emacs-lisp
(use-package nxml-mode
  :ensure nil

  :init
  (wal/hook nxml-mode
    "Hook into `nxml-mode'."
    :lsp t
    :messages '("Extreme mark-up language")
    :prog-like t)

  :config
  (ligature-set-ligatures 'nxml-mode '("<!--" "-->" "</" "/>")))
#+end_src

*** yaml-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Sometimes things that do as well.

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :wal-ways nil

  :ensure nil

  :mode "\\.tpl\\'" ; Helm templates.

  :init
  (wal/hook yaml-mode
    "Hook into command `yaml-mode'."
    :messages '("JSON?! ... Ah, thank God it's you, YAML!")
    :prog-like t

    (flycheck-mode 1)))
#+END_SRC

*** css-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

We want quicker suggestions when in CSS modes.

#+BEGIN_SRC emacs-lisp
(use-package css-mode
  :ensure nil

  :mode ("\\.rasi" . css-mode)

  :init
  (wal/hook css-mode
    "Hook into `css-mode'."
    :tabs t
    :lsp t
    :corfu (0.1 2)
    :messages '("Centering? It's simple. Here's 15 ways to do it.")

    (add-node-modules-path)

    (when (executable-find "stylelint")
      (add-hook
       'lsp-after-open-hook
       (lambda ()
         (if (equal major-mode 'scss-mode)
             (setq-local flycheck-checker 'wal/scss-stylelint)
           (setq-local flycheck-checker 'css-stylelint)))
       nil t))))
#+END_SRC

*** pug-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Support for =pug= templates.

#+BEGIN_SRC emacs-lisp
(use-package pug-mode
  :wal-ways nil

  :ensure nil)
#+END_SRC

*** po-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Get text.

#+BEGIN_SRC emacs-lisp
(use-package po-mode
  :wal-ways nil

  :ensure nil)
#+END_SRC

*** graphql
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package graphql
  :wal-ways nil

  :ensure nil)
#+END_SRC

*** web-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :wal-ways nil

  :ensure nil

  :mode ("\\.vue\\'"
         "\\.blade.php\\'"
         "\\.component.html\\'")

  :init
  (wal/hook web-mode
    "Hook into `web-mode'."
    :lsp t
    :tabs t
    :messages '("This is the Internet"))

  :custom
  (web-mode-comment-style 2))
#+END_SRC

** Games

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack games
  "For game developers."
  :packages (gdscript-mode))
#+END_SRC

*** gdscript-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

The engine you've been waiting for.

**** Utility

#+BEGIN_SRC emacs-lisp
;; Workaround from https://github.com/godotengine/emacs-gdscript-mode#known-issues
(defun wal/with-json-data-ignored-for-gdscript (fun &rest args)
  "Advise FUN, passing ARGS.

This will ignore the error message resulting from Godot not
replying to the `JSONRPC' request."
  (if (string-equal major-mode "gdscript-mode")
      (let ((json-data (nth 0 args)))

        (unless (and (string= (gethash "jsonrpc" json-data "") "2.0")
                     (not (gethash "id" json-data nil))
                     (not (gethash "method" json-data nil)))
          (apply fun args)))
    (apply fun args)))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package gdscript-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook gdscript-mode
    "Hook into `gdscript-mode'."
    :lsp t
    :tabs always
    :corfu (0.2 3)
    :messages '("I wish you were Estra-gone"))

  :config
  (advice-add 'lsp--get-message-type :around
   #'wal/with-json-data-ignored-for-gdscript))
#+END_SRC

** Jakt

On the hunt for yet another language.

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack jakt
  "Go on a hunt with Jakt."
  :recipes ((jakt-mode
             :fetcher url
             :url "https://raw.githubusercontent.com/Walheimat/jakt/main/editors/emacs/jakt-mode.el")))
#+END_SRC

*** jakt-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

This mode is currently included in the main repo.

#+BEGIN_SRC emacs-lisp
(use-package jakt-mode
  :wal-ways nil

  :ensure nil

  :quelpa
  (jakt-mode
   :fetcher url
   :url "https://raw.githubusercontent.com/Walheimat/jakt/main/editors/emacs/jakt-mode.el")

  :mode "\\.jakt\\'")
#+END_SRC

** Prolog

*** prolog-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+BEGIN_SRC emacs-lisp
(use-package prolog
  :ensure nil

  :config
  (ligature-set-ligatures 'prolog-mode '(":-")))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-lang)

;;; wal-lang.el ends here
#+END_SRC

* Fixing Things
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-fix.el" wal/emacs-config-package-path)
:END:

Please let me know when I screwed up. I promise I will learn.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-fix.el --- Fixing things. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide fixing packages.

;;; Code:

(eval-when-compile
  (require 'flycheck nil t))

(declare-function wdb/side "wal-func.el")
(declare-function wal/major "wal-key-bindings.el")
(declare-function flycheck-parse-stylelint "ext:flycheck.el")
(declare-function flycheck-buffer-nonempty-p "ext:flycheck.el")

(defvar wal/consult-map)
#+END_SRC

** Packages

*** flycheck
:PROPERTIES:
:UNNUMBERED: t
:END:

=flycheck= is for all of our linting/code quality needs.

**** Utility

#+BEGIN_SRC emacs-lisp
(defconst wal/flycheck-file--buffer "*wal-flycheck-file*")

(defun wal/flycheck-file--get-buffer ()
  "Get a buffer for FILENAME to display errors in."
  (unless (get-buffer wal/flycheck-file--buffer)
    (with-current-buffer (get-buffer-create wal/flycheck-file--buffer)
      (view-mode 1)))
  (get-buffer wal/flycheck-file--buffer))

(defun wal/flycheck-file--erase ()
  "Erase the flycheck buffer."
  (with-current-buffer (wal/flycheck-file--get-buffer)
    (setq buffer-read-only nil)
    (erase-buffer)
    (setq buffer-read-only t)))

(defun wal/flycheck-file--write (message &optional skip-newline)
  "Write MESSAGE to the file check buffer.

Optionally don't concat a newline char if SKIP-NEWLINE is t."
  (let ((buffer (wal/flycheck-file--get-buffer)))

    (with-current-buffer buffer
      (setq buffer-read-only nil)
      (goto-char (point-max))
      (insert  message)
      (unless skip-newline (insert "\n"))
      (setq buffer-read-only t))))

(defun wal/flycheck-file--callback (file buffer &optional defer-display kill-buffer)
  "Show errors in FILE in a distinct buffer.

Unless DEFER-DISPLAY is t, show it.

If KILL-BUFFER is t, also kill its BUFFER."
  (lambda (_status &optional errors)
    (let* ((output-buffer (wal/flycheck-file--get-buffer))
           (filename (file-name-nondirectory file)))

      (if (null errors)
          (wal/flycheck-file--write (format "No errors in '%s'." filename))
        (wal/flycheck-file--write (format "Errors in file '%s':" filename))
        (seq-do (lambda (err)
                  (when-let ((err-message (flycheck-error-message err))
                             (line (flycheck-error-line err)))

                    (wal/flycheck-file--write (format "line %d: %s\n" line err-message))))
                errors))

      (unless defer-display (display-buffer output-buffer))

      (when kill-buffer (kill-buffer buffer)))))

(defun wal/flycheck-file (file &optional defer-display kill-buffer)
  "Check FILE with flycheck.

Display it afterwards unless DEFER-DISPLAY is t.

If KILL-BUFFER is t, kill the file's buffer."
  (interactive "fSelect file: ")

  (when (and (fboundp 'flycheck-get-checker-for-buffer)
             (fboundp 'flycheck-syntax-check-new)
             (fboundp 'flycheck-compute-working-directory)
             (fboundp 'flycheck-syntax-check-start))
    (with-current-buffer (find-file-noselect file)
      (let ((checker (flycheck-get-checker-for-buffer)))

        (if checker
            (let* ((check (flycheck-syntax-check-new
                           :buffer (current-buffer)
                           :checker checker
                           :context nil
                           :working-directory (flycheck-compute-working-directory checker)))
                   (callback (wal/flycheck-file--callback file (current-buffer) defer-display kill-buffer)))

              (flycheck-syntax-check-start check callback))
          (user-error "Couldn't determine checker for file"))))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :commands (wal/flycheck-file)

  :hook ((sh-set-shell) . flycheck-mode)

  :config
  (wdb/side flycheck-error-list-buffer)

  ;; TEMP: https://github.com/flycheck/flycheck/pull/1944
  (flycheck-define-checker wal/scss-stylelint
    "Same as default but not passing `--syntax' flag."
    :command ("stylelint"
              (eval flycheck-stylelint-args)
              (option-flag "--quiet" flycheck-stylelint-quiet)
              (config-file "--config" flycheck-stylelintrc))
    :standard-input t
    :error-parser flycheck-parse-stylelint
    :predicate flycheck-buffer-nonempty-p
    :modes (scss-mode))

  (wal/major "f" '(:keymap flycheck-command-map :wk "flycheck"))

  :custom
  (flycheck-mode-line-prefix "fly"))
#+END_SRC

*** flyspell
:PROPERTIES:
:UNNUMBERED: t
:END:

My spelling is bad. Uses American English for =flyspell=.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/flyspell ()
  "(De-)Activate the appropriate `flyspell' mode."
  (interactive)

  (if flyspell-mode
      (flyspell-mode -1)
    (if (derived-mode-p 'prog-mode)
        (flyspell-prog-mode)
      (flyspell-mode))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :ensure nil

  :init
  (defvar wal/flyspell-map (make-sparse-keymap))

  :custom
  (flyspell-issue-message-flag nil)
  (flyspell-mode-line-string " fsp")
  (flyspell-default-dictionary "american")

  :bind
  (:map flyspell-mode-map
   ("C-." . ispell-word)  ; Replaces `flyspell-auto-correct-word', which is still available via `C-M-i'.

   :map wal/flyspell-map
   ("s" . wal/flyspell)
   ("b" . flyspell-buffer)
   ("r" . flyspell-region)
   ("c" . ispell-change-dictionary))

  :bind-keymap
  (("C-c s" . wal/flyspell-map)))
#+END_SRC

*** consult-flycheck
:PROPERTIES:
:UNNUMBERED: t
:END:

Find errors by severity.

#+BEGIN_SRC emacs-lisp
(use-package consult-flycheck
  :defer 2
  :after (consult flycheck)

  :bind
  (:map wal/consult-map
   ("!" . consult-flycheck)))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-fix)

;;; wal-fix.el ends here
#+END_SRC

* LSP
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-lsp.el" wal/emacs-config-package-path)
:END:

Language servers are awesome. Thanks, Microsoft.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-lsp.el --- LSP. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide LSP packages.

;;; Code:

(eval-when-compile
  (require 'dash)
  (require 'wal-func (expand-file-name "wal-func.el" ".")))

(declare-function dap--completing-read "ext:dap-mode.el")
(declare-function dap--json-encode "ext:dap-mode.el")
(declare-function dap-register-debug-template "ext:dap-mode.el")
(declare-function hydra-disable "ext:hydra.el")
(declare-function wal/dap-hydra/body "wal-lsp.el")
(declare-function wal/tempel-setup-capf "wal-edit.el")

(defvar dap-debug-template-configurations)

(defgroup wal-lsp nil
  "Change settings for LSP packages."
  :group 'wal
  :tag "LSP")

(defcustom wal/lsp-slow-modes '()
  "Modes that have slow language servers.

For these modes `corfu' settings will not be adjusted to be
smaller."
  :type '(repeat symbol)
  :group 'wal-lsp)
#+END_SRC

** Packages

#+begin_src emacs-lisp
(wal/define-expansion-pack lsp
  "Docker and Kubernetes."
  :extras (lsp-sonarlint))
#+end_src

*** lsp-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

=lsp-mode= is the fancy version. You'll have to install some language
servers yourself[fn:15].

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/slow-lsp-p (mode)
  "Check if MODE is considered slow."
  (memq mode wal/lsp-slow-modes))

(defun wal/lsp ()
  "Defer LSP setup for the file.

Sets up completion styles to use `orderless' unless the mode is
considered slow."
  (unless (wal/slow-lsp-p major-mode)
    (setq-local completion-styles '(orderless partial-completion basic)))

  (lsp-deferred))

(defun wal/lsp-completion ()
  "Make sure completion works well with `corfu' and `orderless'."
  (unless (wal/slow-lsp-p major-mode)
    (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
          completion-styles)))

(defun wal/first-prevent-adding-other-projects (&rest _args)
  "Prevent adding workspace roots from other projects."
  (eval '(setf (lsp-session-server-id->folders (lsp-session)) (ht))))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :wal-ways nil

  :hook (lsp-completion-mode . wal/lsp-completion)

  :config
  ;; Integrate with other packages.
  (require 'avy nil t)

  ;; Additional ignores.
  (wal/append
   'lsp-file-watch-ignored-directories
   '("[/\\\\]build\\'" "[/\\\\]vendor\\'"))

  ;; Don't keep track of multiple projects.
  (advice-add 'lsp :before #'wal/first-prevent-adding-other-projects)

  (wal/transient-define-prefix-once wal/lsp-dispatch ()
    "Call `lsp-mode' functions."
    [["Format"
      ("f" "buffer" lsp-format-buffer)
      ("F" "region" lsp-format-region)]
     ["Actions"
      ("a" "execute" lsp-execute-code-action)
      ("l" "jump to lens" lsp-avy-lens)
      ("h" "highlight symbol" lsp-document-highlight)]
     ["Refactor"
      ("r" "rename" lsp-rename)
      ("o" "organize imports" lsp-organize-imports)]
     ["Go to"
      ("d" "definition" lsp-find-definition)
      ("e" "errors" lsp-treemacs-errors-list)
      ("H" "hierarchy" lsp-treemacs-call-hierarchy)]
     ["Workspace"
      ("R" "restart" lsp-workspace-restart)
      ("Q" "quit" lsp-workspace-shutdown)]])

  ;; JavaScript.
  (with-eval-after-load 'js
    (transient-append-suffix 'wal/js-mode-dispatch '(0 0 -1)
      '("r" "rename file" lsp-javascript-rename-file)))

  ;; Command map.
  (setq lsp-keymap-prefix (wal/key-combo-for-leader 'wal/major "l" t))
  (lsp-enable-which-key-integration t)
  (wal/major-sink "l" '(:keymap lsp-command-map :wk "LSP"))

  :custom
  ;; Simplify visuals.
  (lsp-headerline-breadcrumb-enable nil)
  (lsp-signature-render-documentation nil)
  (lsp-signature-function 'lsp-signature-posframe)
  (lsp-signature-auto-activate '(:on-server-request))

  ;; Play nice with `corfu'.
  (lsp-completion-provider :none)

  (lsp-enable-snippet nil)

  (lsp-keep-workspace-alive nil)

  ;; Individual servers.
  (lsp-pylsp-plugins-jedi-use-pyenv-environment t)
  (lsp-clients-typescript-log-verbosity "off")
  (lsp-rust-analyzer-cargo-watch-command "clippy")
  (lsp-xml-format-split-attributes t)
  (lsp-xml-format-space-before-empty-close-tag nil)
  (lsp-xml-format-split-attributes-indent-size 1)

  :general
  (wal/major :keymaps 'lsp-mode-map "l" '(wal/lsp-dispatch :wk "lsp"))

  :delight
  (lsp-mode " lsp")
  (lsp-lens-mode " lns"))
#+END_SRC

*** lsp-ui
:PROPERTIES:
:UNNUMBERED: t
:END:

Don't clutter things up too much.

#+BEGIN_SRC emacs-lisp
(use-package lsp-ui
  :wal-ways nil

  :after lsp-mode

  :custom
  (lsp-ui-doc-show-with-cursor t)
  ;; No sideline stuff.
  (lsp-ui-sideline-enable nil)

  ;; Late and smaller docs.
  (lsp-ui-doc-delay 1.0)
  (lsp-ui-doc-max-height 30)
  (lsp-ui-doc-max-width 100)
  (lsp-ui-doc-text-scale-level -1))
#+END_SRC

*** dap-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Debugging using VSCode's DAP (in =lsp-mode=). Have a look at the
[[file:docs/debug-templates.org][templates]].

**** Utility

#+BEGIN_SRC emacs-lisp
(defvar wal/dap-before nil)

(defun wal/dap-terminated (_session)
  "Disable hydra and restore window configuration."
  (hydra-disable)

  (when wal/dap-before
    (set-window-configuration wal/dap-before)))

(defun wal/dap-session-created (&rest _r)
  "Save window configuration and delete other windows."
  (setq wal/dap-before (current-window-configuration))

  (delete-other-windows))

(defun wal/dap-stopped (_session)
  "Re-display the hydra."
  (wal/dap-hydra/body))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package dap-mode
  :wal-ways nil

  :after lsp-mode

  :hook (dap-session-created . wal/dap-session-created)

  :config
  ;; Activate UI and configure.
  (dap-auto-configure-mode)

  (add-hook 'dap-terminated-hook #'wal/dap-terminated t)
  (add-hook 'dap-stopped-hook #'wal/dap-stopped t)

  (with-no-warnings
    (defhydra wal/dap-hydra (:hint nil :foreign-keys warn)
      "
%s`w/hew Debug: _n_ext _c_ontinue %s`w/hs _i_n _o_ut
"
      ("n" dap-next)
      ("i" dap-step-in)
      ("o" dap-step-out)
      ("c" dap-continue)

      ("s" dap-debug "start" :color blue)
      ("x" dap-disconnect "disconnect" :color blue)
      ("b" dap-breakpoint-toggle "breakpoint" :color blue)

      ("q" nil)))

  (wal/replace-in-alist
   'dap-ui-buffer-configurations
   `((,dap-ui--repl-buffer . ((side . bottom) (slot . 1) (window-height . 10)))
     (,dap-ui--locals-buffer . ((side . right) (slot . 1)))))

  (wdb/side dap-ui--repl-buffer :no-other t)
  (wdb/side dap-ui--locals-buffer :side 'right :no-other t)

  :custom
  (dap-auto-show-output nil)
  (dap-auto-configure-features '(locals repl))

  (dap-python-executable "python3")
  (dap-python-debugger 'debugpy)

  :general
  (wal/major :keymaps 'lsp-mode-map "b" '(wal/dap-hydra/body :wk "debug"))

  :delight " dap")
#+END_SRC

*** consult-lsp
:PROPERTIES:
:UNNUMBERED: t
:END:

Jump to symbols with =consult=.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/ignore-if-no-lsp (&rest _args)
  "Don't call the function if `lsp-mode' is nil."
  (if (bound-and-true-p lsp-mode)
      t
    (message "Not in a LSP buffer")
    nil))
#+END_SRC

**** Configuration

#+begin_src emacs-lisp
(use-package consult-lsp
  :wal-ways nil

  :after (consult lsp-mode)

  :config
  (advice-add
   'consult-lsp-file-symbols :before-while
   #'wal/ignore-if-no-lsp)

  :bind
  (:map wal/consult-map
   ("s" . consult-lsp-file-symbols)))
#+end_src

** lsp-sonarlint
:PROPERTIES:
:UNNUMBERED: t
:END:

Some more linting.

#+begin_src emacs-lisp
(use-package lsp-sonarlint
  :ensure nil

  :wal-ways nil

  :config
  (require 'lsp-sonarlint-java)

  :custom
  (lsp-sonarlint-java-enabled t)

  :demand
  :after lsp-mode)
#+end_src

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-lsp)

;;; wal-lsp.el ends here
#+END_SRC

* DevOps
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-devops.el" wal/emacs-config-package-path)
:END:

Put it into a container and throw it in the garbage that is the
Internet.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-devops.el --- DevOps. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide DevOps packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))
#+END_SRC

** Docker

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack docker
  "Docker and Kubernetes."
  :packages (docker dockerfile-mode))
#+END_SRC

*** docker
:PROPERTIES:
:UNNUMBERED: t
:END:

What goes =docker-compose= up, goes =docker-compose= down.

#+BEGIN_SRC emacs-lisp
(use-package docker
  :wal-ways nil

  :ensure nil

  :config
  (wdb/side "\\*docker-containers\\*" :side 'top :height 15)
  (wdb/pop-up "^\\* docker container")
  (wdb/pop-up "^\\* docker-compose")

  :custom
  (docker-run-async-with-buffer-function 'docker-run-async-with-buffer-shell)
  (docker-container-default-sort-key '("Names"))
  (docker-image-default-sort-key '("Created" . t))
  (docker-volume-default-sort-key '("Name"))
  (docker-show-status nil)

  :general
  (wal/major "d" 'docker))
#+END_SRC

*** dockerfile-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

Make =Dockerfiles= look nice.

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :wal-ways nil

  :ensure nil

  :init
  (wal/hook dockerfile-mode
    "Hook into `dockerfile-mode'."
    :messages '("Have you ever given?")))
#+END_SRC

** Kubernetes

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack kubernetes
  "Kubernetes."
  :packages (kubernetes))
#+END_SRC

*** kubernetes
:PROPERTIES:
:UNNUMBERED: t
:END:

Who doesn't like pods and stuff?

#+BEGIN_SRC emacs-lisp
(use-package kubernetes
  :if (executable-find "kubectl")

  :wal-ways nil

  :ensure nil

  :custom
  (kubernetes-commands-display-buffer-function 'display-buffer)
  (kubernetes-poll-frequency 3600)
  (kubernetes-redraw-frequency 3600)
  (kubernetes-default-overview-view 'deployments)
  (kubernetes-json-mode (if (featurep 'jsonian-mode) 'jsonian-mode 'js-mode))

  :general
  (wal/major "8" '(kubernetes-overview :wk "kubernetes")))
#+END_SRC

** Jenkins

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack jenkins
  "Kubernetes."
  :packages (jenkinsfile-mode))
#+END_SRC

*** jenkinsfile-mode
:PROPERTIES:
:UNNUMBERED: t
:END:

#+begin_src emacs-lisp
(use-package jenkinsfile-mode
  :wal-ways nil

  :ensure nil

  :mode "Jenkinsfile")
#+end_src

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-devops)

;;; wal-devops.el ends here
#+END_SRC

* The Internet
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-web.el" wal/emacs-config-package-path)
:END:

I browse, I request.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-web.el --- The Internet. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide web packages.

;;; Code:

(eval-when-compile
  (require 'wal-func (expand-file-name "wal-func.el" ".")))
#+END_SRC

** Requests

*** verb
:PROPERTIES:
:UNNUMBERED: t
:END:

Make requests using Org.

**** Utility

#+BEGIN_SRC emacs-lisp
(defun wal/pick-windows-being-kept (&rest _args)
  "Provide t to `verb-kill-*' functions to keep window."
  (list t))
#+END_SRC

**** Configuration

#+BEGIN_SRC emacs-lisp
(use-package verb
  :wal-ways nil

  :after org

  :commands (wal/verb)

  :init
  ;; Make the tag available.
  (add-to-list 'org-tag-alist '("verb" . ?v))

  ;; Make sure windows are being kept.
  (advice-add
   'verb-kill-all-response-buffers :filter-args
   #'wal/pick-windows-being-kept)
  (advice-add
   'verb-kill-response-buffer-and-window :filter-args
   #'wal/pick-windows-being-kept)

  :config
  (wal/transient-define-prefix-once wal/verb ()
    "Dispatch `verb' commands."
    [["Request"
      ("r" "send" verb-send-request-on-point
       :inapt-if-non-nil verb-response-body-mode)
      ("e" "export" verb-export-request-on-point
       :inapt-if-non-nil verb-response-body-mode)]
     ["Response"
      ("R" "resend" verb-re-send-request
       :inapt-if-nil verb-response-body-mode)
      ("k" "kill all" verb-kill-all-response-buffers)]
     ["Variables"
      ("v" "set" verb-set-var)
      ("V" "show" verb-show-vars)]])

  :bind
  (:map verb-response-body-mode-map
   ("k" . verb-kill-buffer-and-window)
   ("q" . quit-window))

  :general
  (wal/major :keymaps '(verb-mode-map verb-response-body-mode-map)
    "v" '(wal/verb :wk "verb"))

  :delight
  (verb-mode " vrb")
  (verb-response-body-mode " vRb"))
#+END_SRC

** E-Mails

#+BEGIN_SRC emacs-lisp
(wal/define-expansion-pack mailing
  "For people reading/writing emails in Emacs."
  :packages (smtpmail))
#+END_SRC

*** mu4e
:PROPERTIES:
:UNNUMBERED: t
:END:

You either need to install =maildir-utils= or build from [[https://github.com/djcb/mu][source]].

#+BEGIN_SRC emacs-lisp
(use-package mu4e
  :if (executable-find "mu")
  :wal-ways nil

  :ensure nil

  :config
  (setq mail-user-agent 'mu4e-user-agent)

  :custom
  (mu4e-confirm-quit nil)
  (mu4e-completing-read-function 'completing-read)
  (mu4e-compose-dont-reply-to-self t)
  (mu4e-get-mail-command "offlineimap") ; This one works nicely.

  :general
  (wal/major "@" 'mu4e))
#+END_SRC

*** smtpmail
:PROPERTIES:
:UNNUMBERED: t
:END:

This configuration is from a (kind of) working [[https://www.djcbsoftware.nl/code/mu/mu4e/Gmail-configuration.html][Gmail setup]].

I recommend putting personal data in a =site-start.el= file somewhere in
your =load-path=.

#+BEGIN_SRC emacs-lisp
(use-package smtpmail
  :wal-ways nil

  :ensure nil

  :custom
  (message-send-mail-function 'smtpmail-send-it)
  (message-kill-buffer-on-exit t)
  (starttls-use-gnutls t))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-web)

;;; wal-web.el ends here
#+END_SRC

* Writing
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-writing.el" wal/emacs-config-package-path)
:END:

Sometimes you have to sit down and write something.

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-writing.el --- Writing. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide writing packages.

;;; Code:
#+END_SRC

** Packages

*** typo
:PROPERTIES:
:UNNUMBERED: t
:END:

Access complex punctuation. To me this doesn't necessarily make sense
for all =text-mode= modes (like =org-mode=), so instead it needs to be
triggered explicitly.

#+BEGIN_SRC emacs-lisp
(use-package typo
  :wal-ways nil

  :hook (typo-mode . flycheck-mode)

  :delight " typ")
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-writing)

;;; wal-writing.el ends here
#+END_SRC

* Fluff
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal-fluff.el" wal/emacs-config-package-path)
:END:

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal-fluff.el --- Fluff. -*- lexical-binding: t -*-

;;; Commentary:
;;
;; Provide fluff packages. These are not installed by default.

;;; Code:
#+END_SRC

** Packages

*** tokei
:PROPERTIES:
:UNNUMBERED: t
:END:

Display code statistics.

#+BEGIN_SRC emacs-lisp
(use-package tokei
  :if (executable-find "tokei")
  :wal-ways nil

  :ensure nil)
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal-fluff)

;;; wal-fluff.el ends here
#+END_SRC

* Config Package
:PROPERTIES:
:header-args:emacs-lisp: :tangle (expand-file-name "wal.el" wal/emacs-config-package-path)
:END:

** Header
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
;;; wal.el --- Walheimat's literate Emacs configuration. -*- lexical-binding: t -*-

;; Version: 1.7.12
;; Package-Requires: ((emacs "28.1"))

;;; Commentary:
;;
;; Require all sub-packages.

;;; Code:

(declare-function posframe-delete "ext:posframe.el")
(declare-function wal/async-process "wal-func.el")
(declare-function wal/directory-files "init.el")
(declare-function wal/flycheck-file "wal-fix.el")
(declare-function wal/flycheck-file--erase "wal-fix.el")
(declare-function wal/flycheck-file--get-buffer "wal-fix.el")
(declare-function wal/matches-in-string "wal-func.el")
(declare-function wal/tangle-config "wal-prelude.el")

(defvar wal/emacs-config-default-path)
(defvar wal/emacs-config-package-path)

(defgroup wal nil
  "Walheimat's configuration."
  :group 'convenience
  :prefix "wal/")

(defgroup wal-config nil
  "Customize configuring the packages."
  :group 'wal
  :tag "Configuration")

(defcustom wal/config-show-whale-animation t
  "Whether to show an animated whale while editing the config."
  :type 'boolean
  :group 'wal-config)

(defcustom wal/config-ascii-whale 'blue
  "The whale to use in the config animation."
  :type '(choice (const :tag "Blue whale" blue)
                 (const :tag "Cachalot" cachalot))
  :group 'wal-config)
#+END_SRC

** Lovable Things

*** Whale Animation

Animate a swimming whale in a =posframe=.

#+BEGIN_SRC emacs-lisp
(defvar wal/ascii-whale--fins (list "-" "'" "-" ","))

(defun wal/ascii-whale--build-key-frames (pattern)
  "Build key frames using PATTERN."
  (seq--into-vector
   (seq-map (lambda (it)
              (format pattern it))
            wal/ascii-whale--fins)))

(defvar wal/ascii-cachalot-whale-key-frames
  (wal/ascii-whale--build-key-frames "(__.%s >{"))

(defvar wal/ascii-blue-whale-key-frames
  (wal/ascii-whale--build-key-frames "âŽ   ï¬ž %s    {"))

(defvar wal/ascii-whale-key-frames nil)

(defvar wal/ascii-whale-frame-index 0)
(defvar wal/ascii-whale-animation-speed 0.4)

(defvar wal/ascii-whale-buffer "*swimming-whale*")
(defvar wal/ascii-whale-timer nil)
(defvar wal/ascii-whale-parent-buffer nil)

(defun wal/ascii-whale-animate ()
  "Animate the ASCII whale."
  (with-current-buffer (get-buffer-create wal/ascii-whale-buffer)
    ;; Clear.
    (erase-buffer)

    ;; Render current frame.
    (let* ((frame (aref wal/ascii-whale-key-frames wal/ascii-whale-frame-index))
           (colored (propertize frame 'face `(:foreground ,(face-attribute 'default :background)
                                              :background ,(face-attribute 'cursor :background)))))

      (insert colored)

      ;; Advance to the next frame.
      (setq wal/ascii-whale-frame-index
            (mod
             (1+ wal/ascii-whale-frame-index)
             (length wal/ascii-whale-key-frames))))))

(defun wal/ascii-whale-setup ()
  "Set up the animated whale."
  (require 'posframe nil t)

  (when (featurep 'posframe)
    ;; Integrate in current window configuration.
    (setq wal/ascii-whale-parent-buffer (current-buffer))

    (pcase wal/config-ascii-whale
      ('blue
       (setq wal/ascii-whale-key-frames wal/ascii-blue-whale-key-frames))
      ('cachalot
       (setq wal/ascii-whale-key-frames wal/ascii-cachalot-whale-key-frames))
      (_ (user-error "Unknown whale %s" wal/config-ascii-whale)))

    (add-hook 'kill-buffer-hook #'wal/ascii-whale-clean-up nil t)
    (add-hook 'window-configuration-change-hook #'wal/ascii-whale-display nil t)

    ;; Queue up timer.
    (unless wal/ascii-whale-timer
      (setq wal/ascii-whale-timer (run-with-timer
                                   0
                                   wal/ascii-whale-animation-speed
                                   #'wal/ascii-whale-animate)))

    ;; Increase the font size.
    (with-current-buffer (get-buffer-create wal/ascii-whale-buffer)
      (defvar wal/fixed-font-height)
      (let ((fheight (* 2 wal/fixed-font-height)))

        (face-remap-add-relative 'default :height fheight)))

    ;; Make sure the first frame is animated before we display.
    (wal/ascii-whale-animate)

    (wal/ascii-whale-display)))

(defun wal/ascii-whale-clean-up ()
  "Clean up the animation."
  ;; Cancel and void the timer.
  (when wal/ascii-whale-timer
    (cancel-timer wal/ascii-whale-timer)
    (setq wal/ascii-whale-timer nil))

  ;; Delete the frame.
  (posframe-delete wal/ascii-whale-buffer)

  ;; Remove animation and re-positioning hooks.
  (remove-hook 'kill-buffer-hook #'wal/ascii-whale-clean-up t)
  (remove-hook 'window-configuration-change-hook #'wal/ascii-whale-display t))

(defun wal/ascii-whale-poshandler (info)
  "Position handler for ASCII whale.

INFO contains positioning information."
  (let* ((window-left (plist-get info :parent-window-left))
         (window-top (plist-get info :parent-window-top))
         (window-width (plist-get info :parent-window-width))
         (posframe-width (plist-get info :posframe-width))

         ;; Offset the frame, taking the pixel-height of a line into
         ;; account.
         (p-window (plist-get info :parent-window))
         (p-line-height (with-selected-window p-window (line-pixel-height)))
         (offset-x p-line-height)
         (offset-y p-line-height))

    (cons (- (+ window-left window-width
                (- 0 posframe-width))
             offset-x)
          (+ window-top offset-y))))

(defun wal/ascii-whale-hidehandler (info)
  "Check INFO whether the parent buffer is invisible."
  (and-let* ((parent (cdr (plist-get info :posframe-parent-buffer)))
             (invisible (not (get-buffer-window parent t))))))

(defun wal/ascii-whale-display ()
  "Display the running animation in a posframe."
  (let ((default-frame-alist nil))
    (posframe-show
     wal/ascii-whale-buffer
     :accept-focus nil
     :border-width (pcase wal/config-ascii-whale ('blue 12) ('cachalot 6) (_ 6))
     :border-color (face-attribute 'cursor :background)
     :poshandler 'wal/ascii-whale-poshandler
     :posframe-parent-buffer (or wal/ascii-whale-parent-buffer (current-buffer))
     :hidehandler 'wal/ascii-whale-hidehandler)))

(defun wal/ascii-whale-toggle-display ()
  "Toggle the animation."
  (interactive)

  (if wal/ascii-whale-timer
      (wal/ascii-whale-clean-up)
    (wal/ascii-whale-setup)))
#+END_SRC

** Editing the Config

Minor mode for editing this config.

*** Version Info

#+BEGIN_SRC emacs-lisp
(defvar wal/tangle-do-prompt t
  "Whether to prompt user to tangle config.")

(defvar wal/config-mode-map (make-sparse-keymap)
  "Map for `wal/config-mode'.")

(defun wal/describe-config-version ()
  "Describe the config's version.

This returns the tag and its annotation as propertized strings."
  (interactive)

  (let* ((default-directory wal/emacs-config-default-path)
         (version (propertize
                   (string-trim
                    (shell-command-to-string "git describe --abbrev=0"))
                   'face 'bold))
         (cat (propertize
               (string-trim
                (shell-command-to-string (format "git cat-file tag %s" version)))
               'face 'italic))
         (out (concat version ": " (car (last (string-lines cat))))))

    (cond
     (noninteractive out)
     (t (message out)))))

(defun wal/show-config-diff-range ()
  "Call `magit-diff-range' with the latest tag."
  (interactive)

  (let ((version (shell-command-to-string "git describe --abbrev=0")))

    (magit-diff-range (string-trim version) '("--stat"))))
#+END_SRC

*** Tangling

#+BEGIN_SRC emacs-lisp
(defun wal/tangle-config-prompt ()
  "Prompt the user to tangle the config.
If the answer is no, there will be no additional prompt."
  (interactive)

  (let ((help-form (message "This will update your packages. Restart Emacs afterwards.")))

    (if (and wal/tangle-do-prompt (y-or-n-p "Config changed, want to tangle? "))
        (wal/tangle-config)
      (if wal/tangle-do-prompt
          (progn
            (setq-local wal/tangle-do-prompt nil)
            (message "To tangle, call `wal/tangle-config'"))
        (message "Config changed. To tangle, call `wal/tangle-config'")))))
#+END_SRC

*** The Config Itself

#+BEGIN_SRC emacs-lisp
(defun wal/find-config ()
  "Find Walheimat's config.

This will activate minor mode `wal/config-mode'."
  (interactive)

  (let ((buf (find-file-noselect (expand-file-name "README.org" wal/emacs-config-default-path))))

    (switch-to-buffer buf)
    (add-hook 'after-revert-hook #'wal/tangle-config-prompt nil t)

    (when wal/config-show-whale-animation
      (wal/ascii-whale-setup))))

(defun wal/customize-group ()
  "Customize `wal' group."
  (interactive)

  (customize-group 'wal t))
#+END_SRC

*** Coverage

#+BEGIN_SRC emacs-lisp
(defun wal/check-coverage--add (buf type)
  "Add all numbers of TYPE in buffer BUF."
  (let* ((regex (concat type ": \\(?1:[[:digit:]]+\\)"))
         (content (with-current-buffer buf (buffer-string)))
         (numbers (wal/matches-in-string regex content)))

    (apply '+ (mapcar #'string-to-number numbers))))

(defun wal/check-coverage--buffer-number (buf)
  "Get the count of BUF."
  (let* ((regex "\\(?1:[[:digit:]]+\\)")
         (content (with-current-buffer buf (buffer-name)))
         (numbers (wal/matches-in-string regex content))
         (number (car-safe numbers)))

    (if number (string-to-number number) 0)))

(defun wal/check-coverage--calculate-coverage ()
  "Calculate the full coverage."
  (when-let* ((buffers (seq-filter (lambda (it) (string-match "\\*wal-async" (buffer-name it))) (buffer-list)))
              (compare (lambda (a b)
                         (> (wal/check-coverage--buffer-number a)
                            (wal/check-coverage--buffer-number b))))
              (filtered (seq-sort compare buffers))
              (latest (car filtered))
              (relevant (wal/check-coverage--add latest "Relevant"))
              (covered (wal/check-coverage--add latest "Covered")))

    (format "%.2f%%" (* 100 (/ (float covered) relevant)))))

(defun wal/check-coverage ()
  "Check the current coverage for custom functionality."
  (interactive)

  (let* ((command "cask exec ert-runner && cat coverage.txt"))

    (wal/coverage--execute
     command
     (lambda ()
       (let ((average (wal/check-coverage--calculate-coverage)))

         (message "All tests succeeded. Coverage: %s" average)))
     (lambda (str) (message "Tests fail: %s" str)))))

(defun wal/create-json-coverage ()
  "Create a JSON report file."
  (interactive)

  (let ((command "export COVERAGE_WITH_JSON=true && cask exec ert-runner"))

    (wal/coverage--execute
     command
     (lambda () (message "Coverage created"))
     (lambda (str) (message "Failed to create coverage: %s" str)))))

(defun wal/coverage--execute (command on-success on-failure)
  "Execute coverage command.

Runs COMMAND asynchronously and passes ON-SUCCESS and ON-FAILURE
handlers.

BUFFER-SUFFIX is a string to make sure existing buffers of that
name are deleted beforehand."
  (unless (executable-find "cask")
    (user-error "You need to install `cask' binary"))

  (let ((full-command (concat "cd " wal/emacs-config-default-path " && " command)))

    (wal/async-process full-command on-success on-failure t)))
#+END_SRC

*** Checking

#+BEGIN_SRC emacs-lisp
(defun wal/package-files ()
  "Get the package files."
  (let* ((package-files (wal/directory-files wal/emacs-config-package-path))
         (el-files (seq-filter
                    (lambda (it)
                      (string-equal (file-name-extension it)
                                    "el"))
                    package-files)))

    el-files))

(defun wal/checkdoc-config-packages ()
  "Run `checkdoc-file' on all package files."
  (interactive)

  (require 'checkdoc nil t)

  (dolist (it (wal/package-files))
    (checkdoc-file it)))

(defun wal/flycheck-config-packages ()
  "Run `wal/flycheck' on all config package files."
  (interactive)

  (let ((output-buffer (wal/flycheck-file--get-buffer)))

    (wal/flycheck-file--erase)
    (display-buffer output-buffer)

    (dolist (it (wal/package-files))
      (wal/flycheck-file it t t))))
#+END_SRC

** Footer
:PROPERTIES:
:VISIBILITY: folded
:END:

#+BEGIN_SRC emacs-lisp
(provide 'wal)

;;; wal.el ends here
#+END_SRC

* Footnotes

[fn:1] Jumped ship from =27.1=. Some minor things might not work there.
I currently use this config in =28.1.50= and =29.0.50=.

[fn:2] If you're feeling adventurous, [[https://git.savannah.gnu.org/cgit/emacs.git/tree/INSTALL][build from source]].

[fn:3] If you're not sure where your =user-emacs-directory= might be,
you can do the following:

+ Run Emacs
+ hit =M-x= (that is your Alt/Option key followed by the letter =x=)
+ type =describe-variable= and hit return
+ type =user-emacs-directory= and hit return again.

A window should pop up telling you the path.

Finally run =git clone git@gitlab.com:Walheimat/emacs-config.git
~/.emacs.d= (replace =~/.emacs.d= with your actual path if it differs).

[fn:4] This includes this very config which will be exported as a
package collection.

Packages that belong to an expansion pack (mainly language-specific
packages) or its extras need to be installed manually by calling
=wal/install-expansion-pack=.

[fn:5] Which means that a frame is reused or created and control
immediately returned. If you're using Emacs 29, consider using
=emacsclient -r= to reuse an existing frame.

[fn:6] Not including where =:tangle no= was set.

/Note/ they will not necessarily be evaluated in the same order they
appear in this file. The order of evaluation is determined by the
[[file:setup/wal-prelude.el][prelude]].

[fn:7] Send me an email, why don't you?

[fn:8] Sometimes you have to play using other people's rules. You can run
=add-dir-local-variable= to do so. Check out the =.dir-locals.el= template
found in the =/templates= folder for an example using spaces.

[fn:9] To get a full overview you'll have to call
=describe-personal-keybindings= and =general-describe-keybindings=.

[fn:10] Alternate spelling is "expansion pak".

[fn:11] The =all-the-icons= icons need to be downloaded manually by
running =M-x all-the-icons-install-fonts= and selecting =yes=.

If the installation process should fail for any reason, close Emacs
and re-run it.

[fn:12] You might have to call =emojify-download-emoji= to download a
set that supports your emojis.

[fn:13] If you're on an older distro your =libvterm= package might be
too old.

[fn:14] Currently requires [[https://daseldocs.tomwright.me/installation#manual ][dasel]].

[fn:15] All languages listed [[https://emacs-lsp.github.io/lsp-mode/page/languages/][here]].
